---
title: 设计模式（一）创建型模式
date: 2020-04-10 10:23:28
tags:	[设计模式]
---

|范围\目的|创建型模式|
|:--|:--|
|类模式|工厂方法|
|对象模式 |单例<br/>原型<br/>抽象工厂<br/>建造者|


创建型模式（Creational Pattern）的主要特点是将`对象的创建与使用分离`，根据对象的创建与组合方式的不同，创建型模式可分为单例（Singleton）模式、原型（Prototype）模式、工厂方法（Factory Method）模式、抽象工厂（Abstract Factory）模式和建造者（Builder）模式 5 种。

***

# 工厂方法

***定义***
工厂方法（FactoryMethod）模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。



***简单工厂模式***
创建产品不多，使用同一个工厂类，不属于23种设计模式之一，违背了开闭原则

***结构***
工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成
+	抽象工厂 创建产品的接口
+	具体工厂 创建产品
+	抽象产品 产品规范
+	具体产品 产品细节

![gcff](/image/degin-pattern/gcff.png)

***
# 抽象工厂模式
在工厂方法中，只考虑同种等级的产品；但是，在实际应用中，多产品才是主流。而 抽象工厂模式则考虑多等级产品的生产。
如下图所示，同种类型的产品是同等级的；而同一个牌子的产品，则是同一个产品族的：
![gcff](/image/degin-pattern/cpz.png)

***定义***
抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。

抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。

使用抽象工厂模式一般要满足以下条件。
系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。
系统一次只可能消费其中某一族产品，即同族的产品一起使用。

抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。
可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
当增加一个新的产品族时不需要修改原代码，满足开闭原则。

其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。

***结构***
+	抽象工厂 创建产品的接口,包含不同等级的产品
+	具体工厂 创建产品(某一产品族)
+	抽象产品 产品规范
+	具体产品 产品细节

![抽象工厂](/image/degin-pattern/cxgc.png)


***
# 单例模式
***定义***

单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。


***特点***

+	单例类只有一个实例对象；
+	该单例对象必须由单例类自行创建；
+	单例类对外提供一个访问该单例的全局访问点；

***分类***
+	懒汉式
	+	需要时再加载（可能存在线程安全问题）
+	饿汉式
	+	类加载后就创建
![抽象工厂](/image/degin-pattern/dl-lh.png)

***
# 原型模式
***定义***
用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。 

> 注：由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。但自定义类需要重写clone()，实现深克隆


***结构***
+	抽象原型类：规定了具体原型对象必须实现的接口。
+	具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。
+	访问类：使用具体原型类中的 clone() 方法来复制新的对象。

![原型模式](/image/degin-pattern/yxms.png)

***通过反射实现通用克隆的方法***
需要参数：类，类对应的对象


***
# 建造者模式（Bulider模式）
***定义***
建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。

该模式的主要优点如下：
各个具体的建造者相互独立，有利于系统的扩展。
客户端不必知道产品内部组成的细节，便于控制细节风险。

其缺点如下：
产品的组成部分必须相同，这限制了其使用范围。
如果产品的内部变化复杂，该模式会增加很多的建造者类。


***结构***

建造者（Builder）模式的主要角色如下。
+	产品角色（Product）：多个部件对象，由具体建造者来创建其各个部件。
+	抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。
+	具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。
+	指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。

![建造者模式](/image/degin-pattern/jzzms.png)
***
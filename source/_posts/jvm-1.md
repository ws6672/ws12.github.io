---
title: jvm探索（一）体系结构
date: 2020-03-30 14:41:53
tags: [java]
---
众所周知，Java的代码会被编译成字节码，而字节码则会被JRE执行。那么，什么是JRE呢？

JRE即Java运行环境（Java Runtime Environment，简称JRE），是 java虚拟机 （JVM）的实现。它的作用有：分析、解释并执行字节码。作为开发人员，了解JVM的体系结构非常重要，因为它使我们能够更高效地编写代码。在本文中，我们将更深入地了解Java中的JVM体系结构以及JVM的不同组件。

### 一、什么是JVM
JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。

JAVA的基础理念之一就是：一次编译,到处运行。编译器将Java编译成一个`.class`文件，然后输入到JVM中，对它进行加载并运行;而实际运行的是JRE, 即JVM的具体实现，借助于JVM的不同实现完成了`一次编译,到处执行`的目标。

JVM体系结构如下：
![JVM体系结构](/image/jvm/JVM.png)

JVM 主要被划分为三个主要的子系统：
+	BootStrap ClassLoader（启动类加载器） 
	+	最顶层的加载类，主要加载核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等.
+	extension ClassLoader（拓展类加载器） 
	+	负责加载ext文件夹（jre/lib）内的类。。还可以加载`-D java.ext.dirs`选项指定的目录。
+	Application ClassLoader（应用类加载器）
	+	负责加载应用程序级别的类路径（当前应用）


### 二、类加载器子系统
Java的类动态加载功能由`类加载器子系统`处理。它会加载、链接类，并在`运行时`（而非编译时）首次引用类时初始化类文件。

***1.加载***
类加载器（class loader）用来加载 Java 类到 Java 虚拟机中，主要分为以下三种类型：
+	启动（Bootstrap）类加载器
+	扩展（Extension）类加载器
+	系统（System）类加载器

***2.链接***
2.1 验证 字节码验证程序将验证生成的字节码是否正确
2.2 准备 将为所有静态变量分配内存并为其分配默认值
2.3 解析 将所有符号内存引用替换为“方法区域”中的原始引用


***3.初始化***
所有静态变量将被分配原始值，并且将执行静态块中的代码。

***4.什么是双亲委派模型***

4.1 类加载器结构
![JVM双亲委派模型](/image/jvm/jvm-sqwp.png)

如果一个类加载器收到了类加载请求，它不会首先加载这个类，而是将请求委派给父类加载器去完成；因此，请求最终会传递到顶层的引导类加载器，如果它无法处理（在范围内无法检索到相应类），子加载器才会尝试自己去加载这个类

4.2 采用双亲委托模型的原因*
+	使得Java类随着类加载器不同而具备带优先级的层次关系，如java.lang.Object（位于rt.jar内），无论那个类加载器要加载该类，最终都委派给顶层引导类加载器，因此Object类在程序的各种类加载环境中都是同一个类。
+	如果不存在该机制，而都是由自定义类加载器进行处理，那将会使得系统带有多个同名的类，使得基础的Java类型体系混乱。
+	如果加载失败，则调用自身的findClass()方法加载

4.3 破坏双亲委派情形
+	使用JNDI服务
+	代码模块热部署

### 三、运行时数据区
运行时数据区主要分为以下五个部分：
+	方法区 
	+	所有类级别的数据（包括静态变量）都将存储在此处。每个JVM只有一个方法区域，它是共享资源
+	堆空间
	+	所有对象及其对应的实例变量和数组将存储在此处。由于`方法区`和`堆空间`为多个线程提供共享的内存，因此存储的数据不是线程安全的。
+	栈空间（又名堆栈）
	+	对于每个线程，将创建一个单独的运行时栈
	+	一个栈中可以有多个栈帧，栈帧随着方法的调用而创建，随着方法的结束而消亡。
	+	栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。
+	PC寄存器
	+	每个线程启动的时候，都会创建一个PC（Program Counter，程序计数器）寄存器。PC寄存器里保存有当前正在执行的JVM指令的地址。
	+	PC寄存器的内容总是指向下一条将被执行指令的地址，这里的地址可以是一个本地指针，也可以是在方法区中相对应于该方法起始指令的偏移量。
+	本地方法栈
	+	本地方法栈是为虚拟机使用到的Native方法服务,保存了本地方法信息。对于每个线程，将创建一个单独的本地方法栈。
	
### 四、执行引擎
分为以下三个部分：
+	解释器
	+	解释器解释字节码的速度较快，但执行速度较慢。解释器的缺点是，当多次调用一种方法时，每次都需要新的解释。
+	JIT 编译器
	+	JIT编译器消除了解释器的缺点。执行引擎将使用解释器的帮助来转换字节码，但是当发现重复的代码时，它将使用JIT编译器，该编译器将编译整个字节码并将其更改为本地代码。此本地代码将直接用于重复的方法调用，从而提高系统性能。
		+	1.中间代码生成器 –产生中间代码
		+	2.代码优化器 –负责优化上面生成的中间代码
		+	3.目标代码生成器 –负责生成机器代码或本机代码
		+	4.Profiler –一个特殊的组件，负责查找热点，即是否多次调用该方法。
+	垃圾回收
	+	收集并删除未引用的对象。垃圾回收可以通过调用触发 `System.gc()`，但不能保证执行。JVM的垃圾收集收集创建的对象。
	
	
### 五、参考文章
> [The JVM Architecture Explained](https://dzone.com/articles/jvm-architecture-explained)
[深入JVM 双亲委派模型](https://blog.csdn.net/qq_33369979/article/details/87934364)
雅可比矩阵
在向量微积分中，雅可比矩阵是一阶偏导数以一定方式排列成的矩阵，其行列式称为雅可比行列式。雅可比矩阵的重要性在于它体现了一个可微方程与给出点的最优线性逼近。因此，雅可比矩阵类似于多元函数的导数。 

残差在数理统计中是指实际观察值与估计值（拟合值）之间的差。“残差”蕴含了有关模型基本假设的重要信息。


对于非循环图，协同初始化是没有必要的，因为它能够将输入从根传播到叶子作为输出。但是，最常见情况是图中混合了无环和强连通分量（SCC）。为了提高效率，所有SCC都应以并行方式解决。


基于雅可比矩阵计算的牛顿-拉夫森算法（NR）：
+	计算输入迭代残差
+	生成雅可比矩阵
+	解答雅可比矩阵
+	应用修正参数到输入
+	直到满足给定的公差

新的迭代传播算法（IP）的运行方式与Newton Raphson相同，唯一的区别是不计算Jacobian矩阵，而是用恒等矩阵代替。因为避免了雅可比计算，IP比NR快得多，但通用性却比NR差。但是，它合适于某种特定场景，特别是在配电网络（无网格的电网）中的潮流计算（电网中的FMU交换电压和流动电流）


Github Actions 核心概念
Runner 用来跑 CI/CD build 的服务器
Github Hosted Runner Github 官方提供的 Runner
Self-Hosted Runner 自定义Runner
Workflow 定义CI/CD的流程


本文档定义了功能模拟接口（FMI）2.0版。 FMI是一种独立于工具的标准，可以使用xml文件和C代码（在DLL /共享库中编译或在源代码中编译）的组合来支持模型交换和动态模型的共同仿真。

# FMI程序接口

1. 模型交换

支持该功能是为了在建模环境中可以生成动态系统模型的C代码，该模型可以被其他建模和仿真环境使用。通过代数、离散方程和具有时间，状态和阶跃事件的离散方程来描述模型。如果C代码描述了一个连续的系统，那么该系统将由使用它的环境的集成商来解决。该接口要处理的模型可以很大，可以在离线或在线仿真中使用，也可以在微处理器的嵌入式控制系统中使用。设计该接口是旨在描述大型模型。

2. 协同仿真

支持该功能的意图是提供一个接口标准，用于在协同仿真环境中与其它仿真工具协同工作。子系统之间的数据交换仅限于离散的通信点（通讯时间）；在两个通信点之外的时间中，子系统由各自的求解器彼此独立地求解。主算法控制子系统之间的数据交换以及所有模拟求解器（从属）的同步。

3. FMI通用概念

这两个接口标准有很多共同点。我们可以利用模型以及协同仿真工具的多个实例单独或协同的将它们连接在一起。这些接口独立于目标环境，因为没有使用依赖于目标环境的头文件（目标平台的数据类型除外）。这允许生成一个可在同一平台上的任何环境中使用的动态链接库。

4. FMU

模型、协同仿真从属/工具的关联部分被存储在一个称为FMU（功能模拟单元）的zip文件中，包含以下内容：
+	XML包含FMU中所有公开变量的定义以及其他静态信息。这样就可以在没有此信息的情况下在目标系统上运行FMU
+	提供了所需的模型方程式或联合仿真工具的访问权限，并提供了一小组易于使用的C函数。与其他方法相比，一种新的缓存技术可以更有效地评估模型方程；同一平台的FMU zip文件中可以包含不同平台的二进制格式
+	可以直接在FMU中提供模型方程式或联合仿真工具，或与外部工具通信的功能模块。
+	包含模型图标（位图文件）、FMU所需的文档文件、地图和表格

FMU包含文件如下：
+	XML 用于描述模型
+	DLL 运行库
+	其它用户所需资源


FMU模型的数据流：
+	数据类型为 Real, Integer, Boolean, String
+	inputs
+	outputs
+	对外暴露的变量

5. 头文件和函数命名

提供了几个头文件，它们定义了FMU的接口。在所有头文件中，均约定所有相关的C函数和类型定义均使用前缀“fmi2”开头


“fmi2TypesPlatform.h“：包含函数的输入和输出参数的类型定义，FMU和目标模拟器都必须使用此头文件。
“fmi2FunctionTypes.h“：包含FMU所有函数原型的 typedef 定义
“fmi2Functions.h“；包含FMU的函数原型，这些原型可以在仿真环境中访问


以上的定义目的是支持FMU的文本表示和二进制表示，并且可执行文件中可能同时存在多个FMU（例如FMU A可以使用FMU B）。所有，不同的fmu中函数名应当不一致，避免同时使用时冲突。fmu函数库的用法如下：
```
	// FMU is shipped with C source code, or with static link library 
	#define  FMI2_FUNCTION_PREFIX MyModel_ 
	#include "fmi2Functions.h" 
	< usage of the FMU functions > 
	// FMU is shipped with DLL/SharedObject 

	#include "fmi2Functions.h" 
	< usage of the FMU functions >
```

6. 类型平台

“fmi2TypesPlatform.h”：包含类型平台的所有定义，用于唯一地标识用于编译二进制文件的头文件，相关源码如下：

```
#ifndef fmi2TypesPlatform_h
#define fmi2TypesPlatform_h
#define fmi2TypesPlatform "default"

   typedef void*           fmi2Component;               /* 该数据结构包含处理模型方程式或处理各个从站的协同仿真所需的信息 */
   typedef void*           fmi2ComponentEnvironment;    /* 可以在仿真环境和记录器功能之间传输来自modelDescription.xml文件 */
   typedef void*           fmi2FMUstate;                /* 保存实际或先前时刻的内部FMU状态*/
   typedef unsigned int    fmi2ValueReference; /* 模型变量值的句柄，句柄和基类型（例如fmi2Real）唯一地标识变量的值*/
   typedef double          fmi2Real   ;
   typedef int             fmi2Integer;
   typedef int             fmi2Boolean;
   typedef char            fmi2Char;
   typedef const fmi2Char* fmi2String;
   typedef char            fmi2Byte;
#define fmi2True  1
#define fmi2False 0
#endif

```

7. 函数返回值

文件中定义了“状态”标识（在文件“ fmi2FunctionTypes.h”中定义的fmi2Status类型的枚举），所有函数均返回该标志以指示函数调用成功：
```
	typedef	enum{
		fmi2OK,
		fmi2Warning, 
		fmi2Discard, 
		fmi2Error, 
		fmi2Fatal, 
		fmi2Pending
	} fmi2Status;
```

8. 初始化，终止和重置FMU

fmi2SetupExperiment函数会在fmi2Instantiate被调用之后和fmi2EnterInitializationMode被调用之前调用，参数公差定义和公差取决于FMU类型
```
fmi2Status fmi2SetupExperiment (fmi2Component c,
								fmi2Boolean   toleranceDefined,
								fmi2Real      tolerance, 
								fmi2Real      startTime,
								fmi2Boolean   stopTimeDefined, 
								fmi2Real    stopTime);
						
```

`fmuType = fmi2ModelExchange`: 如果“ toleranceDefined = fmi2True”，则使用数值积分方案调用模型，其中通过使用“ tolerance”控制误差来控制步长（通常使用相对公差）
`fmuType = fmi2CoSimulation`：如果“toleranceDefined = fmi2True”，通信间隔由估计估计误差控制；如果从站具有可变步长和估计误差的积分，那么通过公差来控制通信间隔

参数 startTime 和 stopTime 可用于检查模型在给定范围内是否有效，或分配存储结果所需的内存。如果当前时间超过 stopTime，则FMU必须返回fmi2Status = fmi2Error。如果stopTimeDefined = fmi2False，则没有定义自变量的最终值，并且参数stopTime没有意义。


相关函数定义：
```
-- 使FMU进入初始化模式
fmi2Status fmi2EnterInitializationMode(fmi2Component c);
-- 使FMU退出初始化模式
fmi2Status fmi2ExitInitializationMode(fmi2Component c);
-- 终止FMU
fmi2Status fmi2Terminate(fmi2Component c);
-- 重置FMU
fmi2Status fmi2Reset(fmi2Component c);
```

9. 偏导数的支持

fmi标准可以选择评估FMU的偏导数。对于模型交换，这意味着在特定时刻计算偏导数；对于协同仿真，这意味着要在特定的通信点上计算偏导数。fmi标准提供了一种函数来计算方向导数，此函数可用于构造所需的偏导数矩阵。

```
fmi2Status fmi2GetDirectionalDerivative(fmi2Component c, 
		const fmi2ValueReference vUnknown_ref[], 
		size_t nUnknown, 
		const fmi2ValueReference vKnown_ref[]  , 
		size_t nKnown,
		const fmi2Real dvKnown[], 
		fmi2Real dvUnknown[])

初始化模式（Initialization Mode）：在<ModelStructure> <InitialUnknowns>下列出的公开类型为实数的未知数。

连续时间模式（Continuous-Time Mode —— ModelExchange）：连续时间输出和状态导数（在<ModelStructure> <Outputs>下列出的类型为Real和variability ='continuous'的变量，以及在<ModelStructure> <Derivatives>下列出为状态导数的变量）。

事件模式（Event Mode —— ModelExchange）：与连续时间模式中相同的变量，以及<ModelStructure> <Outputs>下类型为Real和variability ='discrete'的变量

步进模式（Step Mode —— CoSimulation）：在<ModelStructure> <Outputs>下列出的类型为Real且variability ='continuous'或'discrete'的变量。如果存在<ModelStructure> <Derivatives>，则此处列出的变量也是状态导数。

```

# FMI描述架构

与FMU相关的所有静态信息都以XML格式存储在文本文件modelDescription.xml中(FMU变量及其属性（例如名称，单位，默认初始值等）存储在此文件中)。使用模式文件“ fmiModelDescription.xsd”定义此XML文件的结构。该架构文件使用了以下辅助架构文件：

+	fmi2Unit.xsd
+	fmi2Type.xsd
+	fmi2Annotation.xsd
+	fmi2ScalarVariable.xsd
+	fmi2AttributeGroups.xsd
+	fmi2VariableDependency.xsd

类型表示：
```
xs:double 表示 double
xs:int 表示  int
xs:unsignedInt 表示   unsigned int
xs:boolean 表示  char
xs:string 表示  char*
xs:normalizedString 表示  char*
xs:dateTime tool 表示  specific

```

XML文件的第一行（例如modelDescription.xml）必须包含XML文件的编码方案,要求编码方案始终为UTF-8.


如下，是根级别的架构文件，包含以下定义（下图包含架构文件中的所有元素，数据由这些元素的属性定义）：

![元素架构](/image/co-simulation/fmi-md.png)

1. fmu定义（fmiModelDescription）

顶层元素包含以下元素：
+	ModelExchange 如果存在，则FMU基于“用于模型交换的FMI”（换句话说，FMU包含模型或与提供模型的工具进行通信，而环境提供模拟引擎）。
+	CoSimulation 如果存在，则FMU基于“用于协同仿真的FMI”（换句话说，FMU包括模型和仿真引擎，或者与提供模型和仿真引擎的工具进行通信，该环境提供了主算法来运行耦合的FMU协同仿真从设备以共同运行)。
+	UnitDefinitions 单位和显示单位定义的全局列表（例如，将显示单位转换为模型方程式中使用的单位）。这些定义在XML元素“ ModelVariables”中使用
+	TypeDefinitions “ ModelVariables”中使用的类型定义列表
+	LogCategories 日志类别的全局列表，可以设置该列表以定义FMU支持的日志信息
+	DefaultExperiment 提供积分的默认设置，例如停止时间和相对公差
+	VendorAnnotations 供应商可能想要存储而其他供应商可能会忽略的其他数据
+	ModelVariables 定义了FMU的所有变量
+	ModelStructure 定义模型的结构，包括输出，连续时间状态和初始未知数

![元素架构-属性](/image/co-simulation/fmi-md-attr.png)

2. Units定义（变量单位）

变量的单位是（可选）自定义的，单位的支持对于技术系统很重要，因为很容易发生错误。相关定义如下


![变量单位](/image/co-simulation/fmi-unit.png)
![变量单位](/image/co-simulation/fmi-unit2.png)


3. 类型定义（TypeDefinitions）

该元素是一个名为“SimpleType”的集合，在 fmi2Type.xsd文件中的 fmi2SimpleType 架构下定义的
相关定义如下

![类型定义](/image/co-simulation/fmi-type.png)

4. 日志类别的定义（LogCategories）
LogCategories定义了一组无序的类别字符串，可用于通过函数“ logger”定义日志输出。“名称”属性对于LogCategories列表的所有其他元素必须是唯一的

![日志类别的定义](/image/co-simulation/fmi-log.png)

5. 默认实验的定义（DefaultExperiment）

DefaultExperiment由可选的默认开始时间、停止时间、相对公差和第一次仿真运行的步长组成（工具可能会忽略此信息）。但是，对于用户来说方便的是startTime、stopTime、tolerance和stepSize已经为手头的模型提供了有意义的默认值。此外，对于CoSimulation，stepSize定义了首选的通信。


![默认实验的定义](/image/co-simulation/fmi-de.png)

6. 供应商注释的定义（VendorAnnotations）

VendorAnnotations由一组有序的注释组成，这些注释由可以解释“ any”元素的工具名称标识。 “ any”元素可以是由工具定义的任意XML数据结构；属性“name”对于VendorAnnotationlist的所有其他元素必须是唯一的

![供应商注释的定义](/image/co-simulation/fmi-annotation.png)

7. 模型变量的定义（ModelVariables）


![默认实验的定义](/image/co-simulation/fmi-variables.png)

8. 模型结构的定义（ModelStructure）

![模型结构的定义](/image/co-simulation/fmi-ms.png)


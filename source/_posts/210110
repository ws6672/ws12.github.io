
jdk5.0————很重要的特性就是增加了并发包java.util.concurrent，用于优化多线程的使用，包含了锁相关的一些类、线程池相关的一些类。

# 一、基础

***体系划分***

![concurrent包体系划分](/image/current/currentjg.png)



在学习并发包之前，需要学习一些前置知识：
+	内存模型
+	内存屏障
+	volatile变量
+	CAS机制
+	AbstractQueuedSynchronizer（AQS同步器）




### 2. java内存模型
 
在内存模型中可见，每个线程都存在着一个单独栈空间。具体内存结构如下：
 
![JVM体系结构](/image/jvm/JVM.png)


Java程序初始化顺序：

父类的静态代码块
子类的静态代码块
父类的普通代码块
父类的构造方法
子类的普通代码块
子类的构造方法




### volatile变量
 
1. 基础
 ![volatile](/image/java-bf/volatile.png)
 
 `volatile` 用于声明一个共享变量，它只能保证数据的可见性，而不能保证原子化。
 
 +	可见性，不同线程可以访问同一变量。
 +	不保证原子性，被 `volatile`声明的变量的自增操作无法保证线程安全。`不要将volatile用在getAndOperate场合.(即获取操作后不能连着修改操作)`
 
 ![volatile](/image/java-bf/volatile2.png)
 
2. 使用
```
private volatile boolean flag = true;
private volatile int num = 0;
@Test
public void test() {
	//线程安全
    if (flag) {
        System.out.println(flag);
        flag = false;
        // 业务代码
    }
	//非线程安全
	num++;
}
```

3. 为什么volatile无法保证原子性

`i++`会被编译成：

```
mov    0xc(%r10),%r8d ; Load
inc    %r8d           ; Increment
mov    %r8d,0xc(%r10) ; Store
lock addl $0x0,(%rsp) ; StoreLoad Barrier 内存屏障
```

被`volatile`声明的变量，如果使用累加操作（非原子操作），被编译成汇编语言时，写操作会导致添加一个写内存屏障。在执行写屏障之前，如果其它线程提前一步修改了值，就会被丢失。







 
> interrupt()方法:仅仅使线程中打了一个停止的标记，并不是真的停止线程

***




### 请求策略

***顺序请求***

按顺序处理请求，每次只能处理一个
```
 public void test() {
        try {
            ServerSocket serverSocket = new ServerSocket(80);
            while (true) {
                //接收请求
                Socket connection = serverSocket.accept();
				//每次只能处理一个请求，效率差
                handleRequest(connection);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleRequest(Socket connection) {
        System.out.println(connection.getInetAddress());
    }
```

***每任务-每进程***

为每个请求构建独立线程，提高了吞吐量：

```
public void test() {
	try {
		ServerSocket serverSocket = new ServerSocket(80);
		while (true) {
			//接收请求
			final Socket connection = serverSocket.accept();
			Runnable runnable = new Runnable() {
				@Override
				public void run() {
					handleRequest(connection);
				}
			};
			new Thread(runnable).start();
		}
	} catch (IOException e) {
		e.printStackTrace();
	}
}
```

***无限制进程的缺点***

+	线程生命周期的开销
+	资源消耗
+	稳定性

### Executer 框架



![线程策略](/image/java-bf/xccl.png)

所以，我们需要Executer 框架。
+	这个框架可以用于异步任务执行，而且支持不同类型的任务执行策略；
+	对任务提交与任务执行进行解耦
+	支持生产者-消费者模式

***Executor接口***
在`java.util.concurrent`包中，有接口Executor就有类似的功能。接口定义如：

```
public interface Executor {
    void execute(Runnable command);
}
```

通过框架创建：
```
public class TaskExecutionWebServer {
    private static final int NUMBER = 10;
    private static final Executor exec = Executors.newFixedThreadPool(NUMBER);

    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(80);
        while (true) {
            //接收请求
            final Socket connection = serverSocket.accept();
            Runnable task = new Runnable() {
                @Override
                public void run() {
                   System.out.println(connection.getInetAddress());
                }
            };
            exec.execute(task);
        }
    }
}
```

。。。待续
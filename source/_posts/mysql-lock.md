---
title: mysql 引擎的行锁与表锁
date: 2021-03-30 23:47:49
tags: [mysql]
---


# 事务基础

1. ACID属性
+	原子性：事务不可分
+	一致性：在事务开始和完成时，数据都必须保持一致状态。
+	隔离性：并发的事务是相互隔离的。
+	持久性：事务完成之后，它对于数据的修改是永久性的

2. 并发事务的问题
+	更新丢失：多事务进行更新，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题最后的更 新覆盖了由其他事务所做的更新
+	脏读：事务在提交前，数据的修改可以被其它事务读取
+	不可重复读：同一个事务中前后两次读取的数据不一致
+	幻读：同一个事务中前后两次读取数据时，其他事务插入了满足其查询条件的新数据，导致读取的数据量不一致

3. 事务隔离级别
+	未提交读（Read uncommitted）：读数据一致性
+	已提交读（Read committed）：不会导致脏读（语句级）
+	可重复读（Repeatable read）：不会导致不可重复读（事务级）
+	可序列化（Serializable）：不会导致幻读（事务级）


# 行锁和表锁

在mysql 的 InnoDB引擎支持行锁，与Oracle不同，mysql的行锁是通过索引加载的，即是行锁是加在索引响应的行上的。如果SQL语句没有走索引，那么就无法触发行锁，而是会使用表锁。
+	表锁：不会出现死锁，发生锁冲突几率高，并发低。
+	行锁：会出现死锁，发生锁冲突几率低，并发高。

1. 锁分类
+	共享锁：读锁。当一个事务对某几行上读锁时，允许其他事务对这几行进行读操作，但不允许其进行写操作，也不允许其他事务给这几行上排它锁，但允许上读锁
+	排它锁：写锁，当一个事务对某几个上写锁时，不允许其他事务写，但允许读；更不允许其他事务给这几行上任何锁（包括写锁）

2. 要点
+	行锁必须有索引才能实现，否则会自动锁全表
+	两个事务不能锁同一个索引
+	语句涉及锁
	+	insert、delete、update在事务中都会自动默认加上排它锁
	+	普通SELECT语句，InnoDB不会加任何锁
	+	在insert操作时产生插入意向锁（不是意向锁）；在多事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等待
	+	表级锁还有一种比较特殊的锁：AUTO-INC Locks；这种锁只在向自增主键中插入记录时出现，这种锁是为自增主键设计的。锁机制如下：在向自增主键中插入记录时，其他insert事务都需要等待直到本事务的插入完成才能继续插入自增记录。
+	索引分为主键索引和非主键索引，如果SQL语句走主键索引MySQL会锁住该索引；如果SQL语句走普通索引，那么会锁住该普通索引，再锁住主键索引

3. 遇到的问题
+	死锁：如果两事务同时执行，事务A锁住主键索引，等待非主键索引；然后事务B锁住非主键索引，等待主键索引；那么就会陷入死锁。
+	锁冲突：锁不相容，如读锁和写锁

4. 处理锁冲突（意向锁）

MySQL 为了解决锁冲突，引入了 意向锁。意向锁就是一种不与行级锁冲突的表级锁，分类如下：
+	意向共享锁 （intention shared lock, IS）：事务有意向对表中的某些行加 共享锁（S锁）
+	意向排他锁 （intention exclusive lock, IX）：事务有意向对表中的某些行加 排他锁 （X锁）

例如：
```
-- 意向共享锁 IS
SELECT column FROM table ... LOCK IN SHARE MODE;
-- 意向排他锁 IX
SELECT column FROM table ... FOR UPDATE;
```

意向锁由数据引擎自己维护的，在为数据行加共享/排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。

模拟业务场景如下：
+	事务A查询数据，在涉及的行上加共享锁（行锁）之前，会先加意向共享锁（表锁）。
+	如果事务B要添加数据，需要加排他锁；
	+	如果没有意向锁，那么需要检测每一行，效率低下；
	+	有了意向锁后，发现有意向锁则表示：有其他事务有意向对表中的某些行加共享锁（S锁）；
	+	排他锁加锁快速失败。

5. 表锁的兼容性图

![表锁的兼容性](/image/mysql/lock.png)

# 参考文章
> [MySQL锁机制深入理解](https://www.linuxidc.com/Linux/2018-04/151914.htm)
(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)
(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )
(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )
(4) 父类构造函数
(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )
(6) 子类构造函数

内核实现策略：

1.微内核。最基本的功能由中央内核（微内核）实现。所有其他的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与中心内核通。代表系统是windows.

2.宏内核。内核的所有代码，包括子系统（如内存管理、文件管理、设备驱动程序）都打包到一个文件中。内核中的每一个函数都可以访问到内核中所有其他部分。目前支持模块的动态装卸(裁剪)。Linux内核就是基于这个策略实现的。代表系统是Linux


Linux进程
采用层次结构，每个进程都依赖于一个父进程

Linux中用到内核的地方：
+	进程通信
+	进程切换(同时执行的进程数最多不超过cpu数目)
+	进程调度（决定进程的运行时间）

Linux进程的特点如下：
+	采用层次结构，每个进程都依赖于一个父进程。内核启动init程序作为第一个进程。但是，通过pstree命令查询。实际上centos7 中第一个进程是systemd。
+	系统中每一个进程都有一个唯一标识符(ID),用户（或其他进程）可以使用ID来访问进程


init和Systemd的区别
+	init
	+	启动时间长
	+	串行启动，只有前一个进程启动完，才会启动下一个进程
	+	启动脚本复杂
	+	由Linux内核加载运行，位于 /sbin/init   ,是系统中第一个进程，PID永远为1
+	systemd
	+	按需启动服务
	+	尽可能并行启动进程，减少系统启动等待时间
	+	由Linx内核加载运行，位于 /usr/lib/systemd/systemd  ，是系统中第一个进程，PID永远为1

Linux内核源代码的目录结构
+	内核核心代码 各个子系统和子模块
+	其它非核心代码，例如库文件
+	编译脚本、配置文件、帮助文档、版权说明等辅助性文件

具体文件内容如下：
	include/ ---- 内核头文件，需要提供给外部模块（例如用户空间代码）使用。
	kernel/ ---- Linux内核的核心代码，包含了3.2小节所描述的进程调度子系统，以及和进程调度相关的模块。
	mm/ ---- 内存管理子系统（3.3小节）。
	fs/ ---- VFS子系统（3.4小节）。
	net/ ---- 不包括网络设备驱动的网络子系统（3.5小节）。	
	ipc/ ---- IPC（进程间通信）子系统。
	arch// ---- 体系结构相关的代码，例如arm, x86等等。
		arch//mach- ---- 具体的machine/board相关的代码。
		arch//include/asm ---- 体系结构相关的头文件。
		arch//boot/dts ---- 设备树（Device Tree）文件。
	init/ ---- Linux系统启动初始化相关的代码。
	block/ ---- 提供块设备的层次。
	sound/ ---- 音频相关的驱动及子系统，可以看作“音频子系统”。
	drivers/ ---- 设备驱动（在Linux kernel 3.10中，设备驱动占了49.4的代码量）。
	lib/ ---- 实现需要在内核中使用的库函数，例如CRC、FIFO、list、MD5等。
	crypto/ ----- 加密、解密相关的库函数。
	security/ ---- 提供安全特性（SELinux）。
	virt/ ---- 提供虚拟机技术（KVM等）的支持。
	usr/ ---- 用于生成initramfs的代码。
	firmware/ ---- 保存用于驱动第三方设备的固件。
	samples/ ---- 一些示例代码。
	tools/ ---- 一些常用工具，如性能剖析、自测试等。
	Kconfig, Kbuild, Makefile, scripts/ ---- 用于内核编译的配置文件、脚本等。
	COPYING ---- 版权声明。
	MAINTAINERS ----维护者名单。
	CREDITS ---- Linux主要的贡献者名单。
	REPORTING-BUGS ---- Bug上报的指南。
	Documentation, README ---- 帮助、说明文档。


+	用户空间：用户空间中又包含了，用户的应用程序，C库
+	内核空间：内核空间包括，系统调用，内核，以及与平台架构相关的代码
	+	系统调用接口
	+	进程管理
	+	内存管理
	+	虚拟文件系统
	+	网络堆栈
	+	设备驱动程序
	+	硬件架构的相关代码
	
	



jvm相关的基本知识

Java字节码文件的格式

Java源文件是 `.java`格式的，经过虚拟机编译后形成字节码文件，后缀为`.class`文件；jvm加载`.class`文件执行。

字节码文件是由魔数，版本号，常量池，访问标志，类索引，父类索引，接口索引，字段表集合，方法，属性组成。

+	魔数： 4个字节，对应的是16进制的cafe babe,其是表明class文件的标志
+	版本号：例如0000 0034，0000代表次版本号，0034代表主版本号（52），52对应1.8
+	常量池：常量池主要包含字面量和符号引用，字面量如文本字符串，final声明的变量等，符号引用主要是类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符
+	访问标志 Access_flag：声明class文件是类还是接口、声明访问权限
+	类索引、父类索引和接口索引
+	方法
+	属性


jvm的内存结构
jvm的内存结构分为三部分：类装载器子系统、运行时数据区、执行引擎。
+	类装载器子系统有三个类加载器，bootstrap class Loader、Extension class Loader、Application class Loader;
+	运行时数据区分为五个部分、两种类型；其一是共有的，如堆、方法区、本地方法栈；其二是线程私有的，如栈、PC寄存器。
	+	堆：堆可以分为年轻代、老年代和元空间
		+	年轻代：年轻代又分为新生区和两个幸存区，比例是8:1:1
		+	老年代：幸存区中多次存活的对象会存放到老年区
		+	元空间：JDK1.8之前称之为永久代，是方法区的实现，位于JVM中；而元空间与它类似，但位于本地内存。
	+	方法区：所有类级别的数据都存储在这个地方（包括静态变量），是共享资源
	+	本地方法栈：为虚拟机使用的native方法服务
	+	栈：线程的私有内存，存放线程的局部变量
	+	PC寄存器：用来存储执行下一条指令的地址，由执行引擎进行读取；线程私有，生命周期和线程生命周期保持一致。例如，ArrayList底层是一个数组;当遍历的时候，PC寄存器会存放指向 下一个单元的地址。




1. Netty 任务队列（TaskQueue）

TaskQueue的使用
+	用户自定义的普通任务
+	用户自定义定时任务
+	非当前Reactor线程调用Channel的各种方法

相关实例如下：
```class MyServerHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        ByteBuf byteBuf = Unpooled.copiedBuffer("你好，客户端", Charset.forName("utf-8"));
        ctx.writeAndFlush(byteBuf);
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
//        ByteBuf buf = (ByteBuf) msg;
//        byte[] req = new byte[buf.readableBytes()];
//        buf.readBytes(req);
//        String body = new String(req, "UTF-8");
//        System.out.println(body);

//        假设读取的数据过多，耗时严重；可以由TaskQueue响应任务
//        1. 用户自定义的普通任务（异步任务）
        ctx.channel().eventLoop().execute(new Runnable() {
            @Override
            public void run() {
                try {
                    ByteBuf buf = (ByteBuf) msg;
                    byte[] req = new byte[buf.readableBytes()];
                    buf.readBytes(req);
                    String body = new String(req, "UTF-8");
                    System.out.println(body);
                }  catch (Exception e) {
                    e.printStackTrace();
                }

            }
        });
//        2. 用户自定义定时任务
        ctx.channel().eventLoop().schedule(new Runnable() {
            @Override
            public void run() {
                System.out.println("用户自定义定时任务 执行 任务");
            }
        }, 1000, TimeUnit.MILLISECONDS);
//        3. 非当前Reactor线程调用Channel的各种方法
//        定义ChannelInitializer的 initChannel方法时，保存 SocketChannel到自定义队列；需要时，通过队列获取通道，通过通道的事件循环线程设置任务
    }

}
```

如上所示，任务队列其实是通过异步实现的。Netty的异步模型 是建立在 future和callback上的。callback是回调，如果有一个方法耗时严重，那么就返回一个 future。后续，我们可以通过 future 去监听方法的处理过程。


2. ChannelFuture

```
	serverBootstrap.group(bgroup, workerGroup)
		.channel(NioServerSocketChannel.class)
		.option(ChannelOption.SO_BACKLOG, 1024)
		.childHandler(new ChannelInitializer<SocketChannel>() {
			@Override
			protected void initChannel(SocketChannel sc) throws Exception {
//                            DelimiterBasedFrameDecoder：解码器，接收的数据进行解码，加在SimpleServerHandler 的上面；maxFrameLength表示这一贞最大的大小；delimiter表示分隔符
				sc.pipeline().addLast(new DelimiterBasedFrameDecoder(Integer.MAX_VALUE, Delimiters.lineDelimiter()[0]));
//                            将数据转换成byteBuf
				sc.pipeline().addLast(new MyServerHandler());
			}
		});
//          绑定端口8888
ChannelFuture channelFuture = serverBootstrap.bind(9090).sync();
```

ChannelFuture
+	表示通道异步执行结果，用于检测执行过程.
+	ChannelFuture 是一个接口，可以添加监听器，当监听的事件发生时，就好通知监听器。
	+	`    ChannelFuture addListener(GenericFutureListener<? extends Future<? super Void>> var1);`
	
pipeline()方法返回的是一个ChannelPipeline接口，这是一个双向队列。通过addLast方法，可以按序添加处理器。底层会形成一个链式操作，比如 （解码-数据传输-编码）。而通过serverBootstrap的sync()方法，可以获取ChannelFuture异步对象。通过这个对象可以获取责任链的执行结果。


---------------------------------------------------------------------------------------


/** Implementation for put and putIfAbsent */
    final V putVal(K key, V value, boolean onlyIfAbsent) {
	//	key or value 不允许为null
        if (key == null || value == null) throw new NullPointerException();
        int hash = spread(key.hashCode());
        int binCount = 0;
        for (Node<K,V>[] tab = table;;) {
            Node<K,V> f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0)
                tab = initTable();
				
            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                if (casTabAt(tab, i, null,
                             new Node<K,V>(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        if (fh >= 0) {
                            binCount = 1;
                            for (Node<K,V> e = f;; ++binCount) {
                                K ek;
                                if (e.hash == hash &&
                                    ((ek = e.key) == key ||
                                     (ek != null && key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node<K,V> pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node<K,V>(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        else if (f instanceof TreeBin) {
                            Node<K,V> p;
                            binCount = 2;
                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    if (binCount >= TREEIFY_THRESHOLD)
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        addCount(1L, binCount);
        return null;
    }
	

transient volatile Node<K,V>[] table; // 数组结构


private final Node<K,V>[] initTable() {
	Node<K,V>[] tab; int sc;
	while ((tab = table) == null || tab.length == 0) {
	
		/**
		 * sizeCtl ：默认为0，用来控制table的初始化和扩容操；
		 * -1 代表table正在初始化，保证只初始化一次
		 * -N对应的二进制的低16位数值为M，此时有M-1个线程进行扩容；
		 * 如果table初始化完成，表示table的容量，默认是table大小的0.75倍。
		 */
		if ((sc = sizeCtl) < 0)
			Thread.yield(); // 已经有线程进行初始化
			
			/**
			 * Unsafe compareAndSwapInt(Object var1, long var2, int var4, int var5);
			 * var1：要修改的对象起始地址
			 * var2：需要修改的具体内存地址
			 * var4：期望内存中的值
			 * var5：用于更新的值
			 */
		else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
			try {
				if ((tab = table) == null || tab.length == 0) {
					int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
					@SuppressWarnings("unchecked")
					Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
					table = tab = nt;
					// >>> 表示右移两位，n的四分之一，所以sc是n的四分之三
					sc = n - (n >>> 2);
				}
			} finally {
				sizeCtl = sc;
			}
			break;
		}
	}
	return tab;
}

修改sizeCtl的方法：

+	initTable()
+	addCount（）
+	tryPresize（）
+	transfer（）
+	helpTransfer（）



-------------------------------------------------------------------------------------------



属于被动引用不会出发子类初始化 
 1.子类引用父类的静态字段，只会触发子类的加载、父类的初始化，不会导致子类初始化 
 2.通过数组定义来引用类，不会触发此类的初始化 
 3.常量在编译阶段会进行常量优化，将常量存入调用类的常量池中， 本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 
 
-----------------------------------------------------------------------------------------------------------------


man命令

man命令用于查看命令的手册页条目。

[cen@localhost systemd]$ man fdisk
没有 disk 的手册页条目


fdisk命令
fdisk（以第一种形式调用）是一个以菜单问答形式出现的用来创建和修改分区的程序。它可以辩认 DOS 类型的分区表和 BSD 或 SUN 类型的磁盘标签。

设备通常是下列之一：
```
[cen@localhost systemd]$ sudo fdisk -l

hda一般是指IDE接口的硬盘
	/dev/hda hda指第一块硬盘
	/dev/hdb hdb指第二块硬盘
sda一般是指SATA接口的硬盘
	/dev/sda sda指第一块硬盘
	/dev/sdb sdb指第二块硬盘
```

其它类似的工具：
+	cfdisk（交互好） cfdisk是一个漂亮的程序，它只接受最严谨的分区表， 而且它能生成高质量的分区表。
+	sfdisk（功能强大）是一个专为黑客提供的程序，它的用户界面很不友善，但它更精确，也比fdisk和cfdisk更有效。

sed 命令
Linux sed 命令是利用脚本来处理文本文件。
sed 可依照脚本的指令来处理、编辑文本文件。
Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。

语法：
```
sed [-hnV][-e<script>][-f<script文件>][文本文件]

参数说明：
	-e<script>或--expression=<script> 以选项中指定的script来处理输入的文本文件。
	-f<script文件>或--file=<script文件> 以选项中指定的script文件来处理输入的文本文件。
	-h或--help 显示帮助。
	-n或--quiet或--silent 仅显示script处理后的结果。
	-V或--version 显示版本信息。
	
动作说明
	a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
	c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
	d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
	i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
	p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
	s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！
	
```

例如：

```
-- 第二行添加 NEWLINE 为一行
sed -e 2a\NEWLINE LICENSE.txt 
```

-----------------------------------------------------------------------------------------------------------------



# 一、Java基础


### Java IO

1. 什么是IO流
IO流是用来处理设备间的数据传输的，Java对数据的操作是通过流的形式，java对于流的操作都实现在io包中

2. Java中流的分类
Java中流按方向划分可以分为输入流和输出流、按实现功能划分可以分为顶点流（读写数据）和处理流（封装数据）、按类型划分可以分成字节流以及字符流。字节流继承于 InputStream 和 OutputStream，字符流继承于 InputStreamReader 和 OutputStreamWriter。

3. 字节流如何转为字符流
通过InputStreamReader可以将字节流如何转为字符流，通过OutPutStreamWriter可以将字符流转换为字节流

4. 如何将一个 java 对象序列化到文件里
实现Serializable接口，该接口没有任何方法，只是用于标记。

5. 字节流 和 字符流 的区别
+	字节流 是读到一个字节就返回一个字节；字符流读取到一个或多个字节时，先去查询指定的编码表，然后转换为对应的字符返回；
+	字节流 可以处理所有类型的数据，而字符流只能处理纯文本数据。

6. 字节缓冲输入流和字节缓冲输出流
字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多，这是加入了数组这样的缓冲区效果
+	字节缓冲输出流：BufferedOutputStream
+	字节缓冲输入流：BufferedInputStream

7. close( )和flush( )的区别?
+	close方法会先刷新一次流，再关闭流对象，之后流对象无法再使用。
+	flush方法只是用于刷新缓冲区

8. read()方法返回值为什么是int，而不是byte
因为如果读取到的byte 为11111111，即-1；那么表示读取到结尾，就不会继续读下去了。

9. 如何实现对象克隆
+	实现Cloneable接口并重写Object的clone方法
+	实现Serializable接口，通过序列化可以实现深拷贝

> [JAVA面试--IO](https://blog.csdn.net/huyang0304/article/details/82290626)

### 多线程

1. 进程，线程之间有什么区别
进程是系统运行和资源分配的基本单位，线程是系统资源的共享单位。一个程序至少一个进程，一个进程至少一个线程。

2. 守护线程和非守护线程有什么区别
守护线程需要等待其它非守护线程结束之后，才会停止，最典型的是垃圾回收器；jvm会等待非守护线程完成后关闭，但是jvm不会等待守护线程

3. 什么是多线程上下文切换
多线程的上下文切换是指由一个正在执行的线程切换到另一个处于就绪态并等待获取CPU执行时间的线程的过程

4. 怎么检测一个线程是否持有对象监视器
Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着”某条线程”指的是当前线程。

5. 怎么唤醒一个阻塞的线程
notify() notifyAll()

6. 一个线程如果出现了运行时异常怎么办
如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放

7. 如何在两个线程间共享数据
+	堆外内存 MappedByteBuffer
+	阻塞队列BlockingQueue
+	共享对象

8. 为什么要使用线程池
避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。

> [java 线程面试题](https://blog.csdn.net/weixin_42298927/article/details/114032614)


# 集合

1. 常用集合

集合（只能存储对象，对象类型可以不一样）的长度可变，可在多数情况下使用。

Collection接口是集合类的根接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了两个接口，就是Set和List。
+	Collection
	+	List 有序可重复
		+	LinkedList 底层是一个双链表的数组结构，适合删除、插入较多的业务，因为链表删除的时间复杂度是O(1)
		+	ArrayList 底层是一个数组，适合查询的较多的业务，因为数组底层是相连的
			+	实现接口：`List<E>(列表), RandomAccess(标记接口，快速随机访问), Cloneable(标记接口，克隆), java.io.Serializable(标记接口，序列化)`
			+	扩容：底层通过Arrays.copyOf（底层调用的是System.arraycopy）方法进行扩容，默认容量是10，扩容为1.5倍；如果扩容后小于最小容量，取最小容量。
			+	删除：使用System.arraycopy 进行元素覆盖，设置最后一个元素未null
		
	+	Set 无序、不可重复
		+	HashSet：实际为一个HashMap的实例，允许null元素
		+	TreeSet：用 二叉排序树 保证有序，底层用TreeMap实现

集合遍历：

+	Iterator/Iterable：迭代输出，是使用最多的输出方式。
	+	Iterator是java.util包下的接口
	+	Iterable是java.lang下的接口。Iterable只是包装了Iterator,从而允许实现此接口的对象成为foreach语句的目标
+	ListIterator：是Iterator的子接口，专门用于输出List中的内容。
+	foreach 输出：JDK1.5之后提供的新功能，可以输出数组或集合。
+	for循环

集合遍历的使用：

```
// 1. for循环
for（int i=0;i<arr.size();i++）{...} 
// 2. foreach
for（int　i：arr）{...} 
// 3. iterator
Iterator it = arr.iterator(); 
while(it.hasNext()){ object o =it.next(); ...}
```

2. Map集合

Map：存储的是键值对，键不能重复，值可以重复
+	HashMap（数组+链表+二叉排序树，元素超过8个就转换为红黑树）
+	TreeMap（用二叉排序树）
+	Hashtable：Hashtable与HashMap类似，是HashMap的线程安全版，它支持线程的同步；不允许记录的键或者值为null。
+	LinkedHashMap：保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性
+	TreeMap：实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序）

Map集合有的不支持并发，有的并发能力差。所以，java current包提供了Map接口的并发实现
+	ConcurrentHashMap：线程安全，并且锁分离。1.7 中，ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分；1.8中，使用CAS以及 voliate保证线程安全。

map遍历：
+	KeySet：set具备迭代器。所有可以迭代方式取出所有的键，再根据get方法。获取每一个键对应的值
+	entrySet：返回此映射中包含的映射关系的 Set 视图


---------------------------------------------------------------------------------------------------------

@Transactional 失效的几个可能

+	数据库引擎不支持事务：如MySQL的MyISAM 引擎不支持事务，自然就无法使用事务。
+	数据源没有配置事务管理器（DataSourceTransactionManager）
+	没有被 Spring 管理 （@Transactional 没有加入Spring容器中）
+	方法不是 public 的
+	自非事务方法调用事务方法
+	异常在事务中被处理
+	异常抛出错误，默认只能抛出运行时异常，可以设置 `@Transactional(rollbackFor = Exception.class)`



---------------------------------------------------------------------------------------------------------



SpringBoot整合EhCache
为了提高性能，减少数据库的压力，使用缓存是非常好的手段之一。Spring 定义 CacheManager 和 Cache 接口用来统一不同的缓存技术。例如 JCache、 EhCache、 Hazelcast、 Guava、 Redis 等。在使用 Spring 集成 Cache 的时候，我们需要注册实现的 CacheManager 的 Bean。




1. 测试url存活

URL.sh
```
#!/bin/bash 
check_url() {
-- $1 表示参数1，会自动注入到%{http_code}中
HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w "%{http_code}" $1

)
--	返回值测试
    if [ $HTTP_CODE -ne 200 ]; then
        echo "Warning: $1 Access failure!"
    else
        echo "网站正常"
    fi
}
check_url $1
```

2. 定时检测服务状态脚本

脚本功能：
+	定时监测该服务的返回状态，出现错误后，邮件告警
+	可自定义周期


--------------------------------------------------------


# 三、架构优化

架构优化包括主从复制、读写分离、负载均衡。

### 主从复制


主–从复制
主–主复制
半同步复制

1. 主从复制原理

Mysql 中有一种日志叫做 bin 日志（二进制日志）。这个日志会记录下所有修改了数据库的SQL 语句（insert,update,delete,create/alter/drop table, grant 等等）。主从复制的原理其实就是把主服务器上的 bin 日志复制到从服务器上执行一遍，这样数据就同步了。

![主从复制流程图](/image/mysql/mysql-master-slave.png)

+	线程
	+	主顶点
		+	Dump Thread：为每个 Slave 的 I/O Thread 启动一个 dump 线程，用于向从顶点发送二进制事件
	+	从顶点
		+	I/O Thread：从 Master 顶点请求二进制日志事件，并保存于Relay log（中继日志）中
		+	Sql Thread：从中继日志中读取日志事件并在本地完成重放

2. 复制过程

+	主顶点必须启用二进制日志，记录任何修改了数据库数据的事件。
+	从顶点开启一个线程（I/O Thread)把自己扮演成 mysql 的客户端，通过 mysql 协议，请求主顶点的二进制日志文件中的事件
+	主顶点启动一个线程（dump Thread），检查自己二进制日志中的事件，跟对方请求的位置对比，如果不带请求位置参数，则主顶点就会从第一个日志文件中的第一个事件一个一个发送给从顶点。
+	从顶点接收到主顶点发送过来的数据把它放置到中继日志（Relay log）文件中。并记录该次请求到主顶点的具体哪一个二进制日志文件内部的哪一个位置（主顶点中的二进制文件会有多个，在后面详细讲解）。
+	从顶点启动另外一个线程（sql Thread ），把 Relay log 中的事件读取出来，并在本地再执行一次。

级联复制：从顶点作为其他顶点的主顶点时，需要开启二进制日志文件的；如果只是作为从顶点，则不需要创建二进制文件。

3. 特点

+	异步复制：主顶点不需要把写的数据在本地操作完成同时发送给从服务器并等待从服务器反馈写入完成，再响应用户。主顶点只需要把写入操作在本地完成，就响应用户。但是，从顶点中的数据有可能会落后主顶点，
+	主从数据不一致。

4. 主从复制配置过程
+	主顶点
	+	启用二进制日志。
	+	为当前顶点设置一个全局唯一的 server_id（相同会导致冲突）
	+	创建有复制权限的用户账号 REPLIACTION SLAVE ,REPLIATION CLIENT。
+	从顶点
	+	启动中继日志。
	+	为当前顶点设置一个全局唯一的server_id
	+	使用有复制权限的用户账号连接至主顶点，并启动复制线程。


配置主从复制(my.ini文件)：
```
	# 开启big-log日志
	log-bin = mysql-bin
	# 服务器全局唯一ID
	server-id = 1
	# 独立表空间
	innodb-file-per-table = ON
	# 禁用dns解析,避免网络DNS解析服务引发访问MYSQL的错误
	skip_name_resolve=ON
```


```
-- 查看二进制日志是否开启
show global variables like '%log%';

-- 查看主顶点二进制日志列表
SHOW MASTER LOGS;

-- 创建有复制权限的用户
GRANT REPLIACTION SLAVE, REOPLIATION CLIENT ON *.* TO 'repluser@' IDENTIFIED BY 'repluser'

-- 刷新

```


-----------------------
mysql error 2002 

locate
这个命令的原理是，先为文件系统创建索引数据库，mlocate只是搜索索引，所以速度快
```
-- 更新索引
-- sudo updatedb  只有root权限才能执行，他会扫描整个系统，为整个系统创建索引，数据库在/var/lib/mlocate/mlocate.db
-- 有一定耗时
sudo updatedb
locate mysql
```


+	高性能SQL：SQL优化、explain
+	架构：主从复制，读写分离，负载均衡。


主服务器搭建在window上，修改my.ini文件

```
mysql -V
sudo yum install mysql-server


yum.pid已被锁定
```
# 将该文件删除
rm -f /var/run/yum.pid 
```


1. 卸载centos7的默认数据库mariadb
```
rpm -qa|grep mariadb --查看
	mariadb-server-5.5.65-1.el7.x86_64
	mariadb-libs-5.5.65-1.el7.x86_64
	mariadb-5.5.65-1.el7.x86_64
sudo rpm -e --nodeps mariadb-libs-5.5.65-1.el7.x86_64


```

2. Linux添加mysql包

[mysql 下载地址](https://dev.mysql.com/downloads/mysql/)

通过Window下载传输：
```
	-- WINDOW 文件发送到Linux
	PuTTY>pscp I:/mysql-8.0.17-1.el7.x86_64.rpm-bundle.tar cen@192.168.223.129:/usr/local

	-- Linux通过rpm安装mysql

	sudo mv mysql-community-server-8.0.23-1.el7.x86_64.rpm  mysql
	cd mysql
```

通过centos7 Axel 下载：

```
	-- 安装 Axel
	sudo wget http://download-ib01.fedoraproject.org/pub/epel/7/x86_64/Packages/a/axel-2.4-9.el7.x86_64.rpm
	sudo rpm -i axel-2.4-9.el7.x86_64.rpm

	-- Axel太多重定向
	sudo yum install -y gcc openssl-devel
	sudo wget https://github.com/axel-download-accelerator/axel/releases/download/v2.17.5/axel-2.17.5.tar.gz
	tar -zxvf axel-2.17.5.tar.gz
	cd axel-2.17.5
	./configure && make && sudo make install
	sudo cp axel /usr/bin

	-- -n 使用线程数
	-- -o 输出的目标文件
	sudo axel -n 10 -o mysql8017.tar https://cdn.mysql.com/archives/mysql-8.0/mysql-8.0.17-1.el7.x86_64.rpm-bundle.tar
	sudo tar -xvf mysql-8.0.17-1.el7.x86_64.rpm-bundle.tar
```




3. 按序安装：


```
sudo rpm -ivh mysql-community-common-8.0.18-1.el7.x86_64.rpm
sudo rpm -ivh mysql-community-libs-8.0.18-1.el7.x86_64.rpm
sudo rpm -ivh mysql-community-client-8.0.18-1.el7.x86_64.rpm
sudo rpm -ivh mysql-community-server-8.0.18-1.el7.x86_64.rpm
```

4. 初始化

```
-- 初始化数据库
mysqld --initialize --console

-- 目录授权（cen 是当前用户名）
chown -R cen:cen /var/lib/mysql/

-- 启动msyql服务
systemctl start mysqld
	要求验证密码，忘记使用 passwd+账户 重置
-- 停止命令
service mysqld stop

-- 查看msyql服务的状态
service mysqld status

-- 查看mysql数据库初始密码
cat /var/log/mysqld.log
	A temporary password....

-- 用临时密码登录数据库
mysql -uroot -p

-- mysql8 安全机制
set global validate_password.policy=0
set global validate_password.length=4
quit
mysql_secure_installation

mysql -uroot -p
ALTER USER "root"@"localhost" IDENTIFIED BY "123456";

```

---------------------------------------------------------------



如果输入一个小数。那么java编译器默认认为他是一个double，那么 `float f = 45.0` 就相当于 float a = double b; 在末尾加一个f表示你输入的是float类型就可以了。


---------------------------------------------------------------
在Class文件格式与执行引擎这部分里，用户的程序能直接参与的内容并不太多，Class文件以何种格式存储，类型何时加载、如何连接，以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为，用户程序无法对其进行改变。能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能，但仅仅在如何处理这两点上，就已经出现了许多值得欣赏和借鉴的思路，这些思路后来成为许多常用功能和程序实现的基础。

Web服务器面临的问题：
+	部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离
+	部署在同一个服务器上的两个Web应用程序所使用的Java类库可以互相共享
+	服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响
+	支持JSP应用的Web服务器，十有八九都需要支持HotSwap功能

在Tomcat目录结构中，可以设置3组目录（/common/*、/server/*和/shared/*，但默认不一定是开放的，可能只有/lib/*目录存在）用于存放Java类库，另外还应该加上Web应用程序自身的“/WEBINF/*”目录，一共4组：
+	放置在/common目录中，类库可被Tomcat和所有的Web应用程序协同使用
+	放置在/server目录中，类库可被Tomcat使用，对所有的Web应用程序都不可见
+	放置在/shared目录中，类库可被所有的Web应用程序协同使用，但对Tomcat自己不可见
+	放置在/WebApp/WEB-INF目录中，类库仅仅可以被该Web应用程序使用，对Tomcat和其他Web应用程序都不可见

为了支持这套目录结构，并对目录里面的类库进行加载和隔离，Tomcat自定义了多个类加载器，这些类加载器按照经典的双亲委派模型来实现：

![Tomcat自定义类加载器](/image/jdk/tomcat-cl.png)

从委派关系中可以看出，Common类加载器能加载的类都可以被Catalina类加载器和Shared类加载器使用，而Catalina类加载器和Shared类加载器自己能加载的类则与对方相互隔离。WebApp类加载器可以使用Shared类加载器加载到的类，但各个WebApp类加载器实例之间相互隔离。而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个Class文件，它存在的目的就是为了被丢弃：当服务器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的JSP类加载器来实现JSP文件的HotSwap功能。

上例中的类加载结构在Tomcat 6以前是它默认的类加载器结构，在Tomcat 6及之后的版本简化了默认的目录结构，只有指定了tomcat/conf/catalina.properties配置文件的server.loader和share.loader项后才会真正建立Catalina类加载器和Shared类加载器的实例，否则会用到这两个类加载器的地方都会用Common类加载器的实例代替，而默认的配置文件中并没有设置这两个loader项


OSGi

1. 什么是OSGi
OSGi[1]（Open Service Gateway Initiative）是OSGi联盟（OSGi Alliance）制订的一个基于Java语言的动态模块化规范（在JDK 9引入的JPMS是静态的模块系统）。

OSGi中的每个模块（称为Bundle）与普通的Java类库区别并不太大，两者一般都以JAR格式进行封装[2]，并且内部存储的都是Java的Package和Class。但是一个Bundle可以声明它所依赖的Package（通过Import-Package描述），也可以声明它允许导出发布的Package（通过Export-Package描述）。在OSGi里面，Bundle之间的依赖关系从传统的上层模块依赖底层模块转变为平级模块之间的依赖，而且类库的可见性能得到非常精确的控制，一个模块里只有被Export过的Package才可能被外界访问，其他的Package和Class将会被隐藏起来。

2. OSGi的Bundle类加载器

OSGi的Bundle类加载器之间只有规则，没有固定的委派关系。例如，某个Bundle声明了一个它依赖的Package，如果有其他Bundle声明了发布这个Package后，那么所有对这个Package的类加载动作都会委派给发布它的Bundle类加载器去完成。不涉及某个具体的Package时，各个Bundle加载器都是平级的关系，只有具体使用到某个Package和Class的时候，才会根据Package导入导出定义来构造Bundle间的委派和依赖。

3. 死锁问题

OSG复杂的动态类加载机制虽然带来了肉眼可见的性能提升。但是在高并发的情况下，复杂的网状关系如果存在循环依赖那么最终会导致死锁。以前，用户可以启用osgi.classloader.singleThreadLoads参数来按单线程串行化的方式强制进行类加载动作。在JDK 7时才终于出现了JDK层面的解决方案，类加载器架构进行了一次专门的升级，在ClassLoader中增加了`registerAsParallelCapable`方法对可并行的类加载进行注册声明，把锁的级别从ClassLoader对象本身，降低为要加载的类名这个级别，目的是从底层避免以上这类死锁出现的可能。

4. 总结

总体来说，OSGi描绘了一个很美好的模块化开发的目标，而且定义了实现这个目标所需的各种服务，同时也有成熟框架对其提供实现支持。对于单个虚拟机下的应用，从开发初期就建立在OSGi上是一个很不错的选择，这样便于约束依赖。但并非所有的应用都适合采用OSGi作为基础架构，OSGi在提供强大功能的同时，也引入了额外而且非常高的复杂度，带来了额外的风险。

-------------------------------------------------------------------------



协同执行
在Daccosim中，可以在执行联合仿真图时，选择如何推进时间步长。 时间步长主要有两类：
+	常量 
+	变量 



7. Step

恒定步进器提前的时间每次都是相同的,可能无法提供良好的计算/精度比：为步长选择较小的值会导致大量的计算步骤，而较大的值可能无法捕获模拟变量中的某些变化。

根据FMU的功能，Daccosim NG还可以实施几种可变的步进策略。在模拟第i步后，每个FMU都会检查其输出，并估计它们与精确值的距离。 Daccosim-NG实现了两种算法：
+	基于Euler方法的算法
+	基于Adams Bashforth方法的算法。

它们的原理是：将导数的值存储在连续的通信点上，以便下一次迭代时推断出一个估值；如果发现该数在接受范围之内，则引擎将建议以更大的步长执行下一步。否则，将取消最后一步，并以较小的步长值重做。自从FMI 2.0版引入FMU状态的概念以来，便可以进行回滚，从而允许在执行模拟步骤之前对FMU状态进行序列化，并在必要时恢复保存的状态。该开源软件提供了一个GUI，以方便设计，开发和执行联合仿真图。




8. Matryoshka

Matryoshka
该功能（Galtier等人，2017）允许将联合仿真图存储到FMU中，以用于Dymola等其他联合仿真环境或Daccosim NG本身（Evora等，a）。其中，FMU是由FMI规范提倡的一种仿真文件格式。当由其他工具打开时，存储在FMU中的联合仿真图被视为单个FMU。 每当主算法出于任何目的使用此FMU时，Matryoshka FMU都会将命令分派给相应的内部FMU。

例如，如果主设备通过doStep方法向 Matryoshka-FMU 发出模拟进阶命令，则此FMU将对包含的所有FMU执行doStep，并将按照共同仿真图中的说明在FMU之间交换值。同时，可以在另一个联合仿真图中嵌入一个Matryoshka FMU，然后将此图导出到具有多层FMUsembedded的Ma-tryoshka FMU中。


支持将FMU导出是由好处的：

+	FMU可以导入到任何FMI兼容的仿真工具中，该工具也可以处理Daccosim NG无法直接交互的非FMI组件。
+	利用Daccosim NG高效的多线程步长控制解决方案，有助于在传统的单线程模拟工具中模拟更快的大型模型。
+	借助Daccosim NG广义协初始化算法，可以在Matryoshka中处理复杂图形的初始化。复杂的仿真图可以直接重用，而无需重写任何内容，并且没有泄露工业和知识产权的风险。
+	可以对联合仿真过程进行微调：通常，当求解器仅对整个模型使用一个精度目标时，Daccosim NG允许用户为每个FMU的每个输出和内部变量定义不同的公差值



“Fmu”对象实例的属性为：
+	Label：在联合仿真图中命名FMU。该字段是可编辑的，将用于标识结果文件中的内部变量
+	“...”按钮：重新加载相同的FMU，这在更新FMU或加载另一个要附加到当前FMU块的FMU时很有用
+	static（静态）：此复选框允许以静态模式执行FMU。此模式为此FMU提供了特定的行为，包括在整个模拟执行过程中将FMU保持在初始化模式。也就是说，其他FMU可能会以STEPPER模式更新它的时间，而该FMU将一直保持其初始化模式，即允许在特殊场景下使用纯静态编译模型，而系统的其余部分会随着时间的推移而变化。
+	FMU初始化列表的变量表，该表由四个名为 ‘Type’, ‘Mode’,‘Variable name’and ‘Init value’的列组成。
	+	Type：是当前变量的类型（实型，布尔型，整数，字符串）
	+	Mode：定义当前变量的初始化模式（“ Before”或“ In Init”）
		+	“Before”：被赋予在进入初始化模式之前，即文件存在以下变量配置：
			+	variability = "fixed/tunable" 和 causality = "parameter"
			+	variability = "fixed/tunable" 和 causality = "calculated parameter/local" 以及 initial = "approx"
			+	variability = "discrete/continuous" 和 causality = "local" 以及 initial = "exact/approx"
		+	“In Init”：只能在初始化阶段初始化的变量
			+	causality = "input"
	+	Variable：当前变量的名称
	+	Init value：当前变量的默认值（FMU的modelDescription.xml文件中可用）

> 注意：输入到输出的传播是按照每个FMU在其modelDescription.xml文件中定义的配置执行的。当FMU不公开内部依赖关系时，将假定每个外部输出都依赖于FMU的所有外部输入（这些默认依赖项不能由用户修改）。



----------------------------------------------------------------



org.javafmi.framework.FmiContainer.Variability


Variable表示变量 包含id、type、value、variability属性，存在Input、Output两个子类。variability属性约定了变量的变化情况（枚举类Variability）
	/**
	 * @Author zws
	 * @Description （源码解读） 变量可变性枚举类
	 * @Date 14:04 2021/5/11
	 * @Param
	 * @return
	 **/
    public static enum Variability {
		// 恒定 变量的值永远不变
        constant, 
		// 固定 变量的值在初始化之后不变
        fixed, 
		//可调 变量与外部变量之间的关系是恒定的，变量值的变化取决于外部值以及变量关系的变化
        tunable, 
		
        // discrete：离散 
		// 模型交互：变量的值在外部事件和内部事件之间是恒定的（=在FMU中隐式定义的时间，状态，步进事件）
		// 联合仿真：值的变化取决于变量关系的变化
		discrete, 
		
		// continuous：只有类型为“ Real”的变量可以是连续的  
		// 模型交互：值的变化没有限制
		// 联合仿真：该变量来自微分
        continuous;

        private Variability() {
        }
    }

> [官方的建模规范下载](http://www.modeler.org.cn/standard/FMI.asp)


SimxFile.save

变量存在


```
/**
 * @Author zws-源码
 * @Description 用于simx 文件的载入与保存
 * @Date 10:21 2021/5/11
 **/
public class SimxFile {
	...
	/**
	 * @Author zws
	 * @Description （源码解读）保存SIMX文件
	 * @Date 13:59 2021/5/11
	 **/
	@SuppressWarnings({"ConstantConditions", "ResultOfMethodCallIgnored"})
	void save() {
		try {
//			1. 获取界面包含的fmu，转换为list
			List<String> fmuFiles = vertexesOf().stream().filter(v -> v instanceof FmuSpec).map(v -> ((FmuSpec) v).fileName()).collect(toList());
			
//			2. 检测fmu是否真实存在
			stream(fmuFolder().listFiles()).filter(f -> !fmuFiles.contains(f.getName())).forEach(File::delete);
			
//			3. 用于将mx图转换为dsg(daccosim graph)对象
			Graph graph = MxGraphToDsg.toDaccosimGraph(getEditor());
//			3.1 保存可视化信息为sim文件（）
			writeFile(simFile.toPath(), simFileOf(getEditor().graphComponent.getGraph()));
//			3.2 图对象转换为dng文件（声明性语言）
			writeFile(dngFile.toPath(), exportDng(graph));
//			3.3 图对象转换为dsg文件（json、序列化）
			writeFile(dsgFile.toPath(), graph.serialize());
			
//			4. 将临时文件压缩到simx文件
			moveFile(new Zipper().zipDirectory(tempFolder, this.simxFile.getName()), this.simxFile);
		} catch (Throwable e) {
			showErrorDialog(null, "There was a problem saving the file. Is it already opened by other application?");
			e.printStackTrace();
		}
	}
	...
}
```


Debug 了文件保存，阅读了部分源码，保存格式为simx。相关步骤如下：

1. 获取界面包含的fmu，转换为list；检测fmu是否实际存在于临时文件夹中
2. mxgraph->graph(前端为mxgraph对象，保存时后台会把它解析为 Graph实体)
3. simx实际格式为ZIP格式，包含了 sim、dng、dsg 三种文件
+	sim 可视化信息（xml）
+	dng 使用声明性语言描述了图结构，包含了注释+数据（node、arrow、setting）
+	dsg 将图实体序列化后保存为json格式的文件
4. 将临时文件复制到simx文件中

保存功能修改思考：
1. 前端数据转换为实体（修改字段），实体转换为文件。
+	前端存在修改，那么就更新到服务器，否则由前端处理。
+	通用文件是共用的，如果修改需要设置版本号。
2.  需要上传功能
3.	运行不需要触发保存功能（？），修改一段时间后定时保存（？）

GraphNode是图顶点抽象类，定义了一些通用的属性和方法。FMU顶点是基于FMU文件的顶点，包含属性InitValues（beforeInitValues|inInitValues）、static（静态模式）、flowVariables（？）。


```
/**
 * @Author zws
 * @Description （源码解读） 定义了 顶点-FMU
 * @Date 13:22 2021/5/11
 **/
public class FMU extends GraphNode {
//	FMU文件路径
	private String path;
//	Before 类型的初始化变量
	private List<InitialValue> beforeInitValues = new ArrayList<>();
//	In Init 类型的初始化变量
	private List<InitialValue> inInitValues = new ArrayList<>();
//	流变量
	private List<String> flowVariables = new ArrayList<>();
//	静态模式-FMU全程保持初始化状态
	private boolean static_;
	
}
```

FMU顶点有以下几个属性：
+	InitValues（初始值）：定义当前变量的初始化模式（“ Before”或“ In Init”）
	+	“Before”：被赋予在进入初始化模式之前，即FMU中modelDescription.xml文件存在以下变量配置：
		+	variability = "fixed/tunable" 和 causality = "parameter"
		+	variability = "fixed/tunable" 和 causality = "calculated parameter/local" 以及 initial = "approx"
		+	variability = "discrete/continuous" 和 causality = "local" 以及 initial = "exact/approx"
	+	“In Init”：只能在初始化阶段初始化的变量，FMU中modelDescription.xml文件存在以下变量配置：
		+	causality = "input"
+	static（静态模式）：模式为此FMU提供了特定的行为，包括在整个模拟执行过程中将FMU保持在初始化模式。也就是说，其他FMU可能会以STEPPER模式更新它的时间，而该FMU将一直保持其初始化模式。
+	flowVariables（流变量）：该接口指定FMU输出哪些流，存在那些流输入FMU。流变量可以设定为一个输入多个输出的多重连接。与通常的Modelica规范相比，所有连接的输出值都乘以-1，然后求和，然后再设置为输入（流量变量正在输入模型）


idea查看方法被哪里使用
•方法一:快捷键Alt + F7
•方法二:选中方法名右键,点击"Find Usages"

-------------------------------------------------------------------------------


企业架构由总体架构和系统架构组成，两者分别对应不哦她那个层级设计和管控。

信息系统的基础组织方式，包括各系统组成部分、关系（组成部分之间， 组成部分与系统环境之间）、以及指导系统设计和演进的管控原则。

1. 通用的4A架构

总体架构：从整体上体现了`企业的关键业务、信息、应用和基础设施建设和发展策略`， 以及它们对企业的业务功能和流程的影响。总体架构关注于业务流程、企业的组织结构， 以及支持业务流程的信息技术
+	业务架构
+	数据架构
+	应用架构
+	技术架构
系统架构：总体架构在业务、应用、数据和技术四个架构领域针对具体信息系统或项目的方案视图和设计细化。
+	业务视图
+	数据视图
+	应用视图
+	技术视图

![企业架构](/image/soft-skills/zjg.png)
![企业架构-工作框架](/image/soft-skills/gzjg.png)

2. v结构

![企业架构-v结构](/image/soft-skills/hwv.png)

服务化V模型包括主要的业务要素、应用要素和数据要素。服务作为三者的融合单元， 实现业务、数据与系统功能的拉通。

![企业架构-v结构](/image/soft-skills/hwv-xj.png)


eyJhbGciOiJQUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6Ii4rQC4rIiwibWl4cGFuZWxJZCI6IjE3OTc5OWE0MWQ2ZDBlLTBhZTA0OTI1NDRhNzUxLWQ3ZTE3MzktMTQ0MDAwLTE3OTc5OWE0MWQ3ZjRkIiwibWl4cGFuZWxQcm9qZWN0SWQiOiI0YmZiMjQxNGFiOTczYzc0MWI2ZjA2N2JmMDZkNTU3NSIsIm9yZyI6Ii4qIiwicHViIjoibmVvNGouY29tIiwicmVnIjoiICIsInN1YiI6Im5lbzRqLWRlc2t0b3AiLCJleHAiOjE2NTI3Nzg4OTAsInZlciI6IioiLCJpc3MiOiJuZW80ai5jb20iLCJuYmYiOjE2MjEyNDI4OTAsImlhdCI6MTYyMTI0Mjg5MCwianRpIjoiLVZlMG9iYzVTIn0.vZz94qltlBlV_C5YUb_C99Hh_UHg3cpNEMoFJZsEJVHSQdqU2bqDK6Lsu9LjE4gEaDDdK6Wrdc0qIA6aViVMNyANjOeaW4Qx7lVMGdawvXWMsL6XHiOpbc6cOCXHDBY6vJ32CjI4WsoR7KN1JoqNU5pCLI1qD714XJQWM8rxC9MTxE8b7l0TPUPUjH3KwLWN6VeaZEd1rZB8UlTsVBT0K94VM-wpB1qcJQq90Wy4YJZFPecrOKP_4uI9IP6HhR5weLLnJ70TNEeOix-bIbd0DibgggCfC1ROF_KK7JaIQ094ZRVUPu57PTSrqoDFgviCpg9jh_L8DGL7I4obFTdnLg



---
title: Linux 文件系统
date: 2020-10-17 19:46:18
tags: [linux]
---

### 一、基础

Linux 在最初的设计是 MINIX1 文件系统，它只支持 14 字节的文件名，它的最大文件只支持到 64 MB。在 MINIX 1 之后的文件系统是 ext 文件系统。ext 系统相较于 MINIX 1 来说，在支持字节大小和文件大小上均有很大提升，但是 ext 的速度仍没有 MINIX 1 快，于是，ext 2 被开发出来，它能够支持长文件名和大文件，而且具有比 MINIX 1 更好的性能。这使他成为 Linux 的主要文件系统。只不过 Linux 会使用 VFS 曾支持多种文件系统。在 Linux 链接时，用户可以动态的将不同的文件系统挂载倒 VFS 上。

早期的 Linux 使用 Ext2 文件系统格式，CentOS 5.x 默认使用 Ext3，本教程中所用的 CentOS 6.x 默认使用 Ext4，而目前最新的 CentOS 7.x 默认使用 xfs 格式。

#### 默认文件

Linux默认文件体系如下
+	`/bin`，它是重要的二进制应用程序，包含二进制文件，系统的所有用户使用的命令都在这里
+	`/boot`，启动包含引导加载程序的相关文件
+	`/dev`，包含设备文件，终端文件，USB 或者连接到系统的任何设备
+	`/etc`，配置文件，启动脚本等，包含所有程序所需要的配置文件，也包含了启动/停止单个应用程序的启动和关闭 shell 脚本
+	`/home`，本地主要路径，所有用户用 home 目录存储个人信息
+	`/lib`，系统库文件，包含支持位于/bin和/sbin 下的二进制库文件
+	`/lost+found`，在根目录下提供一个遗失+查找系统，必须在 root 用户下才能查看当前目录下的内容
+	`/media`，挂载可移动介质
+	`/mnt`，挂载文件系统
+	`/opt`，提供一个可选的应用程序安装目录
+	`/proc`，特殊的动态目录，用于维护系统信息和状态，包括当前运行中进程信息
+	`/root`，root 用户的主要目录文件夹
+	`/sbin`，重要的二进制系统文件
+	`/tmp`， 系统和用户创建的临时文件，系统重启时，这个目录下的文件都会被删除
+	`/usr`，包含绝大多数用户都能访问的应用程序和文件
+	`/var`，经常变化的文件，诸如日志文件或数据库等

在 Linux 中，有两种路径，一种是 绝对路径(absolute path) ，绝对路径告诉你从根目录下查找文件，绝对路径的缺点是太长而且不太方便。还有一种是 相对路径(relative path) ，相对路径所在的目录也叫做工作目录(working directory)。

例如：
```
# 绝对路径
cd /usr/local

# 相对路径，移动到当前目录的local目录下
cd local
```

#### 链接(link) 机制

如果访问其它用户的共享文件（其它账号的文件），需要用绝对路径。为了方便共享文件，Linux提供了链接(link) 机制方便用户访问其它用户的文件。linux引入了两种连接方式，硬链接(hard link)和软连接(symbolic link 又称符号连接)，通过该机制可以创建文件（类似Windows系统的快捷文件）。

1. 存储原理
在linux系统中，文件存储被分为两部分，用户数据和元数据。用户数据，即文件数据块，是记录文件真实内容的地方；元数据则是记录文件的附加信息，例如所有人、用户权限、大小、创建时间等信息。
inode号（即索引节点号）是元数据的一部分，是文件的唯一标志；用于指向实际数据。通过文件名调用的流程如下：
`文件名-->inode号-->文件数据块（用户数据）`

2. 查看Inode号
```
[cen@localhost src]$ stat redis-server 
  文件："redis-server"
  大小：11351976  	块：22176      IO 块：4096   普通文件
设备：fd00h/64768d	Inode：49248       硬链接：1
权限：(0755/-rwxr-xr-x)  Uid：(    0/    root)   Gid：(    0/    root)
最近访问：2020-10-16 21:38:34.499038718 +0800
最近更改：2020-10-15 17:47:23.570069451 +0800
最近改动：2020-10-15 17:47:23.570069451 +0800
创建时间：-
```

通过`stat`可以看到redis-server 到inode号为49248；重命名或者移动文件不会改变inode号，表示文件也没有改变，只是文件名、位置变化了而已。


3. 硬连接
一个inode号对应多个文件的时候，这些文件就称为硬连接，通过`link`命令可以创建硬连接。例如：
```
[cen@localhost src]$ sudo ln redis-server redis608-ser
[cen@localhost src]$ stat redis608-server 
  文件："redis608-server"
  大小：11351976  	块：22176      IO 块：4096   普通文件
设备：fd00h/64768d	Inode：49248       硬链接：2
权限：(0755/-rwxr-xr-x)  Uid：(    0/    root)   Gid：(    0/    root)
最近访问：2020-10-16 21:38:34.499038718 +0800
最近更改：2020-10-15 17:47:23.570069451 +0800
最近改动：2020-10-17 20:14:36.554808739 +0800
创建时间：-
```

硬连接文件的特性：
+	文件有相同的inode和 data block
+	只能对已有的文件创建
+	删除没有影响
+	硬连接只能通过文件建立，而不是文件夹
+	不能交叉文件系统创建

3. 软连接（快捷方式）
软连接和硬连接是完全不同的，软连接是一个新的文件，文件的用户数据块存放的是原文件的路径名。
软连接和硬连接的区别：
![linux](/image/linux/link.png)

软连接特点：
+	有自己的文件权限与属性
+	可对不存在的文件或目录创建软链接
+	软链接可交叉文件系统
+	软链接可对文件或目录创建
+	创建软链接时，链接计数 i_nlink 不会增加
+	删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接

例如：
```
ln -s /usr/local/redis608/src/redis-server /home/cen/rd6.sln
[cen@localhost src]$ cd /home/cen/
[cen@localhost src]$ stat rd6.sln 
  文件："r6.sln" -> "redis-server"
  大小：12        	块：0          IO 块：4096   符号链接
设备：fd00h/64768d	Inode：49271       硬链接：1
权限：(0777/lrwxrwxrwx)  Uid：(    0/    root)   Gid：(    0/    root)
最近访问：2020-10-17 20:29:18.180406410 +0800
最近更改：2020-10-17 20:28:53.110735393 +0800
最近改动：2020-10-17 20:28:53.110735393 +0800
创建时间：-

# 启动程序
./rd6.sln
```

#### 文件加锁(locking) 
Linux 文件系统的另外一个特性是支持 加锁(locking)。在一些应用中会出现两个或者更多的进程同时使用同一个文件的情况，这样很可能会导致竞争条件(race condition)。一种解决方法是对其进行加不同粒度的锁，就是为了防止某一个进程只修改某一行记录从而导致整个文件都不能使用的情况。

Linux 支持的文件锁技术主要包括劝告锁（advisory lock）和强制锁（mandatory lock）这两种。此外，Linux 中还引入了两种强制锁的变种形式：共享模式强制锁（share-mode mandatory lock）和租借锁（lease）。

在 Linux 中，不论进程是在使用劝告锁还是强制锁，它都可以同时使用共享锁和排他锁（又称为读锁和写锁）。

1. 劝告锁
劝告锁是一种协同工作的锁。对于这一种锁来说，内核只提供加锁以及检测文件是否已经加锁的手段，但是内核并不参与锁的控制和协调。。也就是说，如果有进程不遵守“游戏规则”，不检查目标文件是否已经由别的进程加了锁就往其中写入数据，那么内核是不会加以阻拦的。

2. 强制锁
与劝告锁不同，强制锁是一种内核强制采用的文件锁，它是从 System V Release 3 开始引入的。每当有系统调用 open()、read() 以及write() 发生的时候，内核都要检查并确保这些系统调用不会违反在所访问文件上加的强制锁约束。也就是说，如果有进程不遵守游戏规则，硬要往加了锁的文件中写入内容，内核就会加以阻拦：

3. 共享锁
多个共享锁之间不会相互干扰，多个进程在同一时刻可以对同一个文件加共享锁，但是无法与排他锁公用。

4. 排他锁
只有一个线程在同一时刻可以对同一个文件加排他锁。


#### 文件相关的系统调用
许多系统调用都会和文件与文件系统有关。
![Linux系统调用](/image/linux/linux-file-stdy.png)


1. 打开文件（creat或者open）
这两个函数的参数是打开文件的方式（只读、可读写还是只写）, 返回值是文件描述符。

1.1 文件描述符
文件描述符就是一个数字，这个数字标示了计算机操作系统中打开的文件。它描述了数据资源，以及访问资源的方式。当一个进程成功访问一个打开的文件时，内核会返回一个文件描述符，这个文件描述符指向全局文件表的 entry 项。这个文件表项包含文件的 inode 信息，字节位移，访问限制等。例如：

![entry 项](/image/linux/linux-f-wjms.png)

默认情况下，前三个文件描述符为 :
+	0：STDIN(标准输入)-键盘
+	1：STDOUT(标准输出)-屏幕
+	2：STDERR(标准错误)-屏幕

2. 文件读写（read和write）

在文件系统中，开销最大的是文件读写，即read和write，参数如下：
+	文件描述符，打开文件的具体信息
+	缓冲区地址，数据读取和写入的地址
+	统计，传输的字节数

Lseek 系统调用会更改指针位置的值，以便后续对 read 或 write 的调用可以在文件中的任何位置开始，甚至可以超出文件末尾。
```
lseek(int fildes, off_t offset, int whence);
fildes 文件描述符
offset 文件位置
whence 文件开头/结尾
```

3. 关闭文件(close)
文件读写完成后，需要使用 close 系统调用进行关闭。close 和 open 返回的 fd 总是未被使用的最小数量。

4. 移动文件指针（lseek）
虽然几乎所有程序都按顺序读取和写入文件，但是某些程序需要能够随机访问文件的任何部分。与每个文件相关联的是一个指针，该指针指示文件中的当前位置。Lseek 系统调用会更改指针位置的值，以便后续对 read 或 write 的调用可以在文件中的任何位置开始，甚至可以超出文件末尾。

定义：
```
lseek(int fildes, off_t offset, int whence);
```

5. 查看文件信息(stat|fstat)
对于每个文件，Linux 都会跟踪文件模式（常规，目录，特殊文件），大小，最后修改时间以及其他信息。程序能够通过 stat 系统调用看到这些信息。
信息结构如下：
+	存储文件的设备
+	i-node编号
+	文件模式
+	文件链接数量
+	文件所有人
+	文件所属组
+	文件大小
+	文件创建时间
+	文件修改时间
+	文件访问时间

`fstat`调用和`stat`相同，只有一点区别，`fstat`可以对打开文件进行操作，而`stat`只能对路径进行操作。

6. 管道(pipe)
`pipe`文件系统调用被用来创建 shell 管道。它会创建一系列的伪文件，来缓冲和管道组件之间的数据，并且返回读取或者写入缓冲区的文件描述符。

7. 文件锁（fcntl）
`fcntl`用来锁定和解锁文件，应用共享锁和互斥锁，或者是执行一些文件相关的其他操作。

#### 目录相关的系统调用

目录相关的系统调用如下：
![目录的系统调用](/image/linux/linux-f-dir.png)

+	mkdir 和 rmdir 创建和删除目录。但是需要注意，只有目录为空时才可以删除。
+	系统调用 link 来创建链接,创建一个指向已有文件的链接时会创建一个目录项(directory entry)
+	使用 unlink 可以删除目录项，当文件的最后一个链接被删除时，这个文件会被自动删除。
+	使用 chdir 系统调用可以改变工作目录。
+	最后四个系统调用是用于读取目录

### 二、文件系统的实现

Linux支持的文件系统有很多，比较常见的有 EXT3、EXT4，还有基于内存的 ramfs、tmpfs 和基于网络的 nfs，和基于用户态的 fuse。为了便于文件系统的使用，Linux 做了一层抽象就是 VFS 虚拟文件系统。

VFS 支持的四个主要的文件系统结构：
+	超级块 特定文件系统，文件系统布局信息
+	Dentry 目录项，路径组成部分
+	I-node 特定文件，文件描述符
+	File 进程相关文件

> 虚拟文件系统(VFS)是由Sun microsystems公司在定义网络文件系统(NFS)时创造的。它是一种用于网络环境的分布式文件系统，是允许和操作系统使用不同的文件系统实现的接口。虚拟文件系统（VFS）是物理文件系统与服务之间的一个接口层，它对Linux的每个文件系统的所有细节进行抽象，使得不同的文件系统在Linux核心以及系统中运行的其他进程看来，都是相同的。


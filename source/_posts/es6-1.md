---
title: ES6（一）基础入门
date: 2019-11-03 21:12:04
tags: [es6]
---

这一系列文章是[阮一峰](http://www.ruanyifeng.com/home.html)大大的【ECMAScript 6 】学习笔记。

*目录*
+	[ES6（一）基础入门](/2019/11/03/es6-1/)
+	[ES6（二）字符串与数值](/2019/11/08/es6-2/)
+	[ES6（三）正则、函数与数组](/2019/11/09/es6-3/)


# 一、ES6 简介

这一系列文章是[阮一峰](http://www.ruanyifeng.com/home.html)大大的【ECMAScript 6 】学习笔记。

### 1. ES6 与 ECMAScript 2015
2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。但由于版本迭代过快，所以决定每一年六月来更新一个版本。所以，ECMAScript 2015是指ES6在2015年的更新版本。

因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。

ES6标准是有兼容性的，通过[网址](kangax.github.io/compat-table/es6/)可以查看各个平台对它的支持。

### 2. babel 转码器

Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。

*安装*
```
	$ npm install --save-dev @babel/core
```

*基本用法*
```
		# 转码结果输出到标准输出
	$ npx babel example.js
		# 转码结果写入一个文件
	# --out-file 或 -o 参数指定输出文件
	$ npx babel example.js --out-file compiled.js
	# 或者
	$ npx babel example.js -o compiled.js
		# 整个目录转码
	# --out-dir 或 -d 参数指定输出目录
	$ npx babel src --out-dir lib
	# 或者
	$ npx babel src -d lib
		# -s 参数生成source map文件
	$ npx babel src -d lib -s
```


具体使用可以查看[文档](https://www.babeljs.cn/docs/), Babel是一个工具链，主要用于将ECMAScript 2015+版本的代码转换为向后兼容的JavaScript语法，可以阻止运行在当前和旧版本的浏览器或其他环境中。目前各大浏览器自身也加快速度兼容 ES6 的新特性，其中对 ES6 新特性最友好的是 Chrome 和 Firefox 浏览器。

### 3. ES与JS
ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。

# 二、let与const的使用


### 1. 局部变量let
*块级作用域有效*
+	ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。
*不存在变量提升——局部变量特性*
+	var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。
+	为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。

*暂时性死区*
+	ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
+	总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

*不允许重复声明 *
+	let不允许在相同作用域内，重复声明同一个变量。

### 2. 常量const命令

*const的特点*
+	常量；
+	声明且立即初始化；
+	块级作用域有效；
+	只能保证简单数据不可变；对于对象只能保证对象地址不变，但无法保证内容不变。
+	可以使用Object.freeze方法进行对象冻结
	+	```
	const foo = Object.freeze({});
	foo.prop = 123; # 无效
	```

### 3. ES6声明变量的六种方法

ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。

### 4. 顶层对象的属性 
顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。
>	顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。
ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。


### 5. global 对象 
ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。
+	浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。
+	浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。
+	Node 里面，顶层对象是global，但其他环境都不支持。

同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。


 



相关资源
> [ES6编译器](https://babeljs.io/)
[gitbook](https://gitbook.io/)
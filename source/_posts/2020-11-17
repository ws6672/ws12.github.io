
账号 1643962278 密码 zU484574


薄弱点
	socket编程
	springboot
	mysql
	oracle
	springcloud
	java并发框架
	
tail

语法：tail [参数] [文件]  

+	-f 循环读取
+	-q 不显示处理信息
+	-v 显示详细的处理信息
+	-c<数目> 显示的字节数
+	-n<行数> 显示文件的尾部 n 行内容
+	--pid=PID 与-f合用,表示在进程ID,PID死掉之后结束
+	-q, --quiet, --silent 从不输出给出文件名的首部
+	-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒


使用

```
# 循环输出，跟踪文件
tail -f filename
# 输出最后两行
tail -n 2 filename
```



### [456. 132模式](https://leetcode-cn.com/problems/132-pattern/)


***题目***

```
给定一个整数序列：a1, a2, ..., an，一个132模式的子序列 ai, aj, ak 被定义为：当 i < j < k 时，ai < ak < aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。

注意：n 的值小于15000。

示例1:
	输入: [1, 2, 3, 4]
	输出: False
	解释: 序列中不存在132模式的子序列。
	
示例 2:
	输入: [3, 1, 4, 2]
	输出: True
	解释: 序列中有 1 个132模式的子序列： [1, 4, 2].
	
示例 3:
	输入: [-1, 3, 2, 0]
	输出: True
	解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].
```

***题解***

```
class Solution {
    public boolean find132pattern(int[] nums) {
        if(nums.length <3) {
            return false;
        }
        int min=nums[0];

        for(int i=1; i<nums.length-1; i++) {
            if(min<nums[i]) {
                for(int j=i+1; j<nums.length; j++) {
                    if(min<nums[j] && nums[i]>nums[j] ) {
                        return true;
                    }
                }
            } else {
                min=nums[i];
            }
        }

        return false;
    }
}
```

### [304. 二维区域和检索 - 矩阵不可变](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/)


***题目***

```
给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。
上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)，该子矩形内元素的总和为 8。

示例:

给定 matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -> 8
sumRegion(1, 1, 2, 2) -> 11
sumRegion(1, 2, 2, 4) -> 12

说明:

	你可以假设矩阵不可变。
	会多次调用 sumRegion 方法。
	你可以假设 row1 ≤ row2 且 col1 ≤ col2
```

***题解***

```
class NumMatrix {
    private int[][] matrix;
    public NumMatrix(int[][] matrix) {
        this.matrix = matrix;
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        int sum=0;
        for(int i=row1; i<=row2; i++) {
            for(int j=col1; j<=col2; j++) {
                sum+=matrix[i][j];
            }
        }
        return sum;
    }

}

/**
 * Your NumMatrix object will be instantiated and called as such:
 * NumMatrix obj = new NumMatrix(matrix);
 * int param_1 = obj.sumRegion(row1,col1,row2,col2);
 */
```

### [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)


***题目***
```

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。

例如：
	输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
	输出：true
```

***题解***
```
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int row = matrix.length;
        if(row==0) {
            return false;
        }
        int col = matrix[0].length;
        
        for(int i=0; i<row;i++) {
            if(matrix[i][col-1]<target) {
                continue;
            }

            for(int j=0; j<col;j++) {
                if(matrix[i][j]>target) {
                    break;
                } else if(matrix[i][j]==target) {
                    return true;
                }
            }
        }
        return false;
    }

    
}
```

### []()


***题目***


***题解***

Java线程之释放锁
+	执行完同步代码块，就会释放锁。（synchronized）
+	在执行同步代码块的过程中，遇到异常而导致线程终止，锁也会被释放。（exception）
+	在执行同步代码块的过程中，执行了锁所属对象的wait()方法，这个线程会释放锁，进入对象的等待池。(wait)
+	Thread 的join() 方法也会调用锁，底层调用的是Object对象的 this.wait()方法。

> 注：yield()方法作用是:暂停当前正在执行的线程对象,并执行其他线程，变成就绪态；
Thread 的sleep()方法用于暂停线程。


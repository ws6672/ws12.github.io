---
title: 面试——某电商笔试
date: 2021-01-07 22:36:01
tags: [ms]
---

### JVM的内存结构

1. Eden和Survivor比例是多少？

Eden区和Survivor区的比例是8:1:1。


2. JVM中一次完整的GC流程是怎样的？

对象的正常流程：Eden 区 -> Survivor 区 -> 老年代。基本上新的对象优先在 Eden 区分配，当 Eden 区没有足够空间时，会发起一次 Minor GC；Minor GC 回收新生代采用复制回收算法的改进版本，即
+	from 区和 to 区的两个交换区，这两个区只有一个区有数据
+	采用8:1:1的默认分配比例（-XX:SurvivorRatio默认为8，代表 Eden 区与 Survivor 区的大小比例）

3. 对象如何晋升到老年代？

+	大对象直接进入老年代。比如很长的字符串，或者很大的数组等。
+	长期存活的对象进入老年代。在堆中分配内存的对象，其内存布局的对象头中（Header）包含了 GC 分代年龄标记信息。如果对象在 eden 区出生，那么它的 GC 分代年龄会初始值为 1，每熬过一次 Minor GC 而不被回收，这个值就会增加 1 岁。当它的年龄到达一定的数值时（jdk1.7 默认是 15 岁），就会晋升到老年代中。
+	动态对象年龄判定。当 Survivor 空间中相同年龄所有对象的大小总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而不需要达到默认的分代年龄。



### 调优

1. Tomcat如何调优？

+	采用动静分离节约tomcat的性能
	+	nginx+tomcat实现动静分离，让 Tomcat 只负责 jsp 文件的解析工作，用nginx实现静态资源的访问
+	调整tomcat的线程池
	+	修改tomcat的server.xml
	+	配置Executor（线程相关的一些配置）
+	调整tomcat的连接器
	+	修改tomcat的server.xml
	+	配置Connector（线程相关的一些配置）
+	修改tomcat的运行模式
	+	BIO：Tomcat8以下版本，默认使用的就是BIO(阻塞式IO)模式。对于每一个请求都要创建一个线程来进行处理，不适合高并发
	+	NIO：Tomcat8以上版本，默认使用的就是NIO模式。非阻塞式Io
	+	APR（Apache Portable Runtime）：是Tomcat生产环境运行的首选方式

+	禁用AJP连接器
	+	使用Nginx+tomcat的架构，所以用不着AJP协议，所以把AJP连接器禁用

2. 你知道的几种主要的jvm参数？

1）堆栈配置相关

-Xmx3550m： 最大堆大小为3550m。

-Xms3550m： 设置初始堆大小为3550m。

-Xmn2g： 设置年轻代大小为2g。

-Xss128k： 每个线程的堆栈大小为128k。

-XX:MaxPermSize： 设置持久代大小为16m

-XX:NewRatio=4: 设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。

-XX:SurvivorRatio=4： 设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6

-XX:MaxTenuringThreshold=0： 设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。

2）垃圾收集器相关

-XX:+UseParallelGC： 选择垃圾收集器为并行收集器。

-XX:ParallelGCThreads=20： 配置并行收集器的线程数

-XX:+UseConcMarkSweepGC： 设置年老代为并发收集。

-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。

-XX:+UseCMSCompactAtFullCollection： 打开对年老代的压缩。可能会影响性能，但是可以消除碎片



### 锁

1. synchronized 和 Lock 有什么区别？

+	来源
	+	lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现；

+	异常是否释放锁
	+	synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁；而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。）

+	是否响应中断
	+	lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断；

+	是否知道获取锁
	+	Lock可以通过trylock来知道有没有获取锁，而synchronized不能；

+	Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）

+	在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。

+	synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，而Lock可以使用Condition进行线程之间的调度，

	

2. 线程死锁的条件是哪些？

（1）互斥条件：线程(进程)对于所分配到的资源具有排它性，即一个资源只能被一个线程(进程)占用，直到被该线程(进程)释放

（2）请求与保持条件：一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。

（3）不剥夺条件：线程(进程)已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。

（4）循环等待条件：当发生死锁时，所等待的线程(进程)必定会形成一个环路（类似于死循环），造成永久阻塞



3. 乐观锁和悲观锁是什么？什么是共享锁和排它锁？

乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）

共享锁【S锁】：又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

排他锁【X锁】：又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。

4. INNODB的行级锁有哪两种，解释其含义

共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。


### 微服务

1. SpringCloud有哪些组件？

+	服务发现——Netflix Eureka
+	客服端负载均衡——Netflix Ribbon
+	断路器——Netflix Hystrix
+	服务网关——Netflix Zuul
+	分布式配置——Spring Cloud Config

2. SpringCloud是如何处理循环服务调用的？

### redis

1. redis持久化机制中aof和rdb的区别？

RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘；
AOF持久化是指在指定的时间间隔内将内存中的命令集快照写入磁盘

2. redis的集群怎么同步数据？

3. 高并发的电商秒杀方案，涉及到哪些技术点？

一个秒杀或者抢购页面，通常分为2个部分，一个是静态的HTML等内容，另一个就是参与秒杀的Web后台请求接口。
通常静态HTML等内容，是通过CDN的部署，一般压力不大，核心瓶颈实际上在后台请求接口上。

+	同一个账号，一次性发出多个请求。
	+	在程序入口处，一个账号只允许接受1个请求，其他请求过滤
+	多个账号，一次性发送多个请求。
	+	可以通过检测指定机器IP请求频率就可以解决，如果发现某个IP请求频率很高，可以给它弹出一个验证码或者直接禁止它的请求
+	多个账号，不同IP发送不同请求。
	+	在业务上识别，IP池对应的账号如果是僵尸账号，那么可以通过账号相对应的数据进行过滤



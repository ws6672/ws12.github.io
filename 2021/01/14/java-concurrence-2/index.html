<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一些关于技术的碎语"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>java 并发（三）数据的并发 | 微言术语</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">java 并发（三）数据的并发</h1><a id="logo" href="/.">微言术语</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">java 并发（三）数据的并发</h1><div class="post-meta"><a href="/2021/01/14/java-concurrence-2/#comments" class="comment-count"></a><p><span class="date">Jan 14, 2021</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="一、Atomic"><a href="#一、Atomic" class="headerlink" title="一、Atomic"></a>一、Atomic</h1><ol>
<li>简介</li>
</ol>
<p>Atomic包是Java.util.concurrent下的另一个专门为线程安全设计的Java包，包含多个原子操作类。这个包里面提供了一组原子变量类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性。</p>
<ol start="2">
<li>自旋锁</li>
</ol>
<p>自旋锁是一种非阻塞锁,抢到执行权的线程并不会自旋,自旋的精髓在于没抢到执行权的线程,它们会空转cpu,一直循环,这就是自旋,并非把线程改为阻塞状态.它们还是在运行的,自旋重试想获取锁。</p>
<p>在JDK1.4.2的时候就引入了自旋锁，到了JDK1.6以后，就已经是默认开启。自定义自旋锁如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicTest &#123;</span><br><span class="line">    private AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;();</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        while (!atomicReference.compareAndSet(null,thread)) &#123;</span><br><span class="line">            //当ref为null的时候compareAndSet返回true，反之为false</span><br><span class="line">//            通过循环的自旋锁判断是否是其它线程持有的</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        if (atomicReference.get()!=null) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        atomicReference.set(null);</span><br><span class="line">    &#125;</span><br><span class="line">    static int count =0;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(20);</span><br><span class="line">        AtomicTest atomicTest = new AtomicTest();</span><br><span class="line">        for (int i=0; i&lt;100; i++) &#123;</span><br><span class="line">            executorService.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    atomicTest.lock();</span><br><span class="line">                    System.out.println(count++);</span><br><span class="line">                    atomicTest.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 输出按序</span><br></pre></td></tr></table></figure>

<p>自适应自旋锁：随着JDK的更新，在1.6的时候，又出现了一个叫做“自适应自旋锁”的玩意。它的出现使得自旋操作变得聪明起来，不再跟之前一样死板。所谓的“自适应”意味着对于同一个锁对象，线程的自旋时间是根据上一个持有该锁的线程的自旋时间以及状态来确定的。</p>
<ol start="3">
<li>CAS机制<br>CAS 是实现自旋锁的基础，CAS 利用 CPU 指令保证了操作的原子性，以达到锁的效果。加锁或使用 synchronized 关键字带来的性能损耗较大，而用 CAS 可以实现乐观锁，它实际上是直接利用了 CPU 层面的指令，所以性能很高。自旋是指循环，如果有多个线程进入自旋，那么性能会大大降低。</li>
</ol>
<p>CAS,compare and swap的缩写，中文翻译成比较并交换。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 <code>如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。</code>无论哪种情况，它都会在 CAS 指令之前返回该位置的值。</p>
<p>通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键。</p>
<p>递归程序使用自旋锁应该遵循以下原则：</p>
<ul>
<li>递归程序决不能在持有自旋锁时调用它自己</li>
<li>决不能在递归调用时试图获得相同的自旋锁。</li>
</ul>
<ol start="4">
<li>compareAndSet</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// compareAndSet这个方法主要调用unsafe.compareAndSwapInt这个方法，这个方法有四个参数，其中第一个参数为需要改变的对象，第二个为偏移量(即之前求出来的valueOffset的值)，第三个参数为期待的值，第四个为更新后的值。</span><br><span class="line">   public final boolean compareAndSet(V expect, V update) &#123;</span><br><span class="line">       return unsafe.compareAndSwapObject(this, valueOffset, expect, update);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Atomic 相关原子类<br>atomic类是基于CAS机制操作volatile遍历实现的，可用于保证基本数据类型的原子性。Atomic中包含了多个基本类型的原子类，具体如下：</li>
</ol>
<ul>
<li>基本类型<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean ：布尔型原子类</li>
</ul>
</li>
<li>引用类型<ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicMarkableReference：原子更新带有标记的引用类型</li>
<li>AtomicStampedReference ：原子更新带有版本号的引用类型</li>
</ul>
</li>
<li>数组类型<ul>
<li>AtomicIntegerArray：整型数组原子类</li>
<li>AtomicLongArray：长整型数组原子类</li>
<li>AtomicReferenceArray ：引用类型数组原子类</li>
</ul>
</li>
<li>原子字段更新器<ul>
<li>AtomicIntegerFieldUpdater：原子更新整型字段的更新器</li>
<li>AtomicLongFieldUpdater： 原子更新长整型字段的更新器</li>
<li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段的更新器</li>
</ul>
</li>
</ul>
<p>在JDK1.6之前，synchroized是重量级锁，即操作被锁的变量前就对对象加锁，不管此对象会不会产生资源竞争。这属于悲观锁的一种实现方式。　而CAS会比较内存中对象和当前对象的值是否相同，相同的话才会更新内存中的值，不同的话便会返回失败。这是乐观锁的一中实现方式。这种方式就避免了直接使用内核状态的重量级锁。</p>
<h1 id="二、并发集合"><a href="#二、并发集合" class="headerlink" title="二、并发集合"></a>二、并发集合</h1><ol>
<li>同步集与并发集合</li>
</ol>
<p>分类：</p>
<ul>
<li>同步集合类<ul>
<li>Hashtable</li>
<li>Vector</li>
<li>同步集合包装类，Collections.synchronizedMap()和Collections.synchronizedList() </li>
</ul>
</li>
<li>并发集合类<ul>
<li>ConcurrentHashMap</li>
<li>CopyOnWriteArrayList</li>
<li>CopyOnWriteHashSet</li>
</ul>
</li>
</ul>
<p>区别：</p>
<ul>
<li>同步集合比并发集合会慢得多，因为是通过锁（sychronized）实现的。</li>
</ul>
<ol start="2">
<li>ConcurrentHashMap</li>
</ol>
<p>主要就是为了应对hashmap在并发环境下不安全而诞生的，ConcurrentHashMap的设计与实现非常精巧，大量的利用了volatile，final，CAS等lock-free技术来减少锁竞争对于性能的影响。对于重要部分，ConcurrentHashMap进行了加锁；对于其它数据，支持多线程访问。</p>
<ul>
<li>JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。</li>
<li>锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。</li>
<li>链表转化为红黑树：定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。</li>
<li>查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。</li>
</ul>
<ol start="3">
<li>CopyOnWriteArrayList 与 CopyOnWriteHashSet</li>
</ol>
<p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。Java并发包离提供了两个基于COW机制的并发容器。</p>
<ul>
<li>读写分离<ul>
<li>COW即写时复制的容器，当向容器中添加新元素时，不会直接操作容器，而是会对容器复制。在向新容器中添加元素后，会重新将原容器的引用引向新的容器。通过COW机制，我们可以进行并发的读而不需要加锁，因为当前容器不会添加元素。所以，COW实际上是基于读写分离构建的。</li>
</ul>
</li>
<li>场景<ul>
<li>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。</li>
</ul>
</li>
<li>特点<ul>
<li>内存占用问题。COW机制是写时复制机制，用空间换取时间，实现并发，但是会占用一倍的内存空间。</li>
<li>数据一致性问题。COW机制只能保证数据的最终一致性，无法保证数据的实时一致性。</li>
</ul>
</li>
</ul>
<h1 id="三、锁"><a href="#三、锁" class="headerlink" title="三、锁"></a>三、锁</h1><p>锁相关类图如下：<br><img src="/image/java/cn/lock.png" alt="Lock"><br><img src="/image/java/cn/lock2.png" alt="Lock"></p>
<ol>
<li>锁的相关概念</li>
</ol>
<ul>
<li>可重入锁：如果锁具备可重入性，则称作为 可重入锁 。像 synchronized和ReentrantLock都是可重入锁，而可重入锁是基于线程的分配，而不是基于方法调用的分配。在获取锁之后，同一个线程不需要重新申请锁。</li>
<li>可中断锁：可中断锁就是可以响应中断的锁。在Java中，synchronized就不是可中断锁，而Lock是可中断锁。</li>
<li>公平锁：公平锁即尽量按请求锁的顺序来获取锁，线程等待的时间越长越快获得锁；而非公平锁则无法保证锁的获取是按照请求锁的顺序进行的，这样就可能导致某个或者一些线程永远获取不到锁。synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。而对于ReentrantLock 和 ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。</li>
</ul>
<ol start="2">
<li>AbstractQueuedSynchronizer（AQS 抽象队列同步器）</li>
</ol>
<p>AQS使用一个整型的volatile变量（命名为state）来维护同步状态，这是接下来实现大部分同步需求的基础，还提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架。AQS（AbstractQueuedSynchronizer）是一个用于构建锁和同步器的框架，许多同步器都可以通过AQS很容易并且高效地构造出来。不仅ReentrantLock和Semaphore是基于AQS构建的，还包括CountDownLatch、ReentrantReadWriteLock、SynchronousQueue和FutureTask。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractQueuedSynchronizer</span><br><span class="line">	extends AbstractOwnableSynchronizer</span><br><span class="line">    implements java.io.Serializable</span><br></pre></td></tr></table></figure>

<p>该同步器利用了一个int来表示状态，期望它能够成为实现大部分同步需求的基础。使用的方法是继承，子类通过继承同步器并需要实现它的方法来管理其状态，管理的方式就是通过类似acquire和release的方式来操纵状态。</p>
<p><strong><em>等待队列</em></strong></p>
<p>同步器核心之一便是等待队列，结构如下：<br><img src="/image/current/compareAndSetTail.png" alt="compareAndSetTail"></p>
<p>该队列的节点定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">	//首节点</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line">	</span><br><span class="line">    //表示节点的状态。默认为0，表示当前节点在sync队列中，等待着获取锁。</span><br><span class="line">    //其它几个状态为：CANCELLED、SIGNAL、CONDITION、PROPAGATE</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line">	</span><br><span class="line">    //前驱节点</span><br><span class="line">    volatile Node prev;</span><br><span class="line">    //后继节点</span><br><span class="line">    volatile Node next;</span><br><span class="line">    //获取锁的线程</span><br><span class="line">    volatile Thread thread;</span><br><span class="line">    //存储condition队列中的后继节点。</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">waitStatus的几个状态</span><br><span class="line"></span><br><span class="line">CANCELLED(1) : 由于 timeout/interrupt, 线程被取消</span><br><span class="line">0            : 其他状态</span><br><span class="line">SIGNAL(-1)   : 线程成功被阻塞,可以调用当前结点的后续结点</span><br><span class="line">CONDITION(-2): 位于条件队列中，等待condition</span><br><span class="line">PROPAGATE(-3): 表示当前场景下后续的acquireShared能够得以执行</span><br></pre></td></tr></table></figure>

<p>该等待队列是“CLH（自旋锁）”锁队列，用于阻塞同步器，使用了相同的策略来控制当前线程的上一个线程的信息。每个节点包含一个状态字段，用于区分该线程是否会被阻塞，而不保证线程获得锁。CLH队列需要一个虚拟头节点才能启动。</p>
<p><strong><em>几个核心方法</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.getState()</span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.setState(int)</span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState(int, int)</span><br><span class="line"></span><br><span class="line">//compareAndSetState是一个基于CAS原则定义的方法，用于设置队列的尾节点</span><br><span class="line">private final boolean compareAndSetTail(Node expect, Node update) &#123;</span><br><span class="line">	return unsafe.compareAndSwapObject(this, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Lock（接口）和 ReentrantLock（可重入锁）</li>
</ol>
<p>Lock（接口）相关方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package java.util.concurrent.locks;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public interface Lock &#123;</span><br><span class="line">// 获取锁</span><br><span class="line">    void lock();</span><br><span class="line">// 如果当前线程未被中断，则获取锁，可以响应中断</span><br><span class="line">    void lockInterruptibly() throws InterruptedException;</span><br><span class="line">// 仅在调用时锁为空闲状态才获取该锁，可以响应中断</span><br><span class="line">    boolean tryLock();</span><br><span class="line">// 如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁</span><br><span class="line">    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line">// 释放锁</span><br><span class="line">    void unlock();</span><br><span class="line">// 返回绑定到此 Lock 实例的新 Condition 实例</span><br><span class="line">    Condition newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 意为可重入锁，是Lock接口的实现类。ReentrantLock是唯一实现了Lock接口的类，并且提供了更多的方法。实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class LockTest &#123;</span><br><span class="line"></span><br><span class="line">    public void testLock(String value) &#123;</span><br><span class="line">        Lock lock = new ReentrantLock();</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            //处理任务</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line">//            释放锁，需要放在第一行</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testTryLock(String value) &#123;</span><br><span class="line">        Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">        if (lock.tryLock()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //处理任务</span><br><span class="line">                System.out.println(value);</span><br><span class="line">            &#125;  catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;  finally &#123;</span><br><span class="line">//            释放锁，需要放在第一行</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;don&apos;t have lock&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LockTest lockTest = new LockTest();</span><br><span class="line">        new Thread(()-&gt;lockTest.testLock(&quot;A&quot;)).start();</span><br><span class="line">        new Thread(()-&gt;lockTest.testLock(&quot;B&quot;)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>ReadWriteLock 和 ReentrantReadWriteLock</li>
</ol>
<p>ReadWriteLock是读写锁接口，源码如下。ReadWriteLock管理一组锁，一个是只读的锁，一个是写锁；ReentrantLock是一个排他锁，同一时间只允许一个线程访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface ReadWriteLock &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns the lock used for reading.</span><br><span class="line">     *</span><br><span class="line">     * @return the lock used for reading</span><br><span class="line">     */</span><br><span class="line">    Lock readLock();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the lock used for writing.</span><br><span class="line">     *</span><br><span class="line">     * @return the lock used for writing</span><br><span class="line">     */</span><br><span class="line">    Lock writeLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>ReetrantReadWriteLock</em></strong></p>
<p>Java并发库中ReetrantReadWriteLock实现了ReadWriteLock接口并添加了可重入的特性。</p>
<p>而ReentrantReadWriteLock允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。相对于排他锁，提高了并发性。在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时ReentrantReadWriteLock能够提供比排他锁更好的并发性和吞吐量。</p>
<p>ReentrantReadWriteLock支持以下功能</p>
<ul>
<li>支持公平和非公平的获取锁的方式</li>
<li>支持可重入</li>
<li>允许从写入锁降级为读取锁，获取写锁后可以获取读锁，最后释放写锁；如果先获取读锁，则不允许升级为写锁。</li>
<li>支持锁中断</li>
<li>Condition支持</li>
</ul>
<p>相关实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class RRWTest &#123;</span><br><span class="line">    Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    ReadWriteLock readWriteLock = new ReentrantReadWriteLock();</span><br><span class="line">    Lock rl = readWriteLock.readLock();</span><br><span class="line">    Lock wl = readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public Integer get(String key) &#123;</span><br><span class="line">        Integer res = null;</span><br><span class="line">        rl.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            res = map.get(key);</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line">            rl.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void put(String key, Integer value) &#123;</span><br><span class="line">        wl.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line">            wl.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        wl.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line">            wl.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Condition</li>
</ol>
<p>Condition类似于条件队列，当一个线程在调用了await方法以后，直到线程等待的某个条件为真的时候才会被唤醒。这种方式为线程提供了更加简单的等待/通知模式。Condition必须要配合锁一起使用，因为对共享状态变量的访问发生在多线程环境下。一个Condition的实例必须与一个Lock绑定，因此Condition一般都是作为Lock的内部实现。</p>
<p>相关源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface Condition &#123;</span><br><span class="line">//	在接到信号或被中断之前一直处于等待状态</span><br><span class="line">    void await() throws InterruptedException;</span><br><span class="line">    boolean await(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line">	</span><br><span class="line">//	造成当前线程在接到信号之前一直处于等待状态</span><br><span class="line">    void awaitUninterruptibly();</span><br><span class="line">//	造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态</span><br><span class="line">    long awaitNanos(long nanosTimeout) throws InterruptedException;</span><br><span class="line">//	造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。如果没有到指定时间就被通知，则返回true，否则表示到了指定时间，返回返回false。</span><br><span class="line">    boolean awaitUntil(Date deadline) throws InterruptedException;</span><br><span class="line">//	唤醒等待线程</span><br><span class="line">    void signal();</span><br><span class="line">    void signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Condition是AQS的内部类。每个Condition对象都包含一个队列(等待队列)。等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。</p>
<ol start="5">
<li>LockSupport</li>
</ol>
<p>LockSupport是JDK中比较底层的类，用来创建锁和其他同步工具类的基本线程阻塞原语。LockSupport很类似于二元信号量(只有1个许可证可供使用)，如果这个许可还没有被占用，当前线程获取许可并继续执行；如果许可已经被占用，当前线程阻塞，等待获取许可。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: 古城烟雨</p><p>原文链接: <a href="http://zws6672.top/2021/01/14/java-concurrence-2/">http://zws6672.top/2021/01/14/java-concurrence-2/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/并发/">并发</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2021/01/15/java-executers/" class="pre">Java 并发（四）线程池</a><a href="/2021/01/11/java-concurrence-0/" class="next">java 并发（二） 线程安全与同步</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、Atomic"><span class="toc-text">一、Atomic</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、并发集合"><span class="toc-text">二、并发集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、锁"><span class="toc-text">三、锁</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/fmi-daccosim/">基于FMI标准的仿真软件————Daccosim</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/vue_add_method/">vue_add_method</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/test/">test</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/springboot-1/">springboot（一）入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/26/jdk-bytecodeEngine/">虚拟机字节码执行引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/15/jdk-cload/">虚拟机类加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/14/jdk-classesFileStruct/">深入理解Java虚拟机——类文件结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/04/springboot-aop/">SpringBoot 使用 AOP（面向切面编程）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/30/mysql-lock/">mysql 引擎的行锁与表锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/29/design-structure-eg/">结构型模式——实例</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/devops/" style="font-size: 15px;">devops</a> <a href="/tags/neo4j/" style="font-size: 15px;">neo4j</a> <a href="/tags/CI/" style="font-size: 15px;">CI</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/oracle/" style="font-size: 15px;">oracle</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/系统/" style="font-size: 15px;">系统</a> <a href="/tags/博客搭建/" style="font-size: 15px;">博客搭建</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/ms/" style="font-size: 15px;">ms</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/运维/" style="font-size: 15px;">运维</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/javaweb/" style="font-size: 15px;">javaweb</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/微服务/" style="font-size: 15px;">微服务</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/elasticsearch/" style="font-size: 15px;">elasticsearch</a> <a href="/tags/fmi/" style="font-size: 15px;">fmi</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/nk/" style="font-size: 15px;">nk</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://juejin.im/" title="掘金" target="_blank">掘金</a><ul></ul><a href="https://www.cnblogs.com/" title="博客园" target="_blank">博客园</a><ul></ul><a href="https://www.infoq.cn/" title="info" target="_blank">info</a><ul></ul><a href="https://www.ibm.com/" title="ibm" target="_blank">ibm</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">古城烟雨.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>
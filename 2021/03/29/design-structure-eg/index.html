<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一些关于技术的碎语"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>结构型模式——实例 | 微言术语</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">结构型模式——实例</h1><a id="logo" href="/.">微言术语</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">结构型模式——实例</h1><div class="post-meta"><a href="/2021/03/29/design-structure-eg/#comments" class="comment-count"></a><p><span class="date">Mar 29, 2021</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="适配器模式（兼容）"><a href="#适配器模式（兼容）" class="headerlink" title="适配器模式（兼容）"></a>适配器模式（兼容）</h1><p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作；可以分为类适配器模式以及对象适配器模式。</p>
<ol>
<li>类适配器模式</li>
</ol>
<p>类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p>
<p>相关实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/29 12:50</span><br><span class="line"> * @Description 类适配器</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 适配器类：通过包装一个需要适配的对象，把原接口转换成目标接口。</span><br><span class="line">public class AdapterTest extends Adaptee implements AdapterTarget&#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        AdapterTarget target = new AdapterTest();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request2() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request3() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 目标接口：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类</span><br><span class="line">interface AdapterTarget &#123;</span><br><span class="line">    void request();</span><br><span class="line">    void request2();</span><br><span class="line">    void request3();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 适配者接口：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法</span><br><span class="line">class Adaptee &#123;</span><br><span class="line">    public void adapteeRequest() &#123;</span><br><span class="line">        System.out.println(&quot;适配者接口的业务代码&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对象适配器模式：对于这种对象的适配器模式，实际上就是通过一个适配器类，把目标类和需要被适配的类进行组合。所以适配器类Adapter一般需要继承或实现Targert，并且还得持有Adaptee的实例引用。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 对象适配器</span><br><span class="line">class ObjectAdapter implements AdapterTarget &#123;</span><br><span class="line">    private Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    public ObjectAdapter(Adaptee adaptee) &#123;</span><br><span class="line">        this.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        adaptee.adapteeRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request2() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request3() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">public class AdapterTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        ObjectAdapter adapter = new ObjectAdapter(new Adaptee());</span><br><span class="line">        adapter.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>为什么使用适配器模式</li>
</ol>
<p>假如在旧的接口涉及到其它功能，这时候我们需要增加一个新的参数。如果在旧有的接口做修改，会影响到其它的实现类。所以，我们可以通过定义适配器来扩展接口，实现和老代码的兼容。但是，如果过渡使用适配器模式，会导致代码结构散乱，难以重构。</p>
<h1 id="代理模式（附加功能与核心功能解耦）"><a href="#代理模式（附加功能与核心功能解耦）" class="headerlink" title="代理模式（附加功能与核心功能解耦）"></a>代理模式（附加功能与核心功能解耦）</h1><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。代理模式通过增加中间层，为其他对象提供一种代理以控制对这个对象的访问，还可以想在访问一个类时做一些控制。代理模式分为:</p>
<ul>
<li>静态代理：所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</li>
<li>动态代理：动态代理是在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象。</li>
</ul>
<p>相关实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/29 13:19</span><br><span class="line"> * @Description 代理模式</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class ProxyTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        ProxyTool tool = new ProxyTool(new RealTool());</span><br><span class="line">        tool.description();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//抽象接口</span><br><span class="line">interface Tool &#123;</span><br><span class="line">    void description();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RealTool implements Tool&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void description() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;这是一个被代理类的描述方法&quot;);</span><br><span class="line">            Thread.sleep((int) (Math.random()*1000));</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProxyTool implements Tool &#123;</span><br><span class="line">    Tool tool;</span><br><span class="line"></span><br><span class="line">    public ProxyTool(Tool tool) &#123;</span><br><span class="line">        this.tool = tool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void description() &#123;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        tool.description();</span><br><span class="line">        System.out.println((System.currentTimeMillis()-startTime) + &quot;毫秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在 RPC、缓存等应用场景中。</p>
<h1 id="桥接模式（多维度解耦）"><a href="#桥接模式（多维度解耦）" class="headerlink" title="桥接模式（多维度解耦）"></a>桥接模式（多维度解耦）</h1><p>如果一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。</p>
<p>桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。桥接模式将继承关系转化成关联关系，它降低了类与类之间的耦合度，减少了系统中类的数量，也减少了代码量。</p>
<ul>
<li>抽象化：其概念是将复杂物体的一个或几个特性抽出去而只注意其他特性的行动或过程。在面向对象就是将对象共同的性质抽取出去而形成类的过程。</li>
<li>实现化：针对抽象化给出的具体实现。它和抽象化是一个互逆的过程，实现化是对抽象化事物的进一步具体化。</li>
<li>脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。</li>
</ul>
<p>桥接模式主要包含如下几个角色：</p>
<ul>
<li>Abstraction：抽象类</li>
<li>RefinedAbstraction：扩充抽象类</li>
<li>Implementor：实现类接口</li>
<li>ConcreteImplementor：具体实现类</li>
</ul>
<p>相关实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/29 13:33</span><br><span class="line"> * @Description 桥接模式</span><br><span class="line"> */</span><br><span class="line">public class BridgeTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        Shape shape = new Circle();</span><br><span class="line">        Color color = new White();</span><br><span class="line">        shape.setColor(color);</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 抽象类</span><br><span class="line">abstract class Shape &#123;</span><br><span class="line">    Color color;</span><br><span class="line"></span><br><span class="line">    public void setColor(Color color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void draw();</span><br><span class="line">&#125;</span><br><span class="line">// 扩充抽象类</span><br><span class="line">class Circle extends Shape&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        color.bepaint(&quot;正方形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现类接口</span><br><span class="line">interface Color &#123;</span><br><span class="line">    public void bepaint(String shape);</span><br><span class="line">&#125;</span><br><span class="line">// 具体实现类</span><br><span class="line">class White implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void bepaint(String shape) &#123;</span><br><span class="line">        System.out.println(&quot;白色的&quot; + shape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="装饰模式（扩展）"><a href="#装饰模式（扩展）" class="headerlink" title="装饰模式（扩展）"></a>装饰模式（扩展）</h1><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。装饰器模式是为了动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
<p>相关实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/29 13:40</span><br><span class="line"> * @Description 装饰器模式</span><br><span class="line"> */</span><br><span class="line">public class DecoratorTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        Bird bird = new Eagle();</span><br><span class="line">        BirdDecorator decorator = new WhiteBirdDecorator(bird);</span><br><span class="line">        decorator.des();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象</span><br><span class="line">interface Bird &#123;</span><br><span class="line">    void des();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体构件（Concrete Component）角色：定义一个将要接收附加责任的类</span><br><span class="line">class Eagle implements Bird &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void des() &#123;</span><br><span class="line">        System.out.println(&quot;小型至中型的白昼活动的鹰形类鸟&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口</span><br><span class="line">abstract class BirdDecorator implements Bird &#123;</span><br><span class="line">    public Bird bird;</span><br><span class="line"></span><br><span class="line">    public BirdDecorator(Bird bird) &#123;</span><br><span class="line">        this.bird = bird;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void des() &#123;</span><br><span class="line">        bird.des();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任</span><br><span class="line">class WhiteBirdDecorator extends  BirdDecorator &#123;</span><br><span class="line">    public WhiteBirdDecorator(Bird bird) &#123;</span><br><span class="line">        super(bird);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void des() &#123;</span><br><span class="line">        bird.des();</span><br><span class="line">        extend();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void extend() &#123;</span><br><span class="line">        System.out.println(&quot;白色的鸟&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="外观模式（同一接口）"><a href="#外观模式（同一接口）" class="headerlink" title="外观模式（同一接口）"></a>外观模式（同一接口）</h1><p>外观模式提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。</p>
<p>外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点：</p>
<ul>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
<li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>
</ul>
<p>相关实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/29 13:57</span><br><span class="line"> * @Description 外观模式</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class FacadeTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        Facade facade = new Facade();</span><br><span class="line">        facade.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//外观角色</span><br><span class="line">class Facade &#123;</span><br><span class="line">    private SubSystem01 obj1 = new SubSystem01();</span><br><span class="line">    private SubSystem02 obj2 = new SubSystem02();</span><br><span class="line">    private SubSystem03 obj3 = new SubSystem03();</span><br><span class="line"></span><br><span class="line">    public void method() &#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem01 &#123;</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;子系统01的method1()被调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem02 &#123;</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;子系统02的method2()被调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem03 &#123;</span><br><span class="line">    public void method3() &#123;</span><br><span class="line">        System.out.println(&quot;子系统03的method3()被调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="享元模式（对象共享）"><a href="#享元模式（对象共享）" class="headerlink" title="享元模式（对象共享）"></a>享元模式（对象共享）</h1><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>
<p>模式所涉及的角色：</p>
<ul>
<li>Flyweight： 享元接口，通过这个接口传入外部状态并作用于外部状态；</li>
<li>ConcreteFlyweight： 具体的享元实现对象，必须是可共享的，需要封装享元对象的内部状态；</li>
<li>UnsharedConcreteFlyweight： 非共享的享元实现对象，并不是所有的享元对象都可以共享，非共享的享元对象通常是享元对象的组合对象；</li>
<li>FlyweightFactory： 享元工厂，主要用来创建并管理共享的享元对象，并对外提供访问共享享元的接口；</li>
</ul>
<p>享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</p>
<p>享元对象能做到共享的关键是区分两个状态：<br>内部状态(Internal State)：存储在享元对象内部并且不会随环境改变而改变的状态<br>外部状态(External State)：随环境改变而改变的、不可以共享的状态</p>
<p>相关实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">// 接口</span><br><span class="line">public interface Shape &#123;</span><br><span class="line">   void draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建实现接口的实体类</span><br><span class="line">public class Circle implements Shape &#123;</span><br><span class="line">   private String color;</span><br><span class="line">   private int x;</span><br><span class="line">   private int y;</span><br><span class="line">   private int radius;</span><br><span class="line"> </span><br><span class="line">   public Circle(String color)&#123;</span><br><span class="line">      this.color = color;     </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setX(int x) &#123;</span><br><span class="line">      this.x = x;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setY(int y) &#123;</span><br><span class="line">      this.y = y;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setRadius(int radius) &#123;</span><br><span class="line">      this.radius = radius;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Circle: Draw() [Color : &quot; + color </span><br><span class="line">         +&quot;, x : &quot; + x +&quot;, y :&quot; + y +&quot;, radius :&quot; + radius);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 享元工厂</span><br><span class="line"></span><br><span class="line">public class ShapeFactory &#123;</span><br><span class="line">   private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">   public static Shape getCircle(String color) &#123;</span><br><span class="line">      Circle circle = (Circle)circleMap.get(color);</span><br><span class="line"> </span><br><span class="line">      if(circle == null) &#123;</span><br><span class="line">         circle = new Circle(color);</span><br><span class="line">         circleMap.put(color, circle);</span><br><span class="line">         System.out.println(&quot;Creating circle of color : &quot; + color);</span><br><span class="line">      &#125;</span><br><span class="line">      return circle;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FlyweightPatternDemo &#123;</span><br><span class="line">   private static final String colors[] = </span><br><span class="line">      &#123; &quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;White&quot;, &quot;Black&quot; &#125;;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">      for(int i=0; i &lt; 20; ++i) &#123;</span><br><span class="line">         Circle circle = </span><br><span class="line">            (Circle)ShapeFactory.getCircle(getRandomColor());</span><br><span class="line">         circle.setX(getRandomX());</span><br><span class="line">         circle.setY(getRandomY());</span><br><span class="line">         circle.setRadius(100);</span><br><span class="line">         circle.draw();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   private static String getRandomColor() &#123;</span><br><span class="line">      return colors[(int)(Math.random()*colors.length)];</span><br><span class="line">   &#125;</span><br><span class="line">   private static int getRandomX() &#123;</span><br><span class="line">      return (int)(Math.random()*100 );</span><br><span class="line">   &#125;</span><br><span class="line">   private static int getRandomY() &#123;</span><br><span class="line">      return (int)(Math.random()*100);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="组合模式（部分-整体）"><a href="#组合模式（部分-整体）" class="headerlink" title="组合模式（部分-整体）"></a>组合模式（部分-整体）</h1><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>
<p>相关实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">   private String name;</span><br><span class="line">   private String dept;</span><br><span class="line">   private int salary;</span><br><span class="line">   private List&lt;Employee&gt; subordinates;</span><br><span class="line"> </span><br><span class="line">   //构造函数</span><br><span class="line">   public Employee(String name,String dept, int sal) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">      this.dept = dept;</span><br><span class="line">      this.salary = sal;</span><br><span class="line">      subordinates = new ArrayList&lt;Employee&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void add(Employee e) &#123;</span><br><span class="line">      subordinates.add(e);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void remove(Employee e) &#123;</span><br><span class="line">      subordinates.remove(e);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public List&lt;Employee&gt; getSubordinates()&#123;</span><br><span class="line">     return subordinates;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String toString()&#123;</span><br><span class="line">      return (&quot;Employee :[ Name : &quot;+ name </span><br><span class="line">      +&quot;, dept : &quot;+ dept + &quot;, salary :&quot;</span><br><span class="line">      + salary+&quot; ]&quot;);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CompositePatternDemo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Employee CEO = new Employee(&quot;John&quot;,&quot;CEO&quot;, 30000);</span><br><span class="line"> </span><br><span class="line">      Employee headSales = new Employee(&quot;Robert&quot;,&quot;Head Sales&quot;, 20000);</span><br><span class="line"> </span><br><span class="line">      Employee headMarketing = new Employee(&quot;Michel&quot;,&quot;Head Marketing&quot;, 20000);</span><br><span class="line"> </span><br><span class="line">      Employee clerk1 = new Employee(&quot;Laura&quot;,&quot;Marketing&quot;, 10000);</span><br><span class="line">      Employee clerk2 = new Employee(&quot;Bob&quot;,&quot;Marketing&quot;, 10000);</span><br><span class="line"> </span><br><span class="line">      Employee salesExecutive1 = new Employee(&quot;Richard&quot;,&quot;Sales&quot;, 10000);</span><br><span class="line">      Employee salesExecutive2 = new Employee(&quot;Rob&quot;,&quot;Sales&quot;, 10000);</span><br><span class="line"> </span><br><span class="line">      CEO.add(headSales);</span><br><span class="line">      CEO.add(headMarketing);</span><br><span class="line"> </span><br><span class="line">      headSales.add(salesExecutive1);</span><br><span class="line">      headSales.add(salesExecutive2);</span><br><span class="line"> </span><br><span class="line">      headMarketing.add(clerk1);</span><br><span class="line">      headMarketing.add(clerk2);</span><br><span class="line"> </span><br><span class="line">      //打印该组织的所有员工</span><br><span class="line">      System.out.println(CEO); </span><br><span class="line">      for (Employee headEmployee : CEO.getSubordinates()) &#123;</span><br><span class="line">         System.out.println(headEmployee);</span><br><span class="line">         for (Employee employee : headEmployee.getSubordinates()) &#123;</span><br><span class="line">            System.out.println(employee);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;        </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><blockquote><p>原文作者: 古城烟雨</p><p>原文链接: <a href="http://zws6672.top/2021/03/29/design-structure-eg/">http://zws6672.top/2021/03/29/design-structure-eg/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/设计模式/">设计模式</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2021/03/30/mysql-lock/" class="pre">mysql 引擎的行锁与表锁</a><a href="/2021/03/29/jdk8/" class="next">JDK8 语言新特性</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#适配器模式（兼容）"><span class="toc-text">适配器模式（兼容）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#代理模式（附加功能与核心功能解耦）"><span class="toc-text">代理模式（附加功能与核心功能解耦）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#桥接模式（多维度解耦）"><span class="toc-text">桥接模式（多维度解耦）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#装饰模式（扩展）"><span class="toc-text">装饰模式（扩展）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#外观模式（同一接口）"><span class="toc-text">外观模式（同一接口）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#享元模式（对象共享）"><span class="toc-text">享元模式（对象共享）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#组合模式（部分-整体）"><span class="toc-text">组合模式（部分-整体）</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/mysql-opt/">MySQL 优化(一)设计与功能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/tool-uml/">UML中关系</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/fmi-ssp-dcp/">了解fmi、ssp与dcp</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/hexo-sync/">多PC同步hexo</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/fmi-daccosim/">基于FMI标准的仿真软件————Daccosim</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/springboot-1/">springboot（一）入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/13/jdk-backend-compile/">后端编译与优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/13/jdk-front-compile/">前端编译与优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/26/jdk-bytecodeEngine/">虚拟机字节码执行引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/15/jdk-cload/">虚拟机类加载机制</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/devops/" style="font-size: 15px;">devops</a> <a href="/tags/CI/" style="font-size: 15px;">CI</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/neo4j/" style="font-size: 15px;">neo4j</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/oracle/" style="font-size: 15px;">oracle</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/系统/" style="font-size: 15px;">系统</a> <a href="/tags/博客搭建/" style="font-size: 15px;">博客搭建</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/ms/" style="font-size: 15px;">ms</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/运维/" style="font-size: 15px;">运维</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/javaweb/" style="font-size: 15px;">javaweb</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/elasticsearch/" style="font-size: 15px;">elasticsearch</a> <a href="/tags/fmi/" style="font-size: 15px;">fmi</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/微服务/" style="font-size: 15px;">微服务</a> <a href="/tags/nk/" style="font-size: 15px;">nk</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/soft-skills/" style="font-size: 15px;">soft-skills</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://juejin.im/" title="掘金" target="_blank">掘金</a><ul></ul><a href="https://www.cnblogs.com/" title="博客园" target="_blank">博客园</a><ul></ul><a href="https://www.infoq.cn/" title="info" target="_blank">info</a><ul></ul><a href="https://www.ibm.com/" title="ibm" target="_blank">ibm</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">古城烟雨.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>
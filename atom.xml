<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>微言术语</title>
  
  
  <link href="http://zws6672.top/atom.xml" rel="self"/>
  
  <link href="http://zws6672.top/"/>
  <updated>2021-05-16T05:57:12.405Z</updated>
  <id>http://zws6672.top/</id>
  
  <author>
    <name>古城烟雨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL 优化(一)设计与功能优化</title>
    <link href="http://zws6672.top/2021/05/16/mysql-opt/"/>
    <id>http://zws6672.top/2021/05/16/mysql-opt/</id>
    <published>2021-05-16T05:56:21.000Z</published>
    <updated>2021-05-16T05:57:12.405Z</updated>
    
    <content type="html"><![CDATA[<p>MYSQL优化包括设计、功能、架构与高性能SQL几个方面。Mysql优化，一方面是找出系统的瓶颈，提高mysql数据库整体的性能，另外一个方面需要合理的结构设计和参数调整，以提高用户操作响应的速度。同时还要尽可能节省系统资源，以便系统可以提供更大负荷的服务。mysql数据库优化是多方面的，原则是减少系统的瓶颈，减少资源的占用，增加系统反应的速度。</p><ul><li>设计：存储引擎，字段类型，范式与逆范式</li><li>功能：索引，缓存，分区分表</li><li>高性能SQL：SQL优化、explain</li><li>架构：主从复制，读写分离，负载均衡。</li></ul><h1 id="一、设计优化"><a href="#一、设计优化" class="headerlink" title="一、设计优化"></a>一、设计优化</h1><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>存储引擎是一种用来存储MySQL中对象（记录和索引）的一种特定的结构（文件结构），处于MySQL服务器的最底层，直接存储数据</p><p>指定存储引擎：<code>Create table tableName () engine=myisam|innodb</code></p><ol><li>查询支持的引擎</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show engines;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">Engine</th><th align="left">Support</th><th align="left">Comment</th><th align="left">Transactions</th><th align="left">XA</th><th align="left">Savepoints</th></tr></thead><tbody><tr><td align="left">MEMORY</td><td align="left">YES</td><td align="left">基于哈希的，存储在内存中，对临时表有用</td><td align="left">NO</td><td align="left">NO</td><td align="left">NO</td></tr><tr><td align="left">MRG_MYISAM</td><td align="left">YES</td><td align="left">与MyISAM表相同的集合</td><td align="left">NO</td><td align="left">NO</td><td align="left">NO</td></tr><tr><td align="left">CSV</td><td align="left">YES</td><td align="left">CSV存储引擎</td><td align="left">NO</td><td align="left">NO</td><td align="left">NO</td></tr><tr><td align="left">FEDERATED</td><td align="left">NO</td><td align="left">联合MySQL存储引擎</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">PERFORMANCE_SCHEMA</td><td align="left">YES</td><td align="left">性能模式</td><td align="left">NO</td><td align="left">NO</td><td align="left">NO</td></tr><tr><td align="left">MyISAM</td><td align="left">YES</td><td align="left">MyISAM存储引擎</td><td align="left">NO</td><td align="left">NO</td><td align="left">NO</td></tr><tr><td align="left">InnoDB</td><td align="left">DEFAULT</td><td align="left">支持事务、行级锁定和外键</td><td align="left">YES</td><td align="left">YES</td><td align="left">YES</td></tr><tr><td align="left">BLACKHOLE</td><td align="left">YES</td><td align="left">/dev/null存储引擎（您向其写入的任何内容都将消失）</td><td align="left">NO</td><td align="left">NO</td><td align="left">NO</td></tr><tr><td align="left">ARCHIVE</td><td align="left">YES</td><td align="left">存档存储引擎</td><td align="left">NO</td><td align="left">NO</td><td align="left">NO</td></tr></tbody></table><blockquote><p>注：engine：引擎名称<br>suppot：MySQL数据库是否支持<br>comment：说明<br>transactions：是够支持事务<br>xa：是否支持XA事务（分布式事务）<br>savepoints：是否支持保存savepoints之间的内容</p></blockquote><ol start="2"><li>InnoDB存储引擎</li></ol><p>Mysql版本&gt;=5.5 默认的存储引擎，MySQL推荐使用的存储引擎。支持事务，行级锁定，外键约束。事务安全型存储引擎。更加注重数据的完整性和安全性。innodb擅长事务、数据的完整性及高并发处理，不擅长快速插入（插入前要排序，消耗时间）和检索</p><p>创建数据库表后生成如下文件：</p><ul><li>db.opt存放了数据库的配置信息，比如数据库的字符集还有编码格式</li><li>XX.frm是表结构文件，仅存储了表的结构、元数据(meta)，包括表结构定义信息等；表引擎都会有一个frm文件。</li><li>XX.ibd是表索引文件，包括了单独一个表的数据及索引内容。</li></ul><p>共享表空间<br>    +    Innodb的所有数据保存在一个单独的表空间里面，而这个表空间可以由很多个文件组成，一个表可以跨多个文件存在，所以其大小限制不再是文件大小的限制，而是其自身的限制。其表空间的最大限制为64TB，也就是说，Innodb的单表限制基本上也在64TB左右。<br>    +    优点：表空间可以分成多个文件存放到各个磁盘，所以表也就可以分成多个文件存放在磁盘上，表的大小不受磁盘大小的限制<br>    +    缺点：所有的数据和索引存放到一个文件，虽然可以把一个大文件分成多个小文件，但是多个表及索引在表空间中混合存储，当数据量非常大的时候，表做了大量删除操作后表空间中将会有大量的空隙，特别是对于统计分析，对于经常删除操作的这类应用最不适合用共享表空间；共享表空间分配后不能回缩：当出现临时建索引或是创建一个临时表的操作表空间扩大后，就是删除相关的表也没办法回缩那部分空间了。<br>独立表空间<br>    +    独立表空间是把每个表的数据和表文件放在一起，每表对应一个 idb文件<br>    +    优点：每个表都有自已独立的表空间，每个表的数据和索引都会存在自已的表空间中，可以实现单表在不同的数据库中移动。<br>    +    缺点：单表增加过大，当单表占用空间过大时，存储空间不足，只能从操作系统层面思考解决方法</p><p>InnoDB采用按表空间（tablespace)的方式进行存储数据, 默认配置情况下会有一个初始大小为10MB， 名字为ibdata1的文件， 该文件就是默认的表空间文件（tablespce file），用户可以通过参数innodb_data_file_path对其进行设置，可以有多个数据文件，如果没有设置innodb_file_per_table的话， 那些Innodb存储类型的表的数据都放在这个共享表空间中，而系统变量innodb_file_per_table=1的话，那么InnoDB存储引擎类型的表就会产生一个独立表空间，独立表空间的命名规则为：表名.idb. 这些单独的表空间文件仅存储该表的数据、索引和插入缓冲BITMAP等信息，其它信息还是存放在共享表空间中。</p><p>查看是否开启独立表空间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;innodb_file_per_table&apos;</span><br><span class="line">innodb_file_per_tableON  </span><br><span class="line">OFF 代表mysql是共享表空间，也就是所有库的数据都存放在一个ibdate1文件中</span><br><span class="line">ON 表示mysql是独立表空间</span><br></pre></td></tr></table></figure><p>开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在my.conf文件中[mysqld] 顶点下添加innodb_file_per_table=1</span><br><span class="line"></span><br><span class="line">或者通过命令：set global innodb_file_per_table=1;</span><br><span class="line">innodb_file_per_table=1 为使用独占表空间</span><br><span class="line">innodb_file_per_table=0 为使用共享表空间</span><br><span class="line">innodb_data_home_dir = &quot;C:\mysql\data\&quot;</span><br><span class="line"></span><br><span class="line">show variables like &apos;innodb_data_home_dir&apos; --数据库文件所存放的目录</span><br><span class="line">show variables like &apos;innodb_log_group_home_dir&apos; --日志存放目录</span><br><span class="line">show variables like &apos;innodb_data_file_path&apos; --指定innodb 共享 表空间文件</span><br><span class="line">innodb_data_file_pathibdata1:12M:autoextend（存储到 ibdata1 初始大小为12M 自动扩容）</span><br></pre></td></tr></table></figure><blockquote><p>注：InnoDB不创建目录，所以在启动服务器之前请确认”所配置的路径目录”的确存在。这对你配置的任何日志文件目录来说也是真实的。使用Unix或DOS的mkdir命令来创建任何必需的目录。通过把innodb_data_home_dir的值原原本本地部署到数据文件名，并在需要的地方添加斜杠或反斜杠，InnoDB为每个数据文件形成目录路径</p></blockquote><ol start="3"><li>MyISAM 存储引擎<br>MySQL&lt;= 5.5 MySQL默认的存储引擎；擅长与处理，高速读与写。<br>特点：</li></ol><ul><li>数据和索引分别存储于不同的文件中。</li><li>数据的存储顺序为插入顺序（没有经过排序、插入速度快，空间占用量小）</li><li>功能<ul><li>全文索引支持</li><li>数据的压缩存储（myisamPack）</li><li>并发性<ul><li>仅仅支持表级锁定，不支持高并发。</li><li>支持并发插入。写操作中的插入操作，不会阻塞读操作（其他操作）</li></ul></li></ul></li></ul><p>Innodb 和 MyISAM 比较：</p><ul><li>Innodb ：数据完整性，并发性处理，擅长更新，删除。</li><li>myisam：高速查询及插入。擅长插入和查询。</li></ul><p>其他存储引擎：</p><ul><li>Archive：存档型，仅提供插入和查询操作。非常高效阻塞的插入和查询。</li><li>Memory：内存型，数据存储于内存中，存储引擎。缓存型存储引擎。</li><li>插件式存储引擎：用C和C++开发的存储引擎。</li></ul><ol start="4"><li>数据库锁</li></ol><p>当客户端操作表（记录）时，为了保证操作的隔离性（多个客户端操作不能互相影响），通过加锁来处理。</p><h3 id="字段类型选择"><a href="#字段类型选择" class="headerlink" title="字段类型选择"></a>字段类型选择</h3><p>类型取值如下：</p><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">范围（有符号）</th><th align="left">范围（无符号）</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">数值类型<br></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">TINYINT</td><td align="left">1 byte</td><td align="left">(-128，127)</td><td align="left">(0，255)</td><td align="left">小整数值</td></tr><tr><td align="left">SMALLINT</td><td align="left">2 bytes</td><td align="left">(-32 768，32 767)</td><td align="left">(0，65 535)</td><td align="left">大整数值</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3 bytes</td><td align="left">(-8 388 608，8 388 607)</td><td align="left">(0，16 777 215)</td><td align="left">大整数值</td></tr><tr><td align="left">INT或INTEGER</td><td align="left">4 bytes</td><td align="left">(-2 147 483 648，2 147 483 647)</td><td align="left">(0，4 294 967 295)</td><td align="left">大整数值</td></tr><tr><td align="left">BIGINT</td><td align="left">8 bytes</td><td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td align="left">(0，18 446 744 073 709 551 615)</td><td align="left">极大整数值</td></tr><tr><td align="left">FLOAT</td><td align="left">4 bytes</td><td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="left">单精度</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">浮点数值</td></tr><tr><td align="left">DOUBLE</td><td align="left">8 bytes</td><td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">双精度</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">浮点数值</td></tr><tr><td align="left">DECIMAL</td><td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td align="left">依赖于M和D的值</td><td align="left">依赖于M和D的值</td><td align="left">小数值</td></tr><tr><td align="left">日期和时间类型<br></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">DATE</td><td align="left">3</td><td align="left">1000-01-01/9999-12-31</td><td align="left">YYYY-MM-DD</td><td align="left">日期值</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘-838:59:59’/‘838:59:59’</td><td align="left">HH:MM:SS</td><td align="left">时间值或持续时间</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">1901/2155</td><td align="left">YYYY</td><td align="left">年份值</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">1000-01-01 00:00:00/9999-12-31 23:59:59</td><td align="left">YYYY-MM-DD HH:MM:SS</td><td align="left">混合日期和时间值</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">1970-01-01 00:00:00/2038</td><td align="left">YYYYMMDD HHMMSS</td><td align="left">混合日期和时间值，时间戳</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">字符串类型<br></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">CHAR</td><td align="left">0-255 bytes</td><td align="left"></td><td align="left"></td><td align="left">定长字符串</td></tr><tr><td align="left">VARCHAR</td><td align="left">0-65535 bytes</td><td align="left"></td><td align="left"></td><td align="left">变长字符串</td></tr><tr><td align="left">TINYBLOB</td><td align="left">0-255 bytes</td><td align="left"></td><td align="left"></td><td align="left">不超过 255 个字符的二进制字符串</td></tr><tr><td align="left">TINYTEXT</td><td align="left">0-255 bytes</td><td align="left"></td><td align="left"></td><td align="left">短文本字符串</td></tr><tr><td align="left">BLOB</td><td align="left">0-65 535 bytes</td><td align="left"></td><td align="left"></td><td align="left">二进制形式的长文本数据</td></tr><tr><td align="left">TEXT</td><td align="left">0-65 535 bytes</td><td align="left"></td><td align="left"></td><td align="left">长文本数据</td></tr><tr><td align="left">MEDIUMBLOB</td><td align="left">0-16 777 215 bytes</td><td align="left"></td><td align="left"></td><td align="left">二进制形式的中等长度文本数据</td></tr><tr><td align="left">MEDIUMTEXT</td><td align="left">0-16 777 215 bytes</td><td align="left"></td><td align="left"></td><td align="left">中等长度文本数据</td></tr><tr><td align="left">LONGBLOB</td><td align="left">0-4 294 967 295 bytes</td><td align="left"></td><td align="left"></td><td align="left">二进制形式的极大文本数据</td></tr><tr><td align="left">LONGTEXT</td><td align="left">0-4 294 967 295 bytes</td><td align="left"></td><td align="left"></td><td align="left">极大文本数据</td></tr></tbody></table><p>选择优化的数据类型原则：</p><ul><li>更小的通常更好</li><li>简单数据类型需要更少的CPU周期（用MySQL内建的类型(date, time, datetime)来存储时间和日期、使用整型存储IP地址）</li><li>指定列为NOT NULL（可为NULL的列使得索引、索引统计和值比较都更复杂）</li></ul><p>分类：</p><ul><li>整数类型<ul><li>TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT分别使用8,16,24,32,64位存储空间。它们可以存储的值得范围从-2(N-1)到2(N-1)-1，如果是UNSIGNED，表示不允许负值，那正数的上限提高一倍</li></ul></li><li>浮点类型<ul><li>FLOAT、DOUBLE、DECIMAL（高精度） 分别使用4字节、8字节、可变个字节存储</li></ul></li><li>字符串类型<ul><li>VARCHAR比CHAR更节省空间，VARCHAR会使用1或2个额外的字节记录字符串的长度。如果使用UTF8字符集，应该选择VARCHAR类型。CHAR适合存储很短的字符串，或者所有值都接近同一个长度。比如MD5加密后的值。对于经常变更的数据，CHAR比VARCHAR更好，因为CHAR类型不易产生碎片</li></ul></li><li>日期和时间类型<ul><li>DATETIME使用8个字节的存储空间，TIMESTAMP使用4个字节，一般情况下尽量选择TIMESTAMP类型</li></ul></li></ul><p>TIMESTAMP 特点：</p><ul><li>当更新一条数据的时候，设置此类型根据当前系统更新可自动更新时间</li><li>如果插入一条NULL，也会自动插入当前系统时间</li><li>创建时，自动设置默认值</li><li>会根据当前时区来存储和查询时间，存储时对当前时区进行转换，查询时再转换为当前的时区</li></ul><h3 id="范式与逆范式"><a href="#范式与逆范式" class="headerlink" title="范式与逆范式"></a>范式与逆范式</h3><p>为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。逆范式是指打破范式，通过增加冗余或重复的数据来提高数据库的性能。</p><p>三大范式：</p><ul><li>第一范式1NF，原子性；段值都是不可分解</li><li>第二范式2NF，消除部分依赖；表中的每列都和主键相关</li><li>第三范式3NF，消除传递依赖；表中非主键列不依赖于其它非主键列</li><li>优点<ul><li>范式可以避免数据冗余，减少数据库的空间，减轻维护数据完整性的麻烦。</li></ul></li><li>缺点<ul><li>所用的范式越高，对数据操作的性能越低。所以我们在利用范式设计表的时候，要根据具体的需求再去权衡是否使用更高范式去设计表。</li></ul></li></ul><h1 id="二、功能优化"><a href="#二、功能优化" class="headerlink" title="二、功能优化"></a>二、功能优化</h1><p>功能优化包含索引，缓存，分区分表等部分。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的关键字一定是排序的。索引本质上是表字段的有序子集，类似于一个目录，通过它可以快速定位数据。</p><ol><li>分类</li></ol><ul><li>种类<ul><li>聚集索引(clustered index)：子顶点存储行记录，有且只有一个聚焦索引。存在主键，则主键是聚焦索引；否则第一个not NULL unique列是聚集索引；否则，InnoDB会创建一个隐藏的row-id作为聚集索引。</li><li>普通索引(secondary index)</li></ul></li><li>类型<ul><li>主键索引,primary key：要求关键字不能重复，也不能为NULL。同时增加主键约束</li><li>唯一索引,unique index：要求关键字不能重复。同时增加唯一约束</li><li>普通索引(secondary index)</li><li>普通索引,index：对关键字没有要求</li><li>全文索引,fulltext key：关键字的来源不是所有字段的数据，而是从字段中提取的特别关键词。该类型的索引特殊在：关键字的创建上。是为了解决 like&lsquo;%keyword%&rsquo;这类查询的匹配问题。（mysql的全文索引几乎不用，因为它不支持中文，应该使用<code>sphinx全文索引</code>）。</li></ul></li></ul><pre><code>+    复合索引：如果一个索引通过在多个字段上提取的关键字，称之为复合索引</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 主键索引</span><br><span class="line">ALTER TABLE student ADD PRIMARY KEY  (id);</span><br><span class="line">-- 普通索引</span><br><span class="line">ALTER TABLE student ADD INDEX index_stu (`name`);</span><br><span class="line">-- 删除普通索引</span><br><span class="line">ALTER TABLE student drop INDEX index_stu;</span><br><span class="line">-- 唯一索引</span><br><span class="line">ALTER TABLE student  ADD UNIQUE idx_uq_name (`name`)</span><br><span class="line">-- 全文索引</span><br><span class="line">ALTER TABLE student ADD FULLTEXT idx_ft_name (`name`)</span><br><span class="line">-- 复合索引</span><br><span class="line">ALTER TABLE student ADD INDEX idx_fh ( `name`,school_id)</span><br></pre></td></tr></table></figure><ol start="2"><li>最左匹配原则</li></ol><p>最左匹配原则都是针对联合索引来说的，构建一颗 B+ 树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建 B+ 树。在 InnoDB 中联合索引只有先确定了前一个（左侧的值）后，才能确定下一个值。如果有范围查询的话，那么联合索引中使用范围查询的字段后的索引在该条 SQL 中都不会起作用。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- 定义 a b c 的联合索引</span><br><span class="line">-- a. 生效的例子</span><br><span class="line">-- eg1</span><br><span class="line">select * from t where a=1 and b=1 and c=1;</span><br><span class="line"></span><br><span class="line">-- eg2</span><br><span class="line">select * from t where a=1 and c=1 and b=1;</span><br><span class="line">==经过优化器转换==&gt; </span><br><span class="line">select * from t where a=1 and b=1 and c=1;</span><br><span class="line"></span><br><span class="line">-- eg3</span><br><span class="line">select * from t where a=1 and b=1 and c&gt;1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- b. 未生效的例子</span><br><span class="line">-- eg1</span><br><span class="line">select * from t where a=1 and b&gt;1 and c=1;（只有ab用上索引）</span><br><span class="line"></span><br><span class="line">-- eg2</span><br><span class="line">select * from t where a=1 and c=1;（只有a用上索引）</span><br></pre></td></tr></table></figure><blockquote><p>注：mysql的执行计划和查询的实际执行过程并不完全吻合，所以参数的查询也会经过优化。</p></blockquote><ol start="3"><li>使用OR<br>必须要保证 OR 两端的条件都存在可以用的索引，该查询才可以使用索引。</li></ol><ol start="4"><li>索引覆盖<br>索引拥有的关键字内容，覆盖了查询所需要的全部数据。此时，就不需要在数据区获取数据，仅仅在索引区即可。覆盖就是直接在索引区获取内容，而不需要在数据区获取。explain的输出结果Extra字段为Using index时，能够触发索引覆盖。即查询字段都为索引字段，通过索引直接就可以获取数据，而不需要再查询表。</li></ol><p>使用场景：</p><ul><li>全表count查询优化</li><li>列查询回表优化（建立联合索引（name+sex），<code>select id,name,sex ... where name=&#39;shenjian&#39;</code>）</li><li>分页查询</li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>MySQL 缓存机制就是缓存sql 文本及缓存结果，用KV形式保存再服务器内存中，如果运行相同的sql,服务器直接从缓存中去获取结果，不需要在再去解析、优化、执行sql。如果表修改了（如insert,update,delete,truncate,alter table,drop table或者是drop database 等命令），那么该表的所有索引都不会生效，查询缓存值得相关条目将被清空。对于更新频繁的表，查询缓存并不合适；对于不变的数据以及查询sql大都相似的表，查询缓存会提高很大性能。</p><ol><li>命中条件</li></ol><p>缓存存在于一个hash表中，通过查询SQL，查询数据库，客户端协议等作为key,在判断命中前，mysql不会解析SQL，而是使用SQL去查询缓存，SQL上的任何字符的不同，如空格、注释，都会导致缓存不命中。如果查询有不确定的数据like now(),current_date()，那么查询完成后结果者不会被缓存，包含不确定的数的是不会放置到缓存中。</p><ol start="2"><li>工作流程</li></ol><ul><li>服务器接收SQL，如果涉及表的库有启动缓存，根据SQL及其他条件查找缓存表；</li><li>如果找到了缓存，则直接返回缓存；</li><li>如果没有找到缓存，则执行SQL查询，包括原来的SQL解析，优化等；</li><li>执行完SQL查询结果以后，将SQL查询结果缓存入缓存表。</li></ul><ol start="3"><li>缓存失败</li></ol><p>当某个表正在写入数据，则这个表的缓存（命中缓存，缓存写入等）将会处于失效状态，在Innodb中，如果某个事务修改了这张表，则这个表的缓存在事务提交前都会处于失效状态，在这个事务提交前，这个表的相关查询都无法被缓存。</p><ol start="4"><li>缓存参数配置</li></ol><ul><li>query_cache_type: 是否打开缓存<ul><li>OFF: 关闭</li><li>ON: 总是打开</li><li>DEMAND: 只有明确写了SQL_CACHE的查询才会吸入缓存</li></ul></li><li>query_cache_size: 缓存使用的总内存空间大小,单位是字节,这个值必须是1024的整数倍,否则MySQL实际分配可能跟这个数值不同(感觉这个应该跟文件系统的blcok大小有关)</li><li>query_cache_min_res_unit: 分配内存块时的最小单位大小</li><li>query_cache_limit: MySQL能够缓存的最大结果,如果超出,则增加 Qcache_not_cached的值,并删除查询结果</li><li>query_cache_wlock_invalidate: 如果某个数据表被锁住,是否仍然从缓存中返回数据,默认是OFF,表示仍然可以返回</li></ul><blockquote><p>注：这里的缓存仅当数据表的记录改变时，缓存才会被删除，而不是依靠过期时间的。如果存在不想使用缓存的SQL执行，则可以使用 SQL_NO_CACHE语法</p></blockquote><h3 id="分区分表"><a href="#分区分表" class="headerlink" title="分区分表"></a>分区分表</h3><p>日常开发中经常会遇到大表的情况，所谓的大表是指存储了百万级乃至千万级条记录的表。这样的表过于庞大，导致数据库在查询和插入的时候耗时太长，性能低下，如果涉及联合查询的情况，性能会更加糟糕。分表和表分区的目的就是减少数据库的负担，提高数据库的效率，通常点来讲就是提高表的增删改查效率。</p><ol><li>分区</li></ol><p>分区，partition，分区是将数据分段划分在多个位置存放，可以是同一块磁盘也可以在不同的机器。分区后，表面上还是一张表，但数据散列到多个位置了。app读写的时候操作的还是大表名字，db自动去组织分区的数据。</p><p>MySQL提供4种分区算法：</p><ul><li>取余<ul><li>Key</li><li>hash </li></ul></li><li>条件<ul><li>List</li><li>range</li></ul></li></ul><p>实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">-- 查看是否支持分区</span><br><span class="line">show VARIABLES like &apos;have_partitioning&apos;</span><br><span class="line"></span><br><span class="line">-- 取余：Key</span><br><span class="line">CREATE TABLE partition_1 (</span><br><span class="line">id  int PRIMARY key AUTO_INCREMENT,</span><br><span class="line">title VARCHAR(255)</span><br><span class="line">)</span><br><span class="line">partition by key(id) PARTITIONS 3;</span><br><span class="line"></span><br><span class="line">分区会生成以下三个文件：</span><br><span class="line">partition_1#p#p0.ibd</span><br><span class="line">partition_1#p#p1.ibd</span><br><span class="line">partition_1#p#p2.ibd</span><br><span class="line">分区与存储引擎无关，是MySQL逻辑层完成的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 取余：hash;，按照某个表达式的值进行取余</span><br><span class="line">CREATE TABLE partition_2 (</span><br><span class="line">id int UNSIGNED  AUTO_INCREMENT,</span><br><span class="line">birthday date,</span><br><span class="line">pname VARCHAR(255),</span><br><span class="line">PRIMARY KEY (id, birthday)</span><br><span class="line">)</span><br><span class="line">partition by hash(month(birthday)) PARTITIONS 12;</span><br><span class="line"></span><br><span class="line">-- 条件：List</span><br><span class="line">CREATE TABLE partition_4 (</span><br><span class="line">id int UNSIGNED  AUTO_INCREMENT,</span><br><span class="line">birthday date,</span><br><span class="line">pname VARCHAR(255),</span><br><span class="line">PRIMARY KEY (id, birthday)</span><br><span class="line">)</span><br><span class="line">partition by list(month(birthday)) (</span><br><span class="line">partition spring VALUES IN(3, 4, 5),</span><br><span class="line">partition summer VALUES IN(6, 7, 8),</span><br><span class="line">partition autumn VALUES IN(9, 10, 11),</span><br><span class="line">partition winter VALUES IN(12, 1, 2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 条件：range</span><br><span class="line"></span><br><span class="line">CREATE TABLE partition_5 (</span><br><span class="line">id int UNSIGNED  AUTO_INCREMENT,</span><br><span class="line">birthday date,</span><br><span class="line">pname VARCHAR(255),</span><br><span class="line">PRIMARY KEY (id, birthday)</span><br><span class="line">)</span><br><span class="line">partition by range(year(birthday)) (</span><br><span class="line">partition p_90 VALUES LESS THAN (2000),</span><br><span class="line">partition p_00 VALUES LESS THAN (2010),</span><br><span class="line">partition P_10 VALUES LESS THAN (2020),</span><br><span class="line">partition p_20 VALUES LESS THAN MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>1.2. 其它语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 取余</span><br><span class="line">-- 增加分区数量</span><br><span class="line">Alter TABLE TABLE_NAME add partition partitions N</span><br><span class="line">-- 减少分区数量</span><br><span class="line">Alter TABLE TABLE_NAME COALESCE partition N</span><br><span class="line"></span><br><span class="line">-- 条件</span><br><span class="line">-- 添加分区</span><br><span class="line">Alter TABLE TABLE_NAME add partition (</span><br><span class="line">partition P_10 VALUES LESS THAN (2020)</span><br><span class="line">)</span><br><span class="line">-- 删除</span><br><span class="line">Alter TABLE TABLE_NAME drop partition P_10</span><br><span class="line"></span><br><span class="line">删除条件算法的分区，会导致分区数据丢失。添加分区不会。</span><br></pre></td></tr></table></figure><ol start="2"><li>分表<br>分表是将一个大表按照一定的规则分解成多张具有独立存储空间的实体表，我们可以称为子表，每个表都对应三个文件，MYD数据文件，.MYI索引文件，.frm表结构文件。这些子表可以分布在同一块磁盘上，也可以在不同的机器上。app读写的时候根据事先定义好的规则得到对应的子表名，然后去操作它。分表技术是比较麻烦的，需要手动去创建子表，app服务端读写时候需要计算子表名。采用merge好一些，但也要创建子表和配置子表间的union关系。（需要手动分表）</li></ol><ul><li>水平分表：通过结构相同的N个表存储数据，MySQL提供了一个可以将多个结构相同的myisam表合并到一起的存储引擎mrg_myisam。</li><li>垂直分表：一张表中存在多个字段。这些字段可以分为常用字段和非常用字段，为了提高查表速度，我们可以把这两类字段分开来存储。主要目的，减少每条记录的长度</li></ul><blockquote><p><a href="https://www.cnblogs.com/kerrycode/p/9515200.html" target="_blank" rel="noopener">MySQL如何判别InnoDB表是独立表空间还是共享表空间</a><br><a href="https://blog.csdn.net/qzqanzc/article/details/80418125" target="_blank" rel="noopener">mysql 缓存机制</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MYSQL优化包括设计、功能、架构与高性能SQL几个方面。Mysql优化，一方面是找出系统的瓶颈，提高mysql数据库整体的性能，另外一个方面需要合理的结构设计和参数调整，以提高用户操作响应的速度。同时还要尽可能节省系统资源，以便系统可以提供更大负荷的服务。mysql数据库</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://zws6672.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>UML中关系</title>
    <link href="http://zws6672.top/2021/05/16/tool-uml/"/>
    <id>http://zws6672.top/2021/05/16/tool-uml/</id>
    <published>2021-05-16T05:42:35.000Z</published>
    <updated>2021-05-16T05:44:39.762Z</updated>
    
    <content type="html"><![CDATA[<ol><li>依赖（Dependency）：A类中存在方法形参为B类</li></ol><p>实体之间一个“使用”关系暗示一个实体的规范发生变化后，可能影响依赖于它的其他实例（图D）。更具体地说，它可转换为对不在实例作用域内的一个类或对象的任何类型的引用。其中包括一个局部变量，对通过方法调用而获得的一个对象的引用（如下例所示），或者对一个类的静态方法的引用（同时不存在那个类的一个实例）</p><ol start="2"><li>关联（Association）：A类有成员变量是B类</li></ol><p>实体之间的一个结构化关系表明对象是相互连接的。UML箭头是可选的，它用于指定导航能力。如果没有箭头，暗示是一种双向的导航能力。在Java中，关联（图E）转换为一个实例作用域的变量，就像图E的“Java”区域所展示的代码那样。可为一个关联附加其他修饰符。</p><ul><li>合成/组合（Composition）：A类的成员变量是B类，且必定存在<ul><li>合成（图G）是聚合的一种特殊形式，UML箭头暗示“局部”在“整体”内部的生存期职责。合成也是非共享的。所以，虽然局部不一定要随整体的销毁而被销毁，但整体要么负责保持局部的存活状态，要么负责将其销毁。局部不可与其他整体共享。但是，整体可将所有权转交给另一个对象，后者随即将承担生存期职责。</li></ul></li><li>聚合（Aggregation）：A类通过存在数组之类的结构存放B类<ul><li>聚合（图F）是关联的一种形式，UML箭头代表两个类之间的整体/局部关系。聚合暗示着整体在概念上处于比局部更高的一个级别，而关联暗示两个类在概念上位于相同的级别。聚合也转换成Java中的一个实例作用域变量。</li></ul></li><li>合成与聚合的区别：聚合即A中可能有B对象，B对象不是A的一部分；合成即A中一定有B对象，并且生成A对象的同时一定生成B对象。</li></ul><ol start="3"><li>泛化（Generalization）：A类继承于B类</li></ol><p>泛化（图H）表示一个更泛化的元素和一个更具体的元素之间的关系。泛化是用于对继承进行建模的UML元素。</p><ol start="4"><li>实现（Realization）：A类实现了B接口</li></ol><p>面向对象中表示接口的实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;依赖（Dependency）：A类中存在方法形参为B类&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实体之间一个“使用”关系暗示一个实体的规范发生变化后，可能影响依赖于它的其他实例（图D）。更具体地说，它可转换为对不在实例作用域内的一个类或对象的任何类型的引用。其中包括一个局部</summary>
      
    
    
    
    
    <category term="soft-skills" scheme="http://zws6672.top/tags/soft-skills/"/>
    
  </entry>
  
  <entry>
    <title>了解fmi、ssp与dcp</title>
    <link href="http://zws6672.top/2021/05/16/fmi-ssp-dcp/"/>
    <id>http://zws6672.top/2021/05/16/fmi-ssp-dcp/</id>
    <published>2021-05-16T05:18:20.000Z</published>
    <updated>2021-05-16T06:01:14.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、fmi、ssp与dcp"><a href="#一、fmi、ssp与dcp" class="headerlink" title="一、fmi、ssp与dcp"></a>一、fmi、ssp与dcp</h1><h3 id="FMI"><a href="#FMI" class="headerlink" title="FMI"></a>FMI</h3><ol><li>为什么需要FMI</li></ol><p>仿真软件面临的难题：</p><ul><li>模型是多来源且异构的</li><li>工具之间的接口不统一，难以实现多工具的联合仿真</li><li>封装模型传递过程中无法有效利用已确定的仿真参数和架构信息或数据，需要二次设置参数和重新拖拽连接模型</li><li>数据交互的通信协议和接口不统一</li><li>代表非实时、软实时和硬实时系统之间的软硬件工具的联合仿真通信方法有待完善，简化应用配置工作，降低应用门槛</li></ul><p>仿真工作可以分为系统级以及部件级，系统级相当于制造汽车，而部件级表示制造汽车过程中涉及的架构、零件等设计流程。在这个研发过程中，会使用到不同供应商提供的软件。这些软件接口不一，模型不一致，很难进行协同研发。在这种情况下，FMI应运而生。</p><blockquote><p>FMI标准的诞生来自于欧盟Modelisar项目，最初由Daimler AG发起、组织和领导，有28个欧洲伙伴参与，这包括工具供应商、工业用户和科研机构。Modelisar项目于2008年启动，第一期项目到2011年结束，第一期项目共投入经费超过3千万欧元，制定了FMI1.0标准。2012年，FMI2.0标准的制定纳入到Modelica协会管理下（Modelica协会是Modelica语义制定和维护的非营利组织），并在2014年初推出了FMI2.0的成熟标准。</p></blockquote><ol start="2"><li>FMI的主要设计思想</li></ol><p>FMI为针对功能和性能模型重用的接口标准，通过FMI标准导出的文件是一个压缩包，文件的扩展名为“.fmu”，故称依据FMI标准导出的用于模型重用的文件为FMU文件，即Functional Mock-up Unit。</p><p>FMU的压缩包文件里包含了：</p><ul><li>描述模型接口信息和数据的“.xml”文件（modelDescription.xml）</li><li>实现模型动态行为功能的文件(C代码或二进制文件)</li><li>其他用户希望包含在FMU中的文件和数据</li></ul><p>FMI规范：</p><ul><li>模型重用<ul><li>模型交换（不包含求解模型方程的求解器）</li><li>联合仿真（依据Co-Simulation方法导出，包含求解器）</li></ul></li><li>模型导出加密（知识产权保护）</li></ul><p>2.1 Model Exchange（模型交换）</p><p>此方法导出的FMU文件不包含求解器，其只包括输入/输出接口和描述物理动态行为的微分代数方程、时间、状态和离散事件等信息。FMU的求解使用导入它的工具的求解器，并与其他模型一起求解，由于使用一个求解器，提高了求解的效率和精度，此方法特别适合大规模模型集成的应用情况，同时其求解占用的系统开销很小，也适合嵌入式系统的应用。FMI标准的专家推荐模型集成和重用优选Model Exchange方法。</p><p>2.2  Co-Simulation方法</p><p>Co-Simulation即为联合仿真方法，此方法并不是FMI标准首创，而是在FMI标准的Co-Simulation方法制定之前既已存在。它基于传统的联合仿真方法，并进行了优化和丰富：</p><ul><li>支持主/从架构</li><li>考虑不同能力的仿真工具</li><li>支持简单和复杂的耦合算法：<ul><li>迭代和直接反馈算法</li><li>固定和变化的通信步长</li></ul></li><li>允许(高阶)连续输入的插值</li><li>支持本地和分布式联合仿真方案</li></ul><p>按照使用场景，分为以下三种模式：</p><ul><li>代码导出方式的Co-Simulation（不依赖工具，可独立运行）</li><li>工具耦合方式的Co-Simulation（依赖指定软件，同一平台多线程）</li><li>分布式方式的Co-Simulation（依赖指定软件，分布于不同平台中）</li></ul><p>FMI标准虽然提供了模型交换和联合仿真的功能，但是还无法描述结构相对复杂的模型。</p><ol start="3"><li>文件结构</li></ol><p>3.1 modelDescription.xml</p><p>信息描述文件采用XML格式，其中包含模型的所有变量信息，下表列出了变量信息的属性及其意义。</p><table><thead><tr><th align="left">属性名</th><th align="left">描述信息</th></tr></thead><tbody><tr><td align="left">name</td><td align="left">变量的名字。在一个FMU中，变量名字是一个变量的唯一标识，即在同一个FMU中不允许出现两个名字一样的变量。</td></tr><tr><td align="left">valueReference</td><td align="left"><br>一个变量的操作编号，用于FMU操作函数中对变量的操作。在一个FMU中，其值对于任何一种数据类型(下表中的declaredType)数据是唯一的，即数据类型和 valueReference可以在FMU操作函数中唯一标识一个变量。</td></tr><tr><td align="left">description</td><td align="left">一个可选的信息用于描述变量的作用或其它。<br></td></tr><tr><td align="left">variability</td><td align="left">定义该变量值的可改变性。可以取以下值：<br><br>constant:变量的值是不可改变的；<br>parameter:被看作是模型的参数，变量的值在初始化(初始化函数见下文)之后就不能再修改了；<br>discrete:变量值仅在初始化和触发事件时可以被更改；<br>continues:任何时间都可以修改变量值，但只有当变量的类型为Real时才可用。</td></tr><tr><td align="left">causality</td><td align="left">定义变量与外界交互时出现的形态，当FMU需要与其它模型相关联时才能发挥作用，其可取值如下（默认状态下，其值为internal。）：<br><br>input:表明变量可以从外界获得输入值，用于FMU自身的求解，默认状态下，其初始值为下表中”start”的值；<br>output:为其它FMU提供输入结果，使本FMU的计算结果可以影响到其它模型；<br>internal:FMU的内部变量，在初始化工作结束后提供数据值，不能用于模型间的连接操作，在初始化之前，其值为”start”的值；<br>none:不影响模型运算的变量，用于标记一些环境相关的值，用的不多。<br></td></tr><tr><td align="left">alias</td><td align="left">可选属性。定义变量是否为一个别名变量，其可取值如下（默认值为noAlias）：<br><br>noAlias:表明变量不是一个别名变量；<br>alias:表明变量是一个别名变量，真实值可以通过其进行读写操作；<br>negatedAlias:是一个别名变量，但其值和真实值的符号总是相反。</td></tr><tr><td align="left">declaredType</td><td align="left">变量的类型，FMI1.0  标准提供的变量类型为 Real、Integer、Boolean、String和Enumeration五种，针对各自类型，FMI提供对应的读写函数<br></td></tr><tr><td align="left">start</td><td align="left">变量的初始值，如果一个变量的causality=”input”，则其必须拥有start属性。</td></tr><tr><td align="left">fixed</td><td align="left">用来定义”start”属性的含义，如果fixed=true, start属性值将会被直接初始化到变量的值，否则，会经过迭代计算获得，默认值为true。<br></td></tr></tbody></table><p>3.2 DLL</p><p>执行库文件，以动态链接库的形式(.dll)存在，其中包含FMU求解所需要的所有函数接口，默认采用C语言格式编写，可以提供源码或二进制形式的文件，能够被其它不同平台所调用</p><p>3.3 其它文件</p><p>模型其它相关信息，如图标、文档等，该部分不参与模型的运行，作为辅助信息提供给模型使用者。</p><h3 id="SSP"><a href="#SSP" class="headerlink" title="SSP"></a>SSP</h3><p>SSP（SystemStructure and Parameterization）是一种与工具无关的格式，用于描述、打包和交换系统的结构及其参数化。该标准由一组基于XML格式的文件组成，这些XML使用信号流和参数化的方法描述了一个组件模型网络。该标准的XML描述文件是工具中立的，主要用于不同工具之间被仿真系统的信息交换。</p><p>“*.SPP”压缩包格式：</p><ul><li><code>*.fmu</code>：Functional Mock-up Unit</li><li><code>*.ssm</code>：SystemStructure Parameter Mapping</li><li><code>*.ssv</code>：SystemStructure Parameter Values</li><li><code>*.ssd</code>：SystemStructure Definition</li><li><code>*.ssb</code>：SystemStructure Signal Dictionaries</li></ul><p>SSP标准的主要目的是：</p><ul><li>为组件网络（特别是FMUs）的连接结构定义标准化格式。</li><li>定义一种标准化的方法来存储和应用这些组件的参数。</li><li>所开发的标准/APIs在开发过程的所有阶段都可用（架构定义、集成、仿真、MiL、SiL、HiL中的测试）。</li><li>视作FMI2.0标准的拓展，与FMI在功能上有效互补</li></ul><h3 id="DCP"><a href="#DCP" class="headerlink" title="DCP"></a>DCP</h3><p>DCP（DistributedCo-Simulation Protocol），即分布式联合仿真协议。它是一种应用层通信协议，旨在将模型或实时系统集成到仿真环境中。它支持使用底层传输协议(如UDP、TCP或CAN)交换与仿真相关的配置信息和数据。同时，DCP支持集成来自不同供应商的工具和实时系统。DCP旨在提高基于工作流仿真的效率，并减少系统集成中的调试工作量。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>FMI、SSP、DCP犹如系统仿真技术在复杂系统模型集成和仿真应用时的利器：FMI提供了统一的接口实现模型交换（ME）和联合仿真（CO）两种工作模式；SSP有效补充了基于FMI标准进行模型重用时的参数和架构信息与数据；DCP规范了通信，将FMI应用范围推广到实时应用领域，且实现了V流程下MiL、SiL、HiL模型的连续传递重用，实现了非实时、软实时和硬实时系统的通信联合仿真。</p><h1 id="二、参考资料"><a href="#二、参考资料" class="headerlink" title="二、参考资料"></a>二、参考资料</h1><blockquote><p><a href="https://mp.weixin.qq.com/s/pS7zT4kardJAD8xVjXvXpg" target="_blank" rel="noopener">FMI、SSP、DCP简介</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、fmi、ssp与dcp&quot;&gt;&lt;a href=&quot;#一、fmi、ssp与dcp&quot; class=&quot;headerlink&quot; title=&quot;一、fmi、ssp与dcp&quot;&gt;&lt;/a&gt;一、fmi、ssp与dcp&lt;/h1&gt;&lt;h3 id=&quot;FMI&quot;&gt;&lt;a href=&quot;#FMI&quot; c</summary>
      
    
    
    
    
    <category term="fmi" scheme="http://zws6672.top/tags/fmi/"/>
    
  </entry>
  
  <entry>
    <title>多PC同步hexo</title>
    <link href="http://zws6672.top/2021/05/16/hexo-sync/"/>
    <id>http://zws6672.top/2021/05/16/hexo-sync/</id>
    <published>2021-05-16T05:03:07.000Z</published>
    <updated>2021-05-16T05:05:54.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在不同机器同步hexo"><a href="#在不同机器同步hexo" class="headerlink" title="在不同机器同步hexo"></a>在不同机器同步hexo</h1><p>hexo项目生成的文档占据了主分支，还需要另外一个分支存放源码</p><ol><li><p>Github上新建分支</p></li><li><p>clone指定分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b 指定分支 https://github.com/用户名/仓库.git</span><br></pre></td></tr></table></figure></li><li><p>删除“.git”（这是一个默认隐藏文件）之外的所有文件</p></li><li><p>移动项目文件到这里面，更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;test&quot;</span><br><span class="line">$ git push origin dir</span><br></pre></td></tr></table></figure></li></ol><p>现在，存在两个分支，主分支存放文章，第二分支存放源码</p><p>unable to access ‘<a href="https://github.com/XX/XX.git" target="_blank" rel="noopener">https://github.com/XX/XX.git</a>: OpenSSL SSL_read: Connection was reset, errno 10054</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 关闭证书认证</span><br><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure><p>【hexo】<code>TypeError [ERR_INVALID_ARG_TYPE]: The mode argument must be integer. Received an instance of Object</code></p><ol><li><p>nodejs版本过高，降级即可<br><a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">nvm 包管理器</a></p></li><li><p>切换node版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nvm install 10.16.0</span><br><span class="line">nvm uninstall 10.16.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nvm use 10.16.0//临时版本</span><br><span class="line">nvm alias default 10.16.0//永久版本</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在不同机器同步hexo&quot;&gt;&lt;a href=&quot;#在不同机器同步hexo&quot; class=&quot;headerlink&quot; title=&quot;在不同机器同步hexo&quot;&gt;&lt;/a&gt;在不同机器同步hexo&lt;/h1&gt;&lt;p&gt;hexo项目生成的文档占据了主分支，还需要另外一个分支存放源码&lt;/p</summary>
      
    
    
    
    
    <category term="博客搭建" scheme="http://zws6672.top/tags/博客搭建/"/>
    
  </entry>
  
  <entry>
    <title>基于FMI标准的仿真软件————Daccosim</title>
    <link href="http://zws6672.top/2021/05/15/fmi-daccosim/"/>
    <id>http://zws6672.top/2021/05/15/fmi-daccosim/</id>
    <published>2021-05-15T14:20:52.000Z</published>
    <updated>2021-05-16T05:45:58.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、FMI"><a href="#一、FMI" class="headerlink" title="一、FMI"></a>一、FMI</h1><ol><li>什么是FMI</li></ol><p>FMI代表“ Functional Mock-up Interface ”，是MODELISAR项目中的一项重要开发工作。FMI规范允许任何建模工具生成代表动态系统模型的C代码或二进制文件，然后可以将其无缝集成到另一个建模和仿真环境中。</p><p>共同仿真规范的FMI处理带有内置求解器和仿真工具耦合的模型。规范分为执行部分和模型描述部分（XML模式）。总之，实现任何FMI规范的FMU（功能模拟单元）均由以下组成：</p><ul><li>XML模型描述。</li><li>以二进制和/或源代码格式实现C函数接口。</li><li>资源，例如输入数据。</li><li>模型的图像和文档。</li></ul><p>遵循此标准导出的模型都可以与其他导出的模型进行协同仿真。在协同仿真的情况下，FMU包含使用XML标准格式表示的模型以及一些二进制文件，具体取决于与FMU兼容的平台。这些二进制文件是可由主算法（MA）加载的动态库。 ），并具有MA知道的标准接口。在这种情况下，FMU被视为MA命令的从属组件。MA是一种协调多个FMU（从站）执行的软件，这种协调主要涉及不同FMU模型之间的数据交换及其调度。</p><ol start="2"><li>FMI标准接口，需要包含以下文件：</li></ol><ul><li>模型描述文件 （XML）；</li><li>仿真程序代码（DLL）；</li><li>其他文件（图片、文档等）</li></ul><ol start="3"><li>FMI规范介绍-设计思想</li></ol><ul><li>Model Exchange（模型交换）</li><li>Co-Simulation（联合仿真）</li></ul><ol start="4"><li>FMI导出文件（FMU）</li></ol><ul><li>不包含求解器，只包括输入/输出接口以及与模型相关的信息；</li><li>FMU可以包含大量的变量；</li><li>FMU可用于嵌入式系统（只需很小的开销）；</li><li>多个FMU可以便捷高效的连在一起求解（各组件可以相互依赖，互相“协作”）</li></ul><p>通过遵循统一的FMI规范，输出统一的FMU文件格式，不同的仿真软件可以联合仿真</p><ul><li><a href="https://www.mathworks.com/help/hdlverifier/simulink-cosimulation.html" target="_blank" rel="noopener">Simulink协同仿真</a></li><li><a href="https://bitbucket.org/simulage/daccosim/src/master/" target="_blank" rel="noopener">daccosim源码</a></li></ul><h1 id="二、daccosim"><a href="#二、daccosim" class="headerlink" title="二、daccosim"></a>二、daccosim</h1><p>DACCOSIM NG是一个用于开发和运行由JavaFMI（fmu-wrapper和fmu-builder）支持的协同仿真用例的环境，JavaFMI是使用FMI标准的“协同仿真”部分实现互操作性的工具套件。DACCOSIM NG允许设计和执行协同仿真，从而提供了开发协同仿真图的机制。</p><h3 id="协同仿真图（co-simulation-graphs）"><a href="#协同仿真图（co-simulation-graphs）" class="headerlink" title="协同仿真图（co-simulation graphs）"></a>协同仿真图（co-simulation graphs）</h3><p>协同仿真图由顶点和连接顶点的箭头组成。一旦定义了顶点，就可以建立箭头来定义如何在它们之间交换变量。在协同仿真图中，可以包含不同类型的顶点：</p><ol><li>FMU<br>这种顶点代表了FMU，它保存文件路径，用作输入和输出的变量以及变量和参数的初始值。</li></ol><ol start="2"><li>External inputs/outputs（外部输入/输出）</li></ol><p>这类顶点允许提供固定值作为其他顶点的输入（外部输入）或者存储由输出提供的值（外部输出）。这两种顶点都可以具有多个变量，如外部输入将拥有几个可用于其他顶点的输出。</p><p>一旦定义了协同仿真图，就可以执行以下步骤：</p><ul><li>加载：该过程首先打开定义了协同仿真的文件并将图形加载到内存中，打开该文件并对其进行处理后，还将加载所使用的每个FMU</li><li>协同初始化：在执行了协同初始化过程后，将用户选择用于导出的变量初始值写入输出文件中，以便随后进行分析</li><li>协同执行：在达到模拟停止时间之前，将根据需要多次调用doStep方法</li><li>导出结果：到达停止时间后，通过终止所有FMU并关闭导出文件来完成仿真</li></ul><p>协同仿真的困难之一是：为所有组件设置一致的系统范围内的初始值。Daccosim协同初始化算法由基于FMU连接变量构建的全局依赖有向图开始，它使用用户建立的连接来查找源FMU的输出和宿主FMU的输入之间的外部依存关系。</p><p>关键思想是有向无环图（DAG）的拓扑排序会给出必须初始化的变量顺序，这导致研究如何将通用有向图转换为DAG。 找到的解决方案是建立与循环依赖关系相对应的强连接组件（SCC）图，将每个SCC收缩到单个顶点中的结果图是DAG。我们使用Tarjan的SCC算法（Tarjan，1972） 在许多Modelica工具中）以标识依赖关系图中的每个SCC（以线性时间运行）。 </p><p>遵循在收缩的SCC图上按拓扑排序获得的顺序： </p><ul><li>对于未收缩的顶点，只需传播其值</li><li>对于收缩的顶点（它们对应于循环依赖关系），我们使用迭代算法（称为JNRA（基于雅各布的牛顿-拉夫森算法））解决了初始化问题，该算法受传统牛顿-拉夫森算法的启发，经常被用于电力潮流计算。</li></ul><ol start="3"><li>运算符（Operator）顶点</li></ol><p>共有四个运算符：加法器，乘法器，偏移量和增益。 这些运算符允许使用其他顶点的输出进行计算，从而在要使用的输出中提供结果。 </p><ul><li>加法器和乘法器有两个或多个输入和一个输出</li><li>偏移量只有一个固定值和一个输入之和</li><li>增益定义为一个固定值，该值将乘以给定的输入</li></ul><p>所有这些顶点都可以使用实数，整数和布尔值。</p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>Daccosim文件结构如下：</p><p><img src="/image/co-simulation/Daccosim-NG-Modelica-f4.jpg" alt="Daccosim文件结构"></p><ul><li>simx：这是一个存档文件（zip），其中包含名为fmu的文件夹，以及在协同仿真图中使用的fmu文件以及sim，dng和dsg文件（sim，dng和dsg文件包含不同格式的协同仿真图的表示）<ul><li>sim 文件中包含要在编辑器中显示的可视化图形信息</li><li>dng 中包含以声明性语言显示的图形</li><li>dsg 中包含以json格式定义的序列化图形（协同仿真图的一种表示）</li><li>fmu 文件夹：包含相关的多个FMU文件</li></ul></li><li>dngx：此存档与simx具有相同的结构和内容，但不存在sim和dsg文件，只有dng文件<ul><li>dngx允许创建一个可运行文件，使用声明性语言定义了图形。</li></ul></li></ul><ol><li>fmu 文件</li></ol><p>这是一种ZIP压缩包，包括了模型的资源和文档，通过XML描述了资源的结构和作用。当使用daccosim加载simx时，会解析包含的每个FMU，将它转换为FMU顶点。当软件加载fum文件时，会将之渲染为fmu顶点。</p><p><img src="/image/co-simulation/Daccosim-NG-Modelica-f4.jpg" alt="Daccosim文件结构"></p><p>每次在doStep方法中调用FMU顶点时，它们通常需要消耗大量的系统资源。 因此，执行引擎还准备在分布式环境中运行，从而可以执行大规模的协同仿真方案。<br>归功于抽象机制的使用，执行引擎无需知道每个FMU的实际执行位置。引擎每次与FMU交互时，都会使用抽象接口。如下图所示，一共有三种实现：</p><p>![Daccosim文件结构](/image/co-simulation/Daccosim-NG-Modelica-    1.jpg)</p><p>Daccosim-NG-Modelica-f5.jpg</p><ul><li>FMULocal：使用文件系统中的FMU文件</li><li>FMUStub：使用与Java消息服务（JMS）的连接来与正在远程执行的FMU进行交互，源码中实现了FMUJMS接口，用于实现服务</li><li>FMUSoul：FMU在远程计算机中的表示</li></ul><p>在上图中，示例展示了如何在运行分布式仿真的机器之间通信。在此示例中，有三台计算机。 在第一个实例中，Daccosim内核的一个实例负责协调分布式执行。 此实例的执行引擎使用FMU接口与要协调的三个FMU进行通信。 其中，两个正在远程执行，一个在本地执行。 但是，由于引擎仅取决于接口，因此类似于执行位置等详细信息对其执行过程来说并不重要。<br>每当引擎发出命令时，FMUStub都会与FMUSoul通信以执行命令，将答案提供给引擎。尽管未显示，但通信是通过JMS进行的。 JMS的使用为设计不同的分发体系结构提供了灵活性，以支持大规模的协同仿真。</p><ol start="2"><li>dng文件（声明式语言）</li></ol><p>Daccosim NG中实现的声明性语言允许用户在文本编辑器上定义一个协同仿真图或通过程序自动生成它。为此，已经设计了一种领域特定的语言来简单地定义一个协同仿真图。该语言非常简单并且易于理解。其目的是创建无法在GUI中建模的非常宽的图，其中有数百个相互连接的顶点交换成千上万的变量。此功能允许预处理工具开发兼容的模型，以便在DaccosimNG中执行。</p><p>声明式语言实例如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 2021-05-08T03:33:24.918Z</span><br><span class="line">// Generated with Daccosim NG %%VERSION%%</span><br><span class="line"></span><br><span class="line">// 格式：FMU ID 文件相对路径 staitc？</span><br><span class="line">FMU equation1 &quot;fmu/equation1win3264.fmu&quot;</span><br><span class="line">// 格式：Output/Input FMU-ID 变量ID 变量类型 变量可变性</span><br><span class="line">Output equation1 x2 Real continuous</span><br><span class="line">Input equation1 x1 Real continuous</span><br><span class="line"></span><br><span class="line">FMU equation2 &quot;fmu/equation2win3264.fmu&quot;</span><br><span class="line">Output equation2 x1 Real continuous</span><br><span class="line">Input equation2 x2 Real continuous</span><br><span class="line"></span><br><span class="line">// 描述要连接的输入、输出</span><br><span class="line">Connection equation1.x2 equation2.x2</span><br><span class="line">Connection equation2.x1 equation1.x1</span><br><span class="line"></span><br><span class="line">Export ; . 2.0E-4</span><br><span class="line">Log equation1.x1 equation1.x2 equation2.x1 equation2.x2</span><br><span class="line">NewtonRaphsonInitializer 20 1.0E-5</span><br><span class="line">// 步长方法</span><br><span class="line">ConstantStepper 1.0</span><br><span class="line">// 仿真起始和结束时间</span><br><span class="line">Simulation 0.0 0.0</span><br><span class="line"></span><br><span class="line">// pipeline 管道配置：管道配置可以合并到dng文件中。在这种情况下，语法由＆和@之类的链接器组成。 ＆链接器表示＆两侧的FMU在同一阶段并行执行。 @链接器指示两侧的FMU在不同阶段执行</span><br><span class="line">Pipeline equation1&amp;equation2</span><br></pre></td></tr></table></figure><p>这个例子来自于<code>equationsPair.simx</code>，该文件实际是压缩文件，解压后就可打开后缀为”.dng”的文件。</p><ol start="3"><li>dsg 文件（DaccosimGraph）</li></ol><p>dsg 中包含以json格式定义的序列化图形（协同仿真图的一种表示）</p><p>相关示例如下，来自于<code>equationsPair.simx</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;settings&quot;: &#123;</span><br><span class="line">&quot;coInitialization&quot;: &#123;</span><br><span class="line">&quot;method&quot;: &quot;NewtonRaphson&quot;,</span><br><span class="line">&quot;residualsTolerance&quot;: 1.0E-5,</span><br><span class="line">&quot;maxIterations&quot;: 20</span><br><span class="line">&#125;,</span><br><span class="line">&quot;startTime&quot;: 0.0,</span><br><span class="line">&quot;stopTime&quot;: 0.0,</span><br><span class="line">&quot;pipeline&quot;: &quot;equation1\u0026equation2&quot;,</span><br><span class="line">&quot;stepper&quot;: &#123;</span><br><span class="line">&quot;method&quot;: &quot;ConstantStep&quot;,</span><br><span class="line">&quot;order&quot;: 3,</span><br><span class="line">&quot;stepSize&quot;: 1.0,</span><br><span class="line">&quot;safetyFactor&quot;: 0.9,</span><br><span class="line">&quot;stepperVariables&quot;: &#123;&#125;,</span><br><span class="line">&quot;transmitDerivatives&quot;: false</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;nodes&quot;: [&#123;</span><br><span class="line">&quot;CLASSNAME&quot;: &quot;eu.simulage.daccosim.view.FMU&quot;,</span><br><span class="line">&quot;INSTANCE&quot;: &#123;</span><br><span class="line">&quot;path&quot;: &quot;fmu/equation1win3264.fmu&quot;,</span><br><span class="line">&quot;beforeInitValues&quot;: [],</span><br><span class="line">&quot;inInitValues&quot;: [],</span><br><span class="line">&quot;flowVariables&quot;: [],</span><br><span class="line">&quot;static_&quot;: false,</span><br><span class="line">&quot;id&quot;: &quot;equation1&quot;,</span><br><span class="line">&quot;inputs&quot;: [&#123;</span><br><span class="line">&quot;id&quot;: &quot;x1&quot;,</span><br><span class="line">&quot;type&quot;: &quot;Real&quot;,</span><br><span class="line">&quot;value&quot;: 0.0,</span><br><span class="line">&quot;variability&quot;: &quot;continuous&quot;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;outputs&quot;: [&#123;</span><br><span class="line">&quot;id&quot;: &quot;x2&quot;,</span><br><span class="line">&quot;type&quot;: &quot;Real&quot;,</span><br><span class="line">&quot;value&quot;: 0.0,</span><br><span class="line">&quot;variability&quot;: &quot;continuous&quot;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;variables&quot;: []</span><br><span class="line">&#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;CLASSNAME&quot;: &quot;eu.simulage.daccosim.view.FMU&quot;,</span><br><span class="line">&quot;INSTANCE&quot;: &#123;</span><br><span class="line">&quot;path&quot;: &quot;fmu/equation2win3264.fmu&quot;,</span><br><span class="line">&quot;beforeInitValues&quot;: [],</span><br><span class="line">&quot;inInitValues&quot;: [],</span><br><span class="line">&quot;flowVariables&quot;: [],</span><br><span class="line">&quot;static_&quot;: false,</span><br><span class="line">&quot;id&quot;: &quot;equation2&quot;,</span><br><span class="line">&quot;inputs&quot;: [&#123;</span><br><span class="line">&quot;id&quot;: &quot;x2&quot;,</span><br><span class="line">&quot;type&quot;: &quot;Real&quot;,</span><br><span class="line">&quot;value&quot;: 0.0,</span><br><span class="line">&quot;variability&quot;: &quot;continuous&quot;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;outputs&quot;: [&#123;</span><br><span class="line">&quot;id&quot;: &quot;x1&quot;,</span><br><span class="line">&quot;type&quot;: &quot;Real&quot;,</span><br><span class="line">&quot;value&quot;: 0.0,</span><br><span class="line">&quot;variability&quot;: &quot;continuous&quot;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;variables&quot;: []</span><br><span class="line">&#125;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;arrows&quot;: [&#123;</span><br><span class="line">&quot;from&quot;: &quot;equation1.x2&quot;,</span><br><span class="line">&quot;to&quot;: &quot;equation2.x2&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;from&quot;: &quot;equation2.x1&quot;,</span><br><span class="line">&quot;to&quot;: &quot;equation1.x1&quot;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;export&quot;: &#123;</span><br><span class="line">&quot;cellSeparator&quot;: &quot;;&quot;,</span><br><span class="line">&quot;decimalSeparator&quot;: &quot;.&quot;,</span><br><span class="line">&quot;prefix&quot;: &quot;equationsPair&quot;,</span><br><span class="line">&quot;variables&quot;: [&quot;equation1.x1&quot;, &quot;equation1.x2&quot;, &quot;equation2.x1&quot;, &quot;equation2.x2&quot;],</span><br><span class="line">&quot;folder&quot;: &quot;.&quot;,</span><br><span class="line">&quot;interpolationInterval&quot;: 2.0E-4</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Matryoshka-FMU"><a href="#Matryoshka-FMU" class="headerlink" title="Matryoshka FMU"></a>Matryoshka FMU</h3><ol><li>Matryoshka FMU 模块</li></ol><p>与FMI 2.0标准兼容的FMU。它封装了DACCOSIM（我们的分布式并行并行主体系结构）及其控制的FMU。 Matryoshka 自动调整其内部时间步长，以确保在由外部FMU兼容模拟器控制下所需的精度。使用的Java FMI工具和DACCOSIM中间件构建，应用于现实生活中的分布式能源系统场景。对于在Dymola中运行的仿真Modelica系统，在保持性能仿真准确性并增强其集成能力的同时，可将计算性能提高250％。Matryoshka FMU 的目标是将 DACCOSIM 协同仿真封装到FMU中，FMU包含一个独立的求解器，可以离开Daccosim这个软件进行求解。</p><ol start="2"><li>DACCOSIM软件</li></ol><p>daccosim的组成：</p><ul><li>简单易用的GUI界面</li><li>并行和分布式的执行架构</li></ul><p>daccosim的局限性：</p><ul><li>仅支持符合FMI 2.0的协同仿真标准的FMU</li><li>不能集成到可导入FMU的特定领域工具中</li></ul><p>为了突破这个局限性，可以使用以下两个方式：</p><ul><li>为DACCOSIM设计特定的控制API以满足这些需求</li><li>将其全部封装到Matryoshka FMU中（可以满足其中的更多要求）<ul><li>FMU可以导入到任何FMI兼容的仿真工具或平台中。这开辟了新的使用场景，因为其中一些工具可能会很好地处理DACCOSIM无法直接交互的非FMI组件</li><li>DACCOSIM的优势多线程、步长控制等解决方案可帮助传统的单线程仿真工具更快地仿真更大的模型。对于很少有并行求解器的域，这特别有意义</li><li>在Matryoshka中，借助DACCOSIM 通用的协同初始化算法，可以完成复杂图形的初始化</li><li>复杂的仿真图可以直接重用，无需重写也可以保护知识产权</li><li>可以对协同仿真过程进行微调：当求解器通常仅对整个模型使用一个精度目标时，DACCOSIM允许用户为每个FMU的每个输出和内部变量定义不同的公差值</li></ul></li></ul><ol start="3"><li>JavaFMI工具包</li></ol><p>java.fmi 致力于生成和执行FMU。JavaFMI是一个软件项目，该工具包允许根据FMI-CS（FMI CO-Simulation） 1.0和2.0规范向Java导入或从Java导出 功能模型单元（FMU）。该项目由SIANI3大学研究所开发，许可证为LGPL。该项目的主要贡献者是EDF Lab，EIFER和Cen-traleSupélec。该项目由两个主要工具组成：</p><p>3.1 包装器（Wrapper）</p><p>FMI包装器允许将FMU导入到支持主算法的Java应用程序。它提供两种类型的接口：</p><ul><li>模拟（简化接口）接口：提供了对FMU的非常简化的访问，用户无需了解FMI标准，因为它提供了相关方法（init、doStep、terminate,、read、write variable、getSimulationTime,、is-Terminated 以及reset）</li><li>访问（完整接口）接口：提供完整接口，需要了解FMI标准，可以进行更细粒度的调整</li></ul><p>3.2 构建器(Builder)</p><p>FMI构建器允许基于Java应用程序或可以由简单Java代码控制的任何程序创建FMU。也就是说，任何Java模拟都可以导出到FMU。该工具提供了一种自动化解决方案来创建FMU，该FMU涵盖了动态库的开发、模型描述文件的生成以及所需资源的打包。</p><p>构建器提供了将Java仿真转换为FMU的框架，需要扩展 FmiSimulation 类，其中至少应实现以下方法：</p><ul><li>define方法：返回一个模型，包含了要在 modelDescription.xml文件中呈现的信息</li><li>init方法：在FMU的实例化过程中调用它，该方法需要注册所有输入和输出变量以及对应的getter和/或setter方法，以便框架以后可以在初始化和仿真阶段获取并设置FMU变量</li><li>doStep方法：它根据给定的步长推进仿真</li><li>reset方法：它将模拟重置为其初始状态</li><li>terminate方法：如果需要的话，应填写终止码</li></ul><p>一旦实现了这些方法，FmiSimulation类将打包到JAR（Java ARchive）文件中，并由构建器进行处理，以便创建FMU。生成器将创建一个FMU文件，其中包含：</p><ul><li>binaries 文件夹：dll 以及 so</li><li>modelDescription.xml文件<ul><li>resources文件夹：</li><li>JAR文件（在daccosim中是Matryoshka.jar）</li><li>其他FMU资源（由用户定义）</li></ul></li></ul><h3 id="daccosim-实例"><a href="#daccosim-实例" class="headerlink" title="daccosim 实例"></a>daccosim 实例</h3><p><a href="https://bitbucket.org/simulage/daccosim/downloads/" target="_blank" rel="noopener">下载daccosim 实例</a> ： daccosim-use-cases-windows-20201212.zip。其中，例子“1-coinit-only/1-equationsPair”就是以下两条算式：</p><ul><li>2<em>X1^X1+5</em>X2=42</li><li>X1-6*X2=4</li></ul><p>每条算式是一个顶点，通过协同合作，两个未知数由零开始递增，最终获得一个近似值。</p><p>Equation1.x2取决于Equation2.x1，而Equation2.x2取决于Equation1。 二者形成一个代数环路，其中对 Equation1.x1的修改会影响Equation1.x2，而对Equation2.x2的修改会影响Equation2.x1。 协同仿真程序将计算该图（为所有变量提供一致的初始值），程序将检测到一个SCC，并且在多次迭代后，x1和x2将达到以下值（x1 = 4.56，x2 = 0.09）。</p><h1 id="三、参考文章"><a href="#三、参考文章" class="headerlink" title="三、参考文章"></a>三、参考文章</h1><blockquote><p><a href="https://www.researchgate.net/publication/317015220_Experimenting_with_Matryoshka_Co-Simulation_Building_Parallel_and_Hierarchical_FMUs" target="_blank" rel="noopener">Experimenting with Matryoshka Co-Simulation: Building Parallel and Hierarchical FMUs</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、FMI&quot;&gt;&lt;a href=&quot;#一、FMI&quot; class=&quot;headerlink&quot; title=&quot;一、FMI&quot;&gt;&lt;/a&gt;一、FMI&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;什么是FMI&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;FMI代表“ Functional Mock-up Inter</summary>
      
    
    
    
    
    <category term="fmi" scheme="http://zws6672.top/tags/fmi/"/>
    
  </entry>
  
  <entry>
    <title>springboot（一）入门</title>
    <link href="http://zws6672.top/2021/05/15/springboot-1/"/>
    <id>http://zws6672.top/2021/05/15/springboot-1/</id>
    <published>2021-05-15T14:07:01.486Z</published>
    <updated>2020-10-12T13:40:29.127Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-SpringBoot-快速入门"><a href="#1-SpringBoot-快速入门" class="headerlink" title="1. SpringBoot 快速入门"></a>1. SpringBoot 快速入门</h3><h5 id="1-1-什么是-SpringBoot"><a href="#1-1-什么是-SpringBoot" class="headerlink" title="1.1 什么是 SpringBoot"></a>1.1 什么是 SpringBoot</h5><p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。</p><blockquote><p>Spring 诞生时是 Java 企业版（Java Enterprise Edition，JEE，也称 J2EE）的<br>轻量级代替品。无需开发重量级的 Enterprise JavaBean（EJB），Spring 为企业级<br>Java 开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java 对象（Plain Old Java Object，POJO）实现了 EJB 的功能。<br>虽然 Spring 的组件代码是轻量级的，但它的配置却是重量级的。</p></blockquote><p><strong><em>Spring配置 发展三阶段</em></strong></p><p>第一阶段：xml配置<br>在Spring 1.x时代，使用Spring开发满眼都是xml配置的Bean，随着项目的扩大，我们需要把xml配置文件放到不同的配置文件里，那时需要频繁的在开发的类和配置文件之间进行切换</p><p>第二阶段：注解配置<br>在Spring 2.x 时代，随着JDK1.5带来的注解支持，Spring提供了声明Bean的注解（例如@Component、@Service），大大减少了配置量。主要使用的方式是应用的基本配置（如数据库配置）用xml，业务配置用注解</p><p>第三阶段：java配置<br>Spring 3.0 引入了基于 Java 的配置能力，这是一种类型安全的可重构配置方式，可以代替 XML。我们目前刚好处于这个时代，Spring4.x和Spring Boot都推荐使用Java配置。</p><p><code>Spring Boot</code> 四个核心</p><ul><li>自动配置：针对很多Spring应用程序常见的应用功能，Spring Boot能自动提供相关配置</li><li>起步依赖：告诉Spring Boot需要什么功能，它就能引入需要的库。</li><li>命令行界面：这是Spring Boot的可选特性，借此你只需写代码就能完成完整的应用程序，无需传统项目构建。</li><li>执行器：让你能够深入运行中的Spring Boot应用程序，一套究竟。</li></ul><p><code>Spring Boot</code>比起<code>Spring</code>，最大的好处是易于使用，是开发微服务、小项目的利器。</p><h5 id="1-2-使用IDEA构建项目"><a href="#1-2-使用IDEA构建项目" class="headerlink" title="1.2 使用IDEA构建项目"></a>1.2 使用IDEA构建项目</h5><p>使用IDEA的好处是可以通过勾选配置组件，不用担心相关包以及版本冲突，</p><p><strong><em>环境</em></strong></p><ul><li>JDK8</li><li>IDEA 20019</li><li>SpringBoot 2.2.3</li></ul><p><strong><em>使用IDEA配置</em></strong></p><p><img src="/iamge/springboot/init.png" alt="springboot项目建立"><br><img src="/iamge/springboot/text1.png" alt="springboot 文件"></p><p><strong><em>项目结构</em></strong></p><p>项目里面基本没有代码，除了几个空目录外，还包含如下几样东西。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line">  +- springboot</span><br><span class="line">    +- src</span><br><span class="line">+- main</span><br><span class="line">|  +- java（存放代码）</span><br><span class="line">|  |</span><br><span class="line">|  |</span><br><span class="line">|  +- resources</span><br><span class="line">|  |  +- static（静态文件 图标/图片）</span><br><span class="line">|  |  +- templates（模板 HTML文件）</span><br><span class="line">|  |  +- application.yml  配置属性</span><br><span class="line">|  |  +- application.profiles  配置属性</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">+- test（测试代码）</span><br><span class="line">+- pom.xml Maven的构建说明文件</span><br></pre></td></tr></table></figure><p><strong><em>pom 配置</em></strong></p><ul><li>spring-boot-starter-parent（父级依赖）：是一个特殊的首发，它用来提供相关的Maven默认依赖，使用它之后，常用的包依赖可以省去版本标签。</li><li>spring-boot-starter-xx（起步依赖）：Spring Boot提供了很多“开箱即用”的依赖模块，都是以spring-boot-starter-xx作为命名的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">// 1. 配置父级依赖</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.3.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.springboot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;example&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">    &lt;name&gt;example&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot（20200816）&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">// 2. 配置启动依赖</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">// 3. 配置其它依赖</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;reactor-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p><strong><em>Application.yml 配置</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8888</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/toolweb?serverTimezone=UTC&amp;useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br></pre></td></tr></table></figure><p><strong><em>启动器</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.springboot.demo;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">// 该注解表示这是一个 SpringBoot启动类</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ExampleApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ExampleApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>控制器</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String index() &#123;</span><br><span class="line">        return &quot;Hello World&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>测试</em></strong></p><p>启动主程序，打开浏览器访问<code>http://localhost:8888/hello</code>，可以看到页面输出Hello World</p><h5 id="YML"><a href="#YML" class="headerlink" title="YML"></a>YML</h5><p>YAML (YAML Ain’t a Markup Language)YAML不是一种标记语言，通常以.yml为后缀的文件，是一种直观的能够被电脑识别的数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，一种专门用来写配置文件的语言。可用于如： Java，C/C++, Ruby, Python, Perl, C#, PHP等。</p><p><strong><em>语法</em></strong></p><ol><li>约定格式</li></ol><ul><li>k: v 表示键值对关系，冒号后面必须有一个空格</li><li>使用空格的缩进表示层级关系，空格数目不重要，只要是左对齐的一列数据，都是同一个层级的</li><li>大小写敏感</li><li>缩进时不允许使用Tab键，只允许使用空格。</li><li>松散表示，java中对于驼峰命名法，可用原名或使用-代替驼峰，如java中的lastName属性,在yml中使用lastName或 last-name都可正确映射。</li></ul><ol start="2"><li>键值对的书写</li></ol><ul><li><p>字面值</p><ul><li>字符串默认不用加上单引号或者双绰号；</li><li>“”: 双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思<ul><li>“a\nb”===&gt; a换行b</li></ul></li><li>‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</li></ul></li><li><p>日期</p><ul><li>date: 2020/08/15</li></ul></li><li><p>对象(属性和值)、Map(键值对)</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">people:</span><br><span class="line">name: ws</span><br><span class="line">age: 1000</span><br><span class="line">people: &#123;name:ws,age: 1000&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数组、list、set</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pets:</span><br><span class="line">- dog</span><br><span class="line">- pig</span><br><span class="line">- cat</span><br><span class="line">pets: [dog,pig,cat]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数组对象、list对象、set对象</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">peoples:</span><br><span class="line">   - name: ws</span><br><span class="line">     age: 22</span><br><span class="line">   - name: lisi</span><br><span class="line">     age: 1000</span><br><span class="line">   - &#123;name: wangwu,age: 18&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="3"><li>文档块</li></ol><ul><li>对于生产、测试环境等可以使用不同的配置，可以写在一个文件中，使用<code>---</code>隔开<ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">active: test #激活</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  profiles: dev #生产环境</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8084</span><br><span class="line">spring:</span><br><span class="line">  profiles: test  #测试环境</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-SpringBoot-WEB"><a href="#2-SpringBoot-WEB" class="headerlink" title="2. SpringBoot WEB"></a>2. SpringBoot WEB</h3><p>前面，我们是使用IDEA快速搭建了一个 RESTful Service 的微服务项目，现在要快速配置一个WEB界面</p><h5 id="2-1-基础"><a href="#2-1-基础" class="headerlink" title="2.1 基础"></a>2.1 基础</h5><p><strong><em>约定配置</em></strong></p><p>Spring Boot默认提供静态资源目录位置需置于classpath下，目录名需符合如下规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/static</span><br><span class="line">/public</span><br><span class="line">/resources</span><br><span class="line">/META-INF/resources</span><br></pre></td></tr></table></figure><p><strong><em>模板引擎</em></strong></p><p><code>@RestController</code>返回的是JSON格式的数据，如果需要渲染页面，可以通过模板引擎实现。</p><p>Spring Boot提供了默认配置的模板引擎主要有以下几种：</p><ul><li><code>Thymeleaf</code></li><li>FreeMarker</li><li>Velocity</li><li>Groovy</li><li>Mustache</li></ul><blockquote><p>Spring Boot建议使用这些模板引擎，避免使用JSP，若一定要使用JSP将无法实现Spring Boot的多种特性</p></blockquote><h5 id="2-2-Thymeleaf"><a href="#2-2-Thymeleaf" class="headerlink" title="2.2 Thymeleaf"></a>2.2 Thymeleaf</h5><p>Thymeleaf是面向Web和独立环境的现代服务器端Java模板引擎，能够处理HTML，XML，JavaScript，CSS甚至纯文本。<br>Thymeleaf的主要目标是提供一个优雅和高度可维护的创建模板的方式。为了实现这一点，它建立在自然模板的概念上，将其逻辑注入到模板文件中，不会影响模板被用作设计原型。这改善了设计的沟通，弥合了设计和开发团队之间的差距。<br>Thymeleaf也从一开始就设计了Web标准 (特别是HTML5)允许您创建完全验证的模板，</p><p><strong><em>引用</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong><em>application.yml 配置</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring: </span><br><span class="line">  thymeleaf:</span><br><span class="line">    prefix: classpath:/templates/ # 前缀</span><br><span class="line">    suffix: .html #后缀</span><br><span class="line">    encoding: UTF-8 # 编码</span><br><span class="line">    mode: HTML5 # 模板模式</span><br><span class="line">    cache: false # 关闭模板缓存，实时更新</span><br><span class="line">    content-type: text/html</span><br></pre></td></tr></table></figure><p><strong><em>示例</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 控制器</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class IndexController &#123;</span><br><span class="line">    @RequestMapping(&quot;/&quot;)</span><br><span class="line">    public String index(ModelMap map) &#123;</span><br><span class="line">        // 加入一个属性，用来在模板中读取</span><br><span class="line">        map.addAttribute(&quot;host&quot;, &quot;https://www.cnblogs.com&quot;);</span><br><span class="line">        // 对应src/main/resources/templates/index.html</span><br><span class="line">        return &quot;index&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">// index.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head lang=&quot;en&quot;&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1 th:text=&quot;$&#123;host&#125;&quot;&gt;Hello World&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong><em>Thymeleaf IDEA 中语法无法识别</em></strong></p><p>在<code>&lt;html&gt;</code> 中添加 <code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code></p><blockquote><p>Thymeleaf主要以属性的方式加入到html标签中，浏览器在解析html时，当检查到没有的属性时候会忽略，所以Thymeleaf的模板可以通过浏览器直接打开展现，这样非常有利于前后端的分离。</p></blockquote><p><strong>* Error resolving template [index], template might not exist or might not be accessible by any of the configured Template Resolvers*</strong></p><p>可能的原因如下：</p><ul><li>路径配置错误，正确的配置 <code>prefix: classpath:/templates/ # 前缀</code></li><li>注解不是<code>@RestController</code>, 而是<code>@Controller</code></li><li>返回值是<code>&quot;/index&quot;</code>,去掉斜杆</li></ul><h3 id="3-RESTful-API与单元测试"><a href="#3-RESTful-API与单元测试" class="headerlink" title="3. RESTful API与单元测试"></a>3. RESTful API与单元测试</h3><p><strong><em>RESTful</em></strong></p><p>基于 RESTful 原则设计的 API 就是RESTful API。该原则如下：</p><ul><li>一个URI代表一种资源</li><li>客户端和服务器之间，传递这种资源的某种表现层</li><li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</li></ul><h5 id="3-1-RESTful-API-实例"><a href="#3-1-RESTful-API-实例" class="headerlink" title="3.1 RESTful API 实例"></a>3.1 RESTful API 实例</h5><p>RESTful API具体设计如下：<br><img src="/image/springboot/restful.png" alt="RESTful API"></p><p><strong><em>实体</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123; </span><br><span class="line"> </span><br><span class="line">    private Long id; </span><br><span class="line">    private String name; </span><br><span class="line">    private Integer age;  </span><br><span class="line">    // 省略setter和getter </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>操作接口</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@RestController </span><br><span class="line">@RequestMapping(value=&quot;/users&quot;)     // 通过这里配置使下面的映射都在/users下 </span><br><span class="line">public class UserController &#123; </span><br><span class="line"> </span><br><span class="line">    // 创建线程安全的Map </span><br><span class="line">    static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;()); </span><br><span class="line"> </span><br><span class="line">    @RequestMapping(value=&quot;/&quot;, method=RequestMethod.GET) </span><br><span class="line">    public List&lt;User&gt; getUserList() &#123; </span><br><span class="line">        // 处理&quot;/users/&quot;的GET请求，用来获取用户列表 </span><br><span class="line">        // 还可以通过@RequestParam从页面中传递参数来进行查询条件或者翻页信息的传递 </span><br><span class="line">        List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values()); </span><br><span class="line">        return r; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    @RequestMapping(value=&quot;/&quot;, method=RequestMethod.POST) </span><br><span class="line">    public String postUser(@ModelAttribute User user) &#123; </span><br><span class="line">        // 处理&quot;/users/&quot;的POST请求，用来创建User </span><br><span class="line">        // 除了@ModelAttribute绑定参数之外，还可以通过@RequestParam从页面中传递参数 </span><br><span class="line">        users.put(user.getId(), user); </span><br><span class="line">        return &quot;success&quot;; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    @RequestMapping(value=&quot;/&#123;id&#125;&quot;, method=RequestMethod.GET) </span><br><span class="line">    public User getUser(@PathVariable Long id) &#123; </span><br><span class="line">        // 处理&quot;/users/&#123;id&#125;&quot;的GET请求，用来获取url中id值的User信息 </span><br><span class="line">        // url中的id可通过@PathVariable绑定到函数的参数中 </span><br><span class="line">        return users.get(id); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    @RequestMapping(value=&quot;/&#123;id&#125;&quot;, method=RequestMethod.PUT) </span><br><span class="line">    public String putUser(@PathVariable Long id, @ModelAttribute User user) &#123; </span><br><span class="line">        // 处理&quot;/users/&#123;id&#125;&quot;的PUT请求，用来更新User信息 </span><br><span class="line">        User u = users.get(id); </span><br><span class="line">        u.setName(user.getName()); </span><br><span class="line">        u.setAge(user.getAge()); </span><br><span class="line">        users.put(id, u); </span><br><span class="line">        return &quot;success&quot;; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    @RequestMapping(value=&quot;/&#123;id&#125;&quot;, method=RequestMethod.DELETE) </span><br><span class="line">    public String deleteUser(@PathVariable Long id) &#123; </span><br><span class="line">        // 处理&quot;/users/&#123;id&#125;&quot;的DELETE请求，用来删除User </span><br><span class="line">        users.remove(id); </span><br><span class="line">        return &quot;success&quot;; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Representational State Transfer: REST</p></blockquote><p><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-SpringBoot-快速入门&quot;&gt;&lt;a href=&quot;#1-SpringBoot-快速入门&quot; class=&quot;headerlink&quot; title=&quot;1. SpringBoot 快速入门&quot;&gt;&lt;/a&gt;1. SpringBoot 快速入门&lt;/h3&gt;&lt;h5 id=&quot;1-1</summary>
      
    
    
    
    
    <category term="javaweb" scheme="http://zws6672.top/tags/javaweb/"/>
    
  </entry>
  
  <entry>
    <title>后端编译与优化</title>
    <link href="http://zws6672.top/2021/05/13/jdk-backend-compile/"/>
    <id>http://zws6672.top/2021/05/13/jdk-backend-compile/</id>
    <published>2021-05-13T15:14:12.000Z</published>
    <updated>2021-05-13T15:14:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>字节码是Java程序的中间态，可以在不同的环境中运行。在何种状态下把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码，它都可以视为整个编译过程的后端。</p><p>无论是提前编译器抑或即时编译器，都不是Java虚拟机必需的组成部分，《Java虚拟机规范》中从来没有规定过虚拟机内部必须要包含这些编译器，更没有限定或指导这些编译器应该如何去实现。</p><h1 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h1><p>目前主流的两款商用Java虚拟机（HotSpot、OpenJ9）里，Java程序最初都是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为“热点代码”（Hot Spot Code），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器被称为即时编译器。</p><ol><li>解释器与编译器</li></ol><p>目前主流的商用Java虚拟机，譬如HotSpot、OpenJ9等，内部都同时包含解释器与编译器，但也不是所有的Java虚拟机都是并存架构。</p><p>解释器</p><ul><li>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行</li><li>可以使用解释执行节约内存</li></ul><p>编译器</p><ul><li>当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率</li><li>可以使用编译执行来提升效率</li></ul><p>并行架构下，编译器会根据概率选择一些不能保证所有情况都正确，但大多数时候都能提升运行速度的优化手段；当激进优化的假设不成立，如加载了新类以后，类型继承结构出现变化、出现“罕见陷阱”（Uncommon Trap）时可以通过逆优化（Deoptimization）退回到解释状态继续执行。因此在整个Java虚拟机执行架构里，解释器与编译器经常是相辅相成地配合工作。</p><p><img src="/image/jdk/jdk-jsby.png" alt="解释器与编译器转换"></p><p>HotSpot虚拟机中内置了两个（或三个）即时编译器，其中有两个编译器存在已久，分别被称为“客户端编译器”（Client Compiler）和“服务端编译器”（Server Compiler），或者简称为C1编译器和C2编译器（部分资料和JDK源码中C2也叫Opto编译器），第三个是在JDK 10时才出现的、长期目标是代替C2的Graal编译器。</p><p>在分层编译（Tiered Compilation）的工作模式出现以前，HotSpot虚拟机通常是采用解释器与其中一个编译器直接搭配的方式工作，程序使用哪个编译器，只取决于虚拟机运行的模式，HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用“-client”或“-server”参数去强制指定虚拟机运行在客户端模式还是服务端模式。</p><blockquote><p>解释器与编译器搭配使用的方式在虚拟机中被称为“混合模式”（Mixed Mode），用户也可以使用参数“-Xint”强制虚拟机运行于“解释模式”（Interpreted Mode），这时候编译器完全不介入工作，全部代码都使用解释方式执行。<br>可以使用参数“-Xcomp”强制虚拟机运行于“编译模式”（Compiled Mode），这时候将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。<br>可以通过虚拟机的“-version”命令的输出结果显示出这三种模式.</p></blockquote><ol start="2"><li>分层编译</li></ol><p>为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机在编译子系统中加入了分层编译的功能。分层编译的概念其实很早就已经提出，但直到JDK 6时期才被初步实现，后来一直处于改进阶段，最终在JDK 7的服务端模式虚拟机中作为默认编译策略被开启。</p><p>编译层次如下：</p><ul><li>第0层：程序纯解释执行，并且解释器不开启性能监控功能（Profiling）。</li><li>第1层：使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能。</li><li>第2层：仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。</li><li>第3层：仍然使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。</li><li>第4层：使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。</li></ul><p>以上层次并不是固定不变的，根据不同的运行参数和版本，虚拟机可以调整分层的数量。</p><p>分层编译的优势：实施分层编译后，解释器、客户端编译器和服务端编译器就会同时工作，热点代码都可能会被多次编译，用客户端编译器获取更高的编译速度，用服务端编译器来获取更好的编译质量，在解释执行的时候也无须额外承担收集性能监控信息的任务，而在服务端编译器采用高复杂度的优化算法时，客户端编译器可先采用简单优化来为它争取更多的编译时间。</p><p><img src="/image/jdk/jdk-hi-comp-interaction.png" alt="分层编译交互"></p><ol start="3"><li>编译对象与触发条件</li></ol><p>在运行过程中会被即时编译器编译的目标是“热点代码”，分为：</p><ul><li>被多次调用的方法<ul><li>以整个方法作为编译对象，虚拟机中标准的即时编译方式</li></ul></li><li>被多次执行的循环体<ul><li>以整个方法作为编译对象，编译时会传入执行入口点字节码序号（Byte Code Index，BCI）</li><li>这种编译方式因为编译发生在方法执行的过程中，因此被很形象地称为“栈上替换”（On Stack Replacement，OSR），即方法的栈帧还在栈上，方法就被替换了。</li></ul></li></ul><p>要知道某段代码是不是热点代码，是不是需要触发即时编译，这个行为称为“热点探测”（Hot Spot Code Detection），其实进行热点探测并不一定要知道方法具体被调用了多少次，目前主流的热点探测判定方式有两种，分别是：</p><ul><li>基于采样的热点探测（Sample Based Hot Spot Code Detection），采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，锁定高频率出现在栈顶的方法。</li><li>基于计数器的热点探测（Counter Based Hot Spot Code Detection），采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”。</li></ul><p>在HotSpot虚拟机中使用的是第二种基于计数器的热点探测方法，为了实现热点计数，HotSpot为每个方法准备了两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter，“回边”的意思就是指在循环边界往回跳转）。</p><p>3.1 方法调用计数器</p><p>方法调用计数器：用于统计方法被调用的次数，默认阈值在客户端模式下是1500次，在服务端模式下是10000次，这个阈值可以通过虚拟机参数-XX：CompileThreshold来人为设定。</p><p>在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被减少一半，这个过程被称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time），进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX：-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样只要系统运行时间足够长，程序中绝大部分方法都会被编译成本地代码。另外还可以使用-XX：CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p><p>3.2 回边计数器</p><p>它的作用是统计一个方法中循环体代码执行的次数[3]，在字节码中遇到控制流向后跳转的指令就称为“回边（Back Edge）”，很显然建立回边计数器统计的目的是为了触发栈上的替换编译。</p><p>可以设置参数-XX：OnStackReplacePercentage来间接调整回边计数器的阈值，其计算公式有如下两种：</p><ul><li><p>虚拟机运行在客户端模式下，回边计数器阈值计算公式为：方法调用计数器阈值（-XX：CompileThreshold）乘以OSR比率（-XX：OnStackReplacePercentage）除以100。其中-XX：OnStackReplacePercentage默认值为933，如果都取默认值，那客户端模式虚拟机的回边计数器的阈值为13995。</p></li><li><p>虚拟机运行在服务端模式下，回边计数器阈值的计算公式为：方法调用计数器阈值（-XX：CompileThreshold）乘以（OSR比率（-XX：OnStackReplacePercentage）减去解释器监控比率（-XX：InterpreterProfilePercentage）的差值）除以100。其中-XX：OnStack ReplacePercentage默认值为140，-XX：InterpreterProfilePercentage默认值为33，如果都取默认值，那服务端模式虚拟机回边计数器的阈值为10700。</p></li></ul><p>与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。</p><h1 id="提前编译器"><a href="#提前编译器" class="headerlink" title="提前编译器"></a>提前编译器</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;字节码是Java程序的中间态，可以在不同的环境中运行。在何种状态下把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码，它都可以视为整个编译过程的后端。&lt;/p&gt;
&lt;p&gt;无论是提前编译器抑或即时编译器，都不是Java虚拟机必需的组成部分，《Java虚</summary>
      
    
    
    
    
    <category term="jdk" scheme="http://zws6672.top/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>前端编译与优化</title>
    <link href="http://zws6672.top/2021/05/13/jdk-front-compile/"/>
    <id>http://zws6672.top/2021/05/13/jdk-front-compile/</id>
    <published>2021-05-13T14:05:07.000Z</published>
    <updated>2021-05-13T14:08:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java-编译器"><a href="#一、Java-编译器" class="headerlink" title="一、Java 编译器"></a>一、Java 编译器</h1><p>“编译期”可能是指一个前端编译器（叫“编译器的前端”更准确一些）把<em>.java文件转变成</em>.class文件的过程；也可能是指Java虚拟机的即时编译器（常称JIT编译器，Just In Time Compiler）运行期把字节码转变成本地机器码的过程；还可能是指使用静态的提前编译器（常称AOT编译器，Ahead Of Time Compiler）直接把程序编译成与目标机器指令集相关的二进制代码的过程。</p><ul><li>前端编译器：JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）</li><li>即时编译器：HotSpot虚拟机的C1、C2编译器，Graal编译器</li><li>提前编译器：JDK的Jaotc、GNU Compiler for the Java（GCJ）、Excelsior JET</li></ul><p>这里，先暂时将“编译期”仅限于第一类编译过程，即前端编译器。相当多新生的Java语法特性，都是靠编译器的“语法糖”来实现，而不是依赖字节码或者Java虚拟机的底层改进来支持。</p><p>Javac编译器不像HotSpot虚拟机那样使用C++语言（包含少量C语言）实现，它本身就是一个由Java语言编写的程序。</p><p>从Javac编译过程如下：</p><ol><li>准备过程</li></ol><ul><li>初始化插入式注解处理器</li></ul><ol start="2"><li>处理过程</li></ol><ul><li>解析与填充符号表过程，包括：<ul><li>词法、语法分析；将源代码的字符流转变为标记集合，构造出抽象语法树。</li><li>填充符号表；产生符号的地址和符号信息。</li></ul></li><li>插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段</li><li>分析与字节码生成过程，包括：<ul><li>标注检查，对语法的静态信息进行检查。</li><li>数据流及控制流分析，对程序动态运行过程进行检查。</li><li>解语法糖，将简化代码编写的语法糖还原为原有的形式。</li><li>字节码生成，将前面各个步骤所生成的信息转化成字节码。</li></ul></li></ul><p>上述3个处理过程里，执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须转回到之前的解析、填充符号表的过程中重新处理这些新符号。</p><p><img src="/image/jdk/jvm-javac.png" alt="javac处理过程"></p><h3 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h3><ol><li>词法、语法分析</li></ol><p>词法分析是将源代码的字符流转变为标记（Token）集合的过程，单个字符是程序编写时的最小元素，但标记才是编译时的最小元素（关键字、变量名、字面量、运算符都可以作为标记，例如“int a=b+2”会被解析为6个标记）。在Javac的源码中，词法分析过程由<code>com.sun.tools.javac.parser.Scanner</code>类来实现。</p><p>语法分析是根据标记序列构造抽象语法树的过程，抽象语法树（Abstract Syntax Tree，AST）是一种用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表着程序代码中的一个语法结构（Syntax Construct），例如包、类型、修饰符、运算符、接口、返回值甚至连代码注释等都 可以是一种特定的语法结构。在Javac的源码中，语法分析过程由<code>com.sun.tools.javac.parser.Parser</code>类实现，这个阶段产出的抽象语法树是以<code>com.sun.tools.javac.tree.JCTree</code>类表示的。</p><p>经过词法和语法分析生成语法树以后，编译器就不会再对源码字符流进行操作了，后续的操作都建立在抽象语法树之上。</p><ol start="2"><li>填充符号表</li></ol><p>符号表（Symbol Table）是由一组符号地址和符号信息构成的数据结构，读者可以把它类比想象成哈希表中键值对的存储形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等各种形式）。</p><p>符号表中所登记的信息在编译的不同阶段都要被用到。譬如在语义分析的过程中，符号表所登记的内容将用于语义检查（如检查一个名字的使用和原先的声明是否一致）和产生中间代码，在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的直接依据。</p><p>在Javac源代码中，填充符号表的过程由com.sun.tools.javac.comp.Enter类实现，该过程的产出物是一个待处理列表，其中包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java（如果存在的话）的顶级节点。</p><h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p>JDK 5之后，Java语言提供了对注解（Annotations）的支持，注解在设计上原本是与普通的Java代码一样，都只会在程序运行期间发挥作用的。但在JDK 6中又提出并通过了JSR-269提案，该提案设计了一组被称为“插入式注解处理器”的标准API，可以提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程。</p><p>我们可以把插入式注解处理器看作是一组编译器的插件，当这些插件工作时，允许读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为一个轮次（Round）</p><p>有了编译器注解处理的标准API后，程序员的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件中被访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。</p><p>有了编译器注解处理的标准API后，程序员的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件中被访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。</p><p>在Javac源码中，插入式注解处理器的初始化过程是在initPorcessAnnotations()方法中完成的，而它的执行过程则是在processAnnotations()方法中完成。这个方法会判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessing-Environment类的doProcessing()方法来生成一个新的JavaCompiler对象，对编译的后续步骤进行处理。</p><h3 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h3><p>经过语法分析之后，编译器获得了程序代码的抽象语法树表示，抽象语法树能够表示一个结构正确的源程序，但无法保证源程序的语义是符合逻辑的。而语义分析的主要任务则是对结构上正确的源程序进行上下文相关性质的检查，譬如进行类型检查、控制流检查、数据流检查等等。</p><ol><li>标注检查</li></ol><p>Javac在编译过程中，语义分析过程可分为标注检查和数据及控制流分析两个步骤，分别由attribute()和flow()方法完成。</p><ul><li>标注检查步骤要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等等。在标注检查中，还会顺便进行一个称为常量折叠（Constant Folding）的代码优化，这是Javac编译器会对源代码做的极少量优化措施之一。标注检查步骤在Javac源码中的实现类是com.sun.tools.javac.comp.Attr类和com.sun.tools.javac.comp.Check类。</li><li>数据流分析和控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上可以看作是一致的，但校验范围会有所区别，有一些校验项只有在编译期或运行期才能进行。</li></ul><blockquote><p>变量的不变性仅仅由Javac编译器在编译期间来保障，这就是一个只能在编译期而不能在运行期中检查的例子.</p></blockquote><ol start="3"><li>解语法糖</li></ol><p>语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机科学家Peter J.Landin发明的一种编程术语，指的是在计算机语言中添加的某种语法，这种语法对语言的编译结果和功能并没有实际影响，但是却能更方便程序员使用该语言。通常来说使用语法糖能够减少代码量、增加程序的可读性，从而减少程序代码出错的机会。</p><p>Java中最常见的语法糖包括了前面提到过的泛型（其他语言中泛型并不一定都是语法糖实现，如C#的泛型就是直接由CLR支持的）、变长参数、自动装箱拆箱，等等，Java虚拟机运行时并不直接支持这些语法，它们在编译阶段被还原回原始的基础语法结构，这个过程就称为解语法糖。</p><p>在Javac的源码中，解语法糖的过程由desugar()方法触发，在com.sun.tools.javac.comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成。</p><ol start="4"><li>字节码生成</li></ol><p>字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码指令写到磁盘中，编译器还进行了少量的代码添加和转换工作。</p><p>实例构造器<init>()方法和类构造器<clinit>()方法就是在这个阶段被添加到语法树之中的。这里的实例构造器并不等同于默认构造函数，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、可访问性（public、protected、private或<package>）与当前类型一致的默认构造函数，这个工作在填充符号表阶段中就已经完成。</package></clinit></init></p><p><init>()和<clinit>()这两个构造器的产生实际上是一种代码收敛的过程，编译器会把语句块（对于实例构造器而言是“{}”块，对于类构造器而言是“static{}”块）、变量初始化（实例变量和类变量）、调用父类的实例构造器（仅仅是实例构造器，<clinit>()方法中无须调用父类的<clinit>()方法，Java虚拟机会自动保证父类构造器的正确执行，但在<clinit>()方法中经常会生成调用java.lang.Object的<init>()方法的代码）等操作收敛到<init>()和<clinit>()方法之中，并且保证无论源码中出现的顺序如何，都一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行。</clinit></init></init></clinit></clinit></clinit></clinit></init></p><p>上面所述的动作由Gen::normalizeDefs()方法来实现。除了生成构造器以外，还有其他的一些代码替换工作用于优化程序某些逻辑的实现方式。</p><p>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交到com.sun.tools.javac.jvm.ClassWriter类手上，由这个类的writeClass()方法输出字节码，生成最终的Class文件，到此，整个编译过程宣告结束。</p><h1 id="二、Java语法糖"><a href="#二、Java语法糖" class="headerlink" title="二、Java语法糖"></a>二、Java语法糖</h1><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型的本质是参数化类型（Parameterized Type）或者参数化多态（Parametric Polymorphism）的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数类型能够用在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。</p><p>泛型路径：</p><ul><li>需要泛型化的类型（主要是容器类型），以前有的就保持不变，然后平行地加一套泛型化版本的新类型(C#)</li><li>直接把已有的类型泛型化，即让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于已有类型的泛型版(JAVA)</li></ul><ol><li>Java与C#的泛型</li></ol><p>Java选择的泛型实现方式叫作“类型擦除式泛型”（Type Erasure Generics），而C#选择的泛型实现方式是“具现化式泛型”（Reified Generics）：</p><ul><li>具现化和特化、偏特化这些名词最初都是源于C++模版语法中的概念。C#里面泛型无论在程序源码里面、编译后的中间语言表示（IntermediateLanguage，这时候泛型是一个占位符）里面，抑或是运行期的CLR里面都是切实存在的，List<int>与List<string>就是两个不同的类型，它们由系统在运行期生成，有着自己独立的虚方法表和类型数据。</string></int></li><li>而Java语言中的泛型则不同，它只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型（Raw Type，稍后我们会讲解裸类型具体是什么）了，并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，ArrayList<int>与ArrayList<string>其实是同一个类型。</string></int></li></ul><ol start="2"><li>Java泛型</li></ol><p>Java中不支持的泛型用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TypeErasureGenerics&lt;E&gt; &#123;</span><br><span class="line">public void doSomething(Object item) &#123;</span><br><span class="line">if (item instanceof E) &#123; // 不合法，无法对泛型进行实例判断</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">E newItem = new E(); // 不合法，无法使用泛型创建对象</span><br><span class="line">E[] itemArray = new E[10]; // 不合法，无法使用泛型创建数组</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java的类型擦除式泛型无论在使用效果上还是运行效率上，几乎是全面落后于C#的具现化式泛型，而它的唯一优势是在于实现这种泛型的影响范围上：擦除式泛型的实现几乎只需要在Javac编译器上做出改进即可，不需要改动字节码、不需要改动Java虚拟机，也保证了以前没有使用泛型的库可以直接运行在Java 5.0之上。</p><p>要让所有需要泛型化的已有类型，譬如ArrayList，原地泛型化后变成了ArrayList<t>，而且保证以前直接用ArrayList的代码在泛型新版本里必须还能继续用这同一个容器，这就必须让所有泛型化的实例类型，譬如ArrayList<integer>、ArrayList<string>这些全部自动成为ArrayList的子类型才能可以，否则类型转换就是不安全的。由此就引出了“裸类型”（Raw Type）的概念，裸类型应被视为所有该类型泛型化实例的共同父类型（Super Type）。</string></integer></t></p><ol start="3"><li>Valhall</li></ol><p>Oracle建立了一个名为Valhalla的语言改进项目,希望改进Java语言留下的各种缺陷（解决泛型的缺陷就是项目主要目标其中之一）。在Valhalla项目中规划了几种不同的新泛型实现方案，被称为Model 1到Model 3，在这些新的泛型设计中，泛型类型有可能被具现化，也有可能继续维持类型擦除以保持兼容（取决于采用哪种实现方案），即使是继续采用类型擦除的方案，泛型的参数化类型也可以选择不被完全地擦除掉，而是相对完整地记录在Class文件中，能够在运行期被使用，也可以指定编译器默认要擦除哪些类型。</p><p>相对于使用不同方式实现泛型，目前比较明确的是未来的Java应该会提供“值类型”（Value Type）的语言层面的支持。与C#不同的是，Java语言中存在基础类型，需要装箱为变量，而不能直接转换为Object；频繁的装箱拆箱使Java语言的泛型受人诟病。</p><p>在Valhalla项目中，Java的值类型方案被称为“内联类型”，计划通过一个新的关键字inline来定义，字节码层面也有专门与原生类型对应的以Q开头的新的操作码（譬如iload对应qload）来支撑。</p><h3 id="自动装箱、拆箱与遍历循环"><a href="#自动装箱、拆箱与遍历循环" class="headerlink" title="自动装箱、拆箱与遍历循环"></a>自动装箱、拆箱与遍历循环</h3><p>自动装箱、自动拆箱与遍历循环（for-each循环）这些语法糖是Java语言里面被使用最多的语法糖。</p><p>拆箱例子1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4);</span><br><span class="line">int sum = 0;</span><br><span class="line">for (int i : list) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===&gt;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">List list = Arrays.asList( new Integer[] &#123;</span><br><span class="line">Integer.valueOf(1),</span><br><span class="line">Integer.valueOf(2),</span><br><span class="line">Integer.valueOf(3),</span><br><span class="line">Integer.valueOf(4) &#125;);</span><br><span class="line">int sum = 0;</span><br><span class="line">for (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) &#123;</span><br><span class="line">int i = ((Integer)localIterator.next()).intValue();</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动装箱的陷阱：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        Integer a = 1;</span><br><span class="line">        Integer b = 2;</span><br><span class="line">        Integer c = 3;</span><br><span class="line">        Integer d = 3;</span><br><span class="line">        Integer e = 321;</span><br><span class="line">        Integer f = 321;</span><br><span class="line">        Long g = 3L;</span><br><span class="line">//        存在 -128~127的Integer对象池</span><br><span class="line">        System.out.println(c == d); // ture</span><br><span class="line">        System.out.println(e == f); // false</span><br><span class="line"></span><br><span class="line">        System.out.println(c == (a + b)); // true</span><br><span class="line">//        自动提权、-128~127的Long对象池</span><br><span class="line">        System.out.println(g == (a + b)); // true</span><br><span class="line">//        equals()方法不处理数据转型</span><br><span class="line">        System.out.println(c.equals(a + b)); // true</span><br><span class="line">        System.out.println(g.equals(a + b)); //false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱，以及它们equals()方法不处理数据转型的关系。</p></blockquote><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>许多程序设计语言都提供了条件编译的途径，如C、C++中使用预处理器指示符（#ifdef）来完成条件编译。</p><p>在Java语言之中并没有使用预处理器，因为Java语言天然的编译方式（编译器并非一个个地编译Java文件，而是将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译，因此各个文件之间能够互相提供符号信息）就无须使用到预处理器。</p><p>Java语言当然也可以进行条件编译，方法就是使用条件为常量的if语句。只能使用条件为常量的if语句才能达到上述效果，如果使用常量与其他带有条件判断能力的语句搭配，则可能在控制流分析中提示错误，被拒绝编译。</p><p>Java语言的条件编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">if (true) &#123;</span><br><span class="line">System.out.println(&quot;block 1&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;block 2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===&gt;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;block 1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// 编译器将会提示“Unreachable code”</span><br><span class="line">while (false) &#123;</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java语言中条件编译的实现，也是Java语言的一颗语法糖，根据布尔常量值的真假，编译器将会把分支中不成立的代码块消除掉，这一工作将在编译器解除语法糖阶段（com.sun.tools.javac.comp.Lower类中）完成。</p><p>Java语言还有不少其他的语法糖，如内部类、枚举类、断言语句、数值字面量、对枚举和字符串的switch支持、try语句中定义和关闭资源（这3个从JDK 7开始支持）、Lambda表达式（从JDK 8开始支持，Lambda不能算是单纯的语法糖，但在前端编译器中做了大量的转换工作）等等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>之所以把Javac这类将Java代码转变为字节码的编译器称作“前端编译器”，是因为它只完成了从程序到抽象语法树或中间字节码的生成，而在此之后，还有一组内置于Java虚拟机内部的“后端编译器”来完成代码优化以及从字节码生成本地机器码的过程，即前面多次提到的即时编译器或提前编译器，这个后端编译器的编译速度及编译结果质量高低，是衡量Java虚拟机性能最重要的一个指标。</p><blockquote><p><a href>深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）第10章</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Java-编译器&quot;&gt;&lt;a href=&quot;#一、Java-编译器&quot; class=&quot;headerlink&quot; title=&quot;一、Java 编译器&quot;&gt;&lt;/a&gt;一、Java 编译器&lt;/h1&gt;&lt;p&gt;“编译期”可能是指一个前端编译器（叫“编译器的前端”更准确一些）把&lt;em&gt;.</summary>
      
    
    
    
    
    <category term="jdk" scheme="http://zws6672.top/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机字节码执行引擎</title>
    <link href="http://zws6672.top/2021/04/26/jdk-bytecodeEngine/"/>
    <id>http://zws6672.top/2021/04/26/jdk-bytecodeEngine/</id>
    <published>2021-04-26T03:17:18.000Z</published>
    <updated>2021-04-26T03:18:17.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、运行时栈帧结构"><a href="#一、运行时栈帧结构" class="headerlink" title="一、运行时栈帧结构"></a>一、运行时栈帧结构</h1><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一<br>大步。</p><p>执行引擎在执行字节码的时候，通常会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备。</p><blockquote><p>有一些虚拟机（如Sun Classic VM）的内部只存在解释器，只能解释执行，另外一些虚拟机（如BEA JRockit）的内部只存在即时编译器，只能编译执行。</p></blockquote><p>Java虚拟机以方法作为最基本的执行单元，“栈帧”（Stack Frame）则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。每一个栈帧都包括了 局部变量表、操作数栈、动态连接、方法返回地址 和一些额外的 附加信息。</p><p>而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”（Current Stack Frame），与这个栈帧所关联的方法被称为“当前方法”（Current Method）</p><ol><li>局部变量表</li></ol><p>局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。局部变量表的容量以变量槽（Variable Slot）为最小单位，每个变量槽都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存储。</p><ol start="2"><li>操作数栈</li></ol><p>操作数栈（Operand Stack）也常被称为操作栈，它是一个后入先出（Last In First Out，LIFO）栈。操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项，操作数栈中元素的数据类型必须与字节码指令的序列严格匹配。Java虚拟机的解释执行引擎被称为“基于栈的执行引擎”，里面的“栈”就是操作数栈。</p><ol start="3"><li>动态连接</li></ol><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。</p><ol start="4"><li>方法返回地址</li></ol><p>当一个方法开始执行后，只有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者或者主调方法），方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为“正常调用完成”（Normal Method Invocation Completion）。</p><p>退出方法：</p><ul><li>Java虚拟机内部产生的异常</li><li>代码中使用athrow字节码指令产生的异常（throw、throws）</li></ul><p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：</p><ul><li>恢复上层方法的局部变量表和操作数栈</li><li>把返回值（如果有的话）压入调用者栈帧的操作数栈中</li><li>调整PC计数器的值以指向方法调用指令后面的一条指令等。=</li></ul><ol start="5"><li>附加信息</li></ol><p>Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现</p><h1 id="二、方法调用"><a href="#二、方法调用" class="headerlink" title="二、方法调用"></a>二、方法调用</h1><p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还未涉及方法内部的具体运行过程。</p><p>Class文件的编译过程中不包含传统程序语言编译的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（也就是之前说的直接引用）。</p><ul><li>解析：调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析（Resolution）。<ul><li>在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问。</li></ul></li><li>分派：分派（Dispatch）调用则要复杂许多，它可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派[1]。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况。<ul><li>静态分派：所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。静态分派的最典型应用表现就是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行</li><li>动态分派：在运行期根据实际类型确定方法执行版本的分派过程称为动态分派，动态分派 的最典型应用表现就是方法重写。</li><li>单分派与多分派：方法的接收者与方法的参数统称为方法的宗量，这个定义最早应该来源于著名的《Java与模式》一书。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。</li></ul></li><li>方法调用字节码指令<ul><li>invokestatic：用于调用静态方法。</li><li>invokespecial：用于调用实例构造器<init>()方法、私有方法和父类中的方法。</init></li><li>invokevirtual：用于调用所有的虚方法。</li><li>invokeinterface：用于调用接口方法，会在运行时再确定一个实现该接口的对象。</li><li>invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</li></ul></li><li>虚拟机动态分派的实现：Java虚拟机实现基于执行性能的考虑，真正运行时一般不会如此频繁地去反复搜索类型元数据。面对这种情况，一种基础而且常见的优化手段是为类型在方法区中建立一个虚方法表（Virtual Method Table，也称为vtable，与此对应的，在invokeinterface执行时也会用到接口方法表——Interface Method Table，简称itable），使用虚方法表索引来代替元数据查找以提高性能。<ul><li>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</li></ul></li></ul><blockquote></blockquote><p>Java语言是一门静态多分派、动态单分派的语言。 字段永远不参与多态，哪个类的方法访问某个名字的字段时，该名字指的就是这个类能看到的那个字段。当子类声明了与父类同名的字段时，虽然在子类的内存中两个字段都会存在，但是子类的字段会遮蔽父类的同名字段。</p><h1 id="三、动态类型语言"><a href="#三、动态类型语言" class="headerlink" title="三、动态类型语言"></a>三、动态类型语言</h1><p>JDK7 发布了字节码首位新成员——invokedynamic指令，用于实现动态类型语言（Dynamically Typed Language）支持，为JDK 8里可以顺利实现Lambda表达式而做的技术储备。</p><p>动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的，满足这个特征的语言有很多，常用的包括：APL、Clojure、Erlang、Groovy、JavaScript、Lisp、Lua、PHP、Prolog、Python、Ruby、Smalltalk、Tcl，等等。那相对地，在编译期就进行类型检查过程的语言，譬如C++和Java等就是最常用的静态类型语言。。“变量无类型而变量值才有类型”这个特点也是动态类型语言的一个核心特征。</p><p>动态类型方法调用的底层问题终归是应当在Java虚拟机层次上去解决才最合适。因此，在Java虚拟机层面上提供动态类型的直接支持就成为Java平台发展必须解决的问题，这便是JDK 7时JSR-292提案中invokedynamic指令以及java.lang.invoke包出现的技术背景。</p><ol><li>MethodHand（方法句柄）</li></ol><p>JDK 7时新加入的java.lang.invoke包是JSR 292的一个重要组成部分，这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这条路之外，提供一种新的动态确定目标方法的机制，称为“方法句柄”（Method Handle）。java7新增了一个字节码invokedynamic,可以在运行期动态决定调用的方法，区别于之前的 invokestatic(静态方法调用),invokespecial（构造方法，私有方法，父类方法），invokevirtual（实例方法），invokeinterface(接口方法)，不过在java7下javac不支持生成invokedynamic,java8中可以通过lambda来生成。</p><ol start="2"><li>Reflection 与 MethodHandle</li></ol><ul><li><p>Reflection 和MethodHandle机制本质上都是在模拟方法调用，但是Reflection是在模拟Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用。</p></li><li><p>在MethodHandles.Lookup上的3个方法findStatic()、findVirtual()、findSpecial()正是为了对应于 invokestatic、invokevirtual（以及invokeinterface）和invokespecial这几条字节码指令的执行权限校验行为，而这些底层细节在使用Reflection API时是不需要关心的。</p></li><li><p>Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的java.lang.invoke.MethodHandle对象所包含的信息来得多。前者是方法在Java端的全面映像，包含了方法的签名、描述符以及方法属性表中各种属性的Java端表示方式，还包含执行权限等的运行期信息。而后者仅包含执行该方法的相关信息。用开发人员通俗的话来讲，Reflection是重量级，而MethodHandle是轻量级。</p></li><li><p>由于MethodHandle是对字节码的方法指令调用的模拟，那理论上虚拟机在这方面做的各种优化（如方法内联），在MethodHandle上也应当可以采用类似思路去支持。</p></li><li><p>Reflection API的设计目标是只为Java语言服务的，而MethodHandle则设计为可服务于所有Java虚拟机之上的语言，其中也包括了Java语言而已，而且Java在这里并不是主角。</p></li></ul><ol start="3"><li>invokedynamic指令</li></ol><p>某种意义上可以说invokedynamic指令与MethodHandle机制的作用是一样的，都是为了解决原有4条“invoke*”指令方法分派规则完全固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中，让用户（广义的用户，包含其他程序语言的设计者）有更高的自由度。</p><p>每一处含有invokedynamic指令的位置都被称作“动态调用点（Dynamically-Computed Call Site）”，这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是变为 JDK7 时新加入的CONSTANT_InvokeDynamic_info常量，从这个新常量中可以得到3项信息：</p><ul><li>引导方法（Bootstrap Method，该方法存放在新增的BootstrapMethods属性中）</li><li>方法类型（MethodType）</li><li>名称</li></ul><p>invokedynamic指令与此前4条传统的“invoke*”指令的最大区别就是它的分派逻辑不是由虚拟机决定的，而是由程序员决定。但是，这个指令Java其实不太好用。准确的来说，它的设计是为了在Java虚拟机层面上提供动态类型的直接支持，而Java这种静态语言就很难用到这个指令。而在JDK8中，lamda表达式和默认方法就是围绕这个指令而设计的。</p><h1 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h1><p>许多Java虚拟机的执行引擎在执行Java代码的时候都有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择。只有确定了谈论对象是某种具体的Java实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较合理确切。</p><p><img src="/image/jdk/engine-jslc.png" alt="字节码解释执行引擎"></p><p>如今，基于物理机、Java虚拟机，或者是非Java的其他高级语言虚拟机（HLLVM）的代码执行过程，大体上都会遵循这种符合现代经典编译原理的思路，在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树（Abstract Syntax Tree，AST）。对于一门具体语言的实现来说，</p><ul><li>词法、语法分析以至后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是C/C++语言</li><li>也可以选择把其中一部分步骤（如生成抽象语法树之前的步骤）实现为一个半独立的编译器，这类代表是Java语言</li><li>又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子之中，如大多数的JavaScript执行引擎。</li></ul><p>在Java语言中，Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。</p><ol><li>基于栈的指令集与基于寄存器的指令集</li></ol><p>Javac编译器输出的字节码指令流，基本上[1]是一种基于栈的指令集架构（Instruction Set Architecture，ISA），字节码指令流里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作。与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的就是x86的二地址指令集。</p><p>基于栈的指令集主要优点是可移植，因为寄存器由硬件直接提供[2]，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束；栈架构指令集的主要缺点是理论上执行速度相对来说会稍慢一些。</p><p>在解释执行时，栈架构指令集的代码虽然紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构来得更多，因为出栈、入栈操作本身就产生了相当大量的指令。更重要的是栈实现在内存中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。尽管虚拟机可以采取栈顶缓存的优化方法，把最常用的操作映射到寄存器中避免直接内存访问，但这也只是优化措施而不是解决本质问题的方法。因此由于指令数量和内存访问的原因，导致了栈架构指令集的执行速度会相对慢上一点。</p><ol start="2"><li>基于栈的解释器执行过程</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int calc() &#123;</span><br><span class="line">int a = 100;</span><br><span class="line">int b = 200;</span><br><span class="line">int c = 300;</span><br><span class="line">return (a + b) * c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int calc();</span><br><span class="line">Code:</span><br><span class="line">Stack=2, Locals=4, Args_size=1</span><br><span class="line">0: bipush 100# Bipush指令的作用是将单字节的整型常量值（-128～127）推入操作数栈顶</span><br><span class="line">2: istore_1# istore_1指令的作用是将操作数栈顶的整型值出栈并存放到第1个局部变量槽中</span><br><span class="line">3: sipush 200</span><br><span class="line">6: istore_2</span><br><span class="line">7: sipush 300</span><br><span class="line">10: istore_3</span><br><span class="line">11: iload_1# iload_1指令的作用是将局部变量表第1个变量槽中的整型值复制到操作数栈顶</span><br><span class="line">12: iload_2# iload_2指令的作用是将局部变量表第2个变量槽中的整型值复制到操作数栈顶</span><br><span class="line">13: iadd# 栈顶取两数相加</span><br><span class="line">14: iload_3# iload_3指令的作用是将局部变量表第3个变量槽中的整型值复制到操作数栈顶</span><br><span class="line">15: imul# 栈顶取两数相除</span><br><span class="line">16: ireturn# ireturn指令是方法返回指令之一，它将结束方法执行并将操作数栈顶的整型值返回给该方法的调用者</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、运行时栈帧结构&quot;&gt;&lt;a href=&quot;#一、运行时栈帧结构&quot; class=&quot;headerlink&quot; title=&quot;一、运行时栈帧结构&quot;&gt;&lt;/a&gt;一、运行时栈帧结构&lt;/h1&gt;&lt;p&gt;代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一</summary>
      
    
    
    
    
    <category term="jdk" scheme="http://zws6672.top/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类加载机制</title>
    <link href="http://zws6672.top/2021/04/15/jdk-cload/"/>
    <id>http://zws6672.top/2021/04/15/jdk-cload/</id>
    <published>2021-04-15T14:37:42.000Z</published>
    <updated>2021-04-15T14:38:20.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、类加载的过程"><a href="#一、类加载的过程" class="headerlink" title="一、类加载的过程"></a>一、类加载的过程</h1><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。在了解了Class文件的结构后，还需要了解虚拟机如何加载字节码文件、加载字节码文件后数据发生了什么变化。</p><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的；而Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。（一般会在一个阶段执行的过程中调用、激活另一个阶段）</p><p><img src="/image/jdk/cload-lifeCycle.png" alt="类加载的过程"></p><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。</p><p>需要立即进行初始化的几种情况有且只有以下几种：</p><ul><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：<ul><li>使用new关键字实例化对象</li><li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）</li><li>调用一个类型的静态方法的时候。</li></ul></li><li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化</li><li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li>如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化</li><li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ul><p>除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。</p><ul><li>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</li><li>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</li></ul><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>“加载”（Loading）阶段是整个“类加载”（Class Loading）过程中的一个阶段，虚拟机完成以下三件事：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明二进制字节流必须得从某个Class文件中获取：从ZIP压缩包中读取、网络中获取、运行时计算生成、从数据库中读取等）</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ul><p>数组加载：</p><ul><li>对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，由Java虚拟机直接在内存中动态构造；但是数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载<ul><li>如果数组的组件类型是引用类型(Integer[])，递归采用加载过程去加载组件类型；数组将被标识在加载该组件类型的类加载器的类名称空间上</li><li>如果数组的组件类型是基本类型（int[]），Java虚拟机将会把数组C标记为与引导类加载器关联.数组类的可访问性将默认为public，可被所有的类和接口访问到。</li></ul></li></ul><p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><p>Class文件并不一定只能由Java源码编译而来，它可以使用包括靠键盘0和1直接在二进制编辑器中敲出Class文件在内的任何途径产生。Java虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有错误或有恶意企图的字节码流而导致整个系统受攻击甚至崩溃，所以验证字节码是Java虚拟机保护自身的一项必要措施。</p><p>文件格式验证</p><ul><li>是否以魔数0xCAFEBABE开头。</li><li>主、次版本号是否在当前Java虚拟机接受范围之内。</li><li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li><li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。</li><li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息等等<br>元数据验证：对字节码描述的信息进行语义分析</li><li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li><li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li><li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。<br>字节码验证</li><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作</li><li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上</li><li>保证方法体中的类型转换总是有效的（避免父类转换为子类）</li><li>符号引用验证（解析阶段）：发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生；查看该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源</li><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li><li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li><li>符号引用中的类、字段、方法的可访问性（private、protected、public、<package>）是否可被当<br>前类访问。</package></li></ul><blockquote><p>StackMapTable属性：在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化，把尽可能多的校验辅助措施挪到Javac编译器里进行；只需要检查 StackMapTable属性 中的记录是否合法即可。这项属性描述了方法体所有的基本块（Basic Block，指按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态。JDK 6的HotSpot虚拟机中提供了-XX：-UseSplitVerifier选项来关闭掉这项优化，或者使用参数-XX：+FailOverToOldVerifier要求在类型校验失败的时候退回到旧的类型推导方式进行校验。</p></blockquote><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域，在JDK 7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了</p><p>基本类型的初始化：<br><img src="/image/jdk/cload-basetypeinit.png" alt="基本数据类型的零值"></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。</p><ul><li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可</li><li>直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在</li></ul><p>《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行ane-warray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p><p>对同一个符号引用进行多次解析请求是很常见的事情。如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直能够成功；同样地，如果第一次解析失败了，其他指令对这个符号的解析请求也应该收到相同的异常，哪怕这个请求的符号在后来已成功加载进Java虚拟机内存之中。</p><ol><li>类或接口的解析</li></ol><p>类或接口的解析，假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：</p><ul><li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败。</li><li>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表该数组维度和元素的数组对象。</li><li>如果上面两步没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</li></ul><p>如果说一个D拥有C的访问权限，那就意味着以下3条规则中至少有其中一条成立：</p><ul><li>被访问类C是public的，并且与访问类D处于同一个模块。</li><li>被访问类C是public的，不与访问类D处于同一个模块，但是被访问类C的模块允许被访问类D的模块进行访问。</li><li>被访问类C不是public的，但是它与访问类D处于同一个包中。</li></ul><ol start="2"><li>字段解析<br>要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index[3]项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。</li></ol><ul><li>如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败、</li><li>如果解析成功完成，那把这个字段所属的类或接口用C表示<ul><li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束（本类的字段）</li><li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束（自定义类父接口的字段）</li><li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。（自定义类父类的字段）</li><li>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</li></ul></li></ul><p>在实际情况中，Javac编译器往往会采取比上述规范更加严格一些的约束，譬如有一个同名字段同时出现在某个类的接口和父类当中，或者同时在自己或父类的多个接口中出现，按照解析规则仍是可以确定唯一的访问字段，但Javac编译器就可能直接拒绝其编译为Class文件。</p><ol start="3"><li>方法解析</li></ol><p>方法解析的第一个步骤与字段解析一样，也是需要先解析出方法表的class_index[4]项中索引的方法所属的类或接口的符号引用，如果解析成功，那么我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的方法搜索：</p><ul><li>由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现class_index中索引的C是个接口的话，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li><li>如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出java.lang.AbstractMethodError异常。</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。</li></ul><ol start="4"><li>接口方法解析</li></ol><p>接口方法也是需要先解析出接口方法表的class_index[5]项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：</p><ul><li>与类的方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那么就直接抛出java.lang.IncompatibleClassChangeError异常。</li><li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>对于规则3，由于Java的接口允许多重继承，如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li></ul><p>在JDK 9之前，Java接口中的所有方法都默认是public的，也没有模块化的访问约束，所以不存在访问权限的问题，接口方法的符号解析就不可能抛出java.lang.IllegalAccessError异常。但在JDK 9中增加了接口的静态私有方法，也有了模块化的访问约束，所以从JDK 9起，接口方法的访问也完全有可能因访问权限控制而出现java.lang.IllegalAccessError异常</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通<br>过程序编码制定的主观计划去初始化类变量和其他资源。初始化阶段就是执行类构造器<clinit>()方法的过程，它是Javac编译器的自动生成。</clinit></p><ul><li><p><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</clinit></p></li><li><p><clinit>()方法与类的构造函数（即在虚拟机视角中的实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。</clinit></clinit></init></clinit></p></li><li><p>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作</clinit></p></li><li><p><clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</clinit></clinit></p></li><li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成</p></li><li><p><clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法</clinit></clinit></clinit></clinit></p></li><li><p>Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行完毕<clinit>()方法。</clinit></clinit></clinit></p></li></ul><h1 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h1><p>“类加载器”（Class Loader）将”通过一个类的全限定名来获取描述该类的二进制字节流”放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。</p><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。两个类进行比较时，只要加载它们的类加载器不同，那么这两个类必定不相等。</p><blockquote><p>“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况</p></blockquote><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现[1]，是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</p><ol><li>三层类加载器</li></ol><p>启动类加载器（Bootstrap Class Loader）：前面已经介绍过，这个类加载器负责加载存放在<java_home>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。</java_home></p><p>扩展类加载器（Extension Class Loader）：这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载<java_home>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。根据“扩展类加载器”这个名称，就可以推断出这是一种Java系统类库的扩展机制，JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK9之后，这种扩展机制被模块化带来的天然的扩展能力所取代。</java_home></p><p>应用程序类加载器（Application Class Loader）：这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><ol start="2"><li>双亲委派模型</li></ol><p>双亲委派模型如下：</p><p><img src="/image/jdk/cload-sq.png" alt="双亲委派模型"></p><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p><p>Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。如果定义一个和rt.jar类库中已有类重名的Java类，将会发现它可以正常编译，但永远无法被加载运行。</p><p>双亲委派模型的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">// a. 检查请求的类是否已经被加载过了</span><br><span class="line">Class c = findLoadedClass(name);</span><br><span class="line">if (c == null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">// b. 若没有则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。</span><br><span class="line">if (parent != null) &#123;</span><br><span class="line">c = parent.loadClass(name, false);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">c = findBootstrapClassOrNull(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">// 如果父类加载器抛出ClassNotFoundException，说明父类加载器无法完成加载请求</span><br><span class="line">&#125;</span><br><span class="line">if (c == null) &#123;</span><br><span class="line">// c. 在父类加载器无法加载时，再调用本身的findClass方法来进行类加载</span><br><span class="line">c = findClass(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (resolve) &#123;</span><br><span class="line">resolveClass(c);</span><br><span class="line">&#125;</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、Java模块化系统"><a href="#三、Java模块化系统" class="headerlink" title="三、Java模块化系统"></a>三、Java模块化系统</h1><p>在JDK 9中引入的Java模块化系统（Java Platform Module System，JPMS）是对Java技术的一次重要升级，为了能够实现模块化的关键目标——可配置的封装隔离机制。JDK 9的模块不仅仅像之前的JAR包那样只是简单地充当代码的容器，除了代码外，Java的模块定义还包含以下内容：</p><ul><li>依赖其他模块的列表。</li><li>导出的包列表，即其他模块可以使用的列表。</li><li>开放的包列表，即其他模块可反射访问模块的列表。</li><li>使用的服务列表。</li><li>提供服务的实现列表</li></ul><p>优点如下：</p><ul><li><p>可配置的封装隔离机制首先要解决JDK 9之前基于类路径（ClassPath）来查找依赖的可靠性问题（如果类路径中缺失了运行时依赖的类型，那就只能等程序运行到发生该类型的加载、链接时才会报出运行的异常）。而在JDK 9以后，如果启用了模块化进行封装，模块就可以声明对其他模块的显式依赖，这样Java虚拟机就能够在启动时验证应用程序开发阶段设定好的依赖关系在运行期是否完备，如有缺失那就直接启动失败，从而避免了很大一部分[1]由于类型依赖而引发的运行时异常。</p></li><li><p>可配置的封装隔离机制还解决了原来类路径上跨JAR文件的public类型的可访问性问题。JDK 9中的public类型不再意味着程序的所有地方的代码都可以随意访问到它们，模块提供了更精细的可访问性控制，必须明确声明其中哪一些public的类型可以被其他哪一些模块访问，这种访问控制也主要是在类加载过程中完成的。</p></li></ul><ol><li>模块兼容性</li></ol><p>模块化系统将按照以下规则来保证使用传统类路径依赖的Java程序可以不经修改地直接运行在JDK 9及以后的Java版本上：</p><ul><li>JAR文件在类路径的访问规则：所有类路径下的JAR文件及其他资源文件，都被视为自动打包在一个匿名模块（Unnamed Module）里，这个匿名模块几乎是没有任何隔离的，它可以看到和使用类路径上所有的包、JDK系统模块中所有的导出包，以及模块路径上所有模块中导出的包。</li><li>模块在模块路径的访问规则：模块路径下的具名模块（Named Module）只能访问到它依赖定义中列明依赖的模块和包，匿名模块里所有的内容对具名模块来说都是不可见的，即具名模块看不见传<br>统JAR包的内容。</li><li>JAR文件在模块路径的访问规则：如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个自动模块（Automatic Module）。尽管不包含module-info.class，但自动模块将默认依赖于整个模块路径中的所有模块，因此可以访问到所有模块导出的包，自动模块也默认导出自己所有的包。</li></ul><p>除了向后兼容性外，随着JDK 9模块化系统的引入，更值得关注的是它本身面临的模块间的管理和兼容性问题：如果同一个模块发行了多个不同的版本，那只能由开发者在编译打包时人工选择好正确版本的模块来保证依赖的正确性。</p><p>在JDK 9时加入Class文件格式的Module属性，里面有module_version_index这样的字段，用户可以在编译时使用“javac–module-version”来指定模块版本，在Java类库API中也存在java.lang.module.ModuleDescriptor.Version这样的接口可以在运行时获取到模块的版本号。</p><ol start="2"><li>模块化下的类加载器</li></ol><p>为了模块化系统的顺利施行，模块化下的类加载器仍然发生了一些应该被注意到变动，主要包括以下几个方面：</p><ul><li>扩展类加载器（Extension Class Loader）被平台类加载器（Platform Class Loader）取代</li><li>平台类加载器和应用程序类加载器都不再派生自java.net.URLClassLoader</li></ul><p>JDK 9中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载</p><p>三个类加载器负责各自加载的模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">启动类加载器负责加载的模块：</span><br><span class="line">java.base java.security.sasl</span><br><span class="line">java.datatransfer java.xml</span><br><span class="line">java.desktop jdk.httpserver</span><br><span class="line">java.instrument jdk.internal.vm.ci</span><br><span class="line">java.logging jdk.management</span><br><span class="line">java.management jdk.management.agent</span><br><span class="line">java.management.rmi jdk.naming.rmi</span><br><span class="line">java.naming jdk.net</span><br><span class="line">java.prefs jdk.sctp</span><br><span class="line">java.rmi jdk.unsupported</span><br><span class="line"></span><br><span class="line">平台类加载器负责加载的模块：</span><br><span class="line">java.activation* jdk.accessibility</span><br><span class="line">java.compiler* jdk.charsets</span><br><span class="line">java.corba* jdk.crypto.cryptoki</span><br><span class="line">java.scripting jdk.crypto.ec</span><br><span class="line">java.se jdk.dynalink</span><br><span class="line">java.se.ee jdk.incubator.httpclient</span><br><span class="line">java.security.jgss jdk.internal.vm.compiler*</span><br><span class="line">java.smartcardio jdk.jsobject</span><br><span class="line">java.sql jdk.localedata</span><br><span class="line">java.sql.rowset jdk.naming.dns</span><br><span class="line">java.transaction* jdk.scripting.nashorn</span><br><span class="line">java.xml.bind* jdk.security.auth</span><br><span class="line">java.xml.crypto jdk.security.jgss</span><br><span class="line">java.xml.ws* jdk.xml.dom</span><br><span class="line">java.xml.ws.annotation* jdk.zipfs</span><br><span class="line"></span><br><span class="line">应用程序类加载器负责加载的模块：</span><br><span class="line">jdk.aot jdk.jdeps</span><br><span class="line">jdk.attach jdk.jdi</span><br><span class="line">jdk.compiler jdk.jdwp.agent</span><br><span class="line">jdk.editpad jdk.jlink</span><br><span class="line">jdk.hotspot.agent jdk.jshell</span><br><span class="line">jdk.internal.ed jdk.jstatd</span><br><span class="line">jdk.internal.jvmstat jdk.pack</span><br><span class="line">jdk.internal.le jdk.policytool</span><br><span class="line">jdk.internal.opt jdk.rmic</span><br><span class="line">jdk.jartool jdk.scripting.nashorn.shell</span><br><span class="line">jdk.javadoc jdk.xml.bind*</span><br><span class="line">jdk.jcmd jdk.xml.ws*</span><br><span class="line">jdk.jconsole</span><br></pre></td></tr></table></figure><h1 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h1><blockquote><p><a href>深入理解Java虚拟机：JVM高级特性与最佳实践——虚拟机类加载机制</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、类加载的过程&quot;&gt;&lt;a href=&quot;#一、类加载的过程&quot; class=&quot;headerlink&quot; title=&quot;一、类加载的过程&quot;&gt;&lt;/a&gt;一、类加载的过程&lt;/h1&gt;&lt;p&gt;代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。在</summary>
      
    
    
    
    
    <category term="jdk" scheme="http://zws6672.top/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机——类文件结构</title>
    <link href="http://zws6672.top/2021/04/14/jdk-classesFileStruct/"/>
    <id>http://zws6672.top/2021/04/14/jdk-classesFileStruct/</id>
    <published>2021-04-14T15:19:18.000Z</published>
    <updated>2021-04-15T01:11:32.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Class文件结构"><a href="#一、Class文件结构" class="headerlink" title="一、Class文件结构"></a>一、Class文件结构</h1><p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。任何一个Class文件都对应着唯一的一个类或接口的定义信息，但是反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。</p><h3 id="无关性"><a href="#无关性" class="headerlink" title="无关性"></a>无关性</h3><p>Oracle公司以及其他虚拟机发行商发布过许多可以运行在各种不同硬件平台和操作系统上的Java虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写，到处运行”。</p><p>各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——字节码（Byte Code）是构成平台无关性的基石。但是，无关性不仅包括平台无关性，也包括了语言无关性。。但在Java技术发展之初，设计者们就曾经考虑过并实现了让其他语言运行在Java虚拟机之上的可能性，他们在发布规范文档的时候，也刻意把Java的规范拆分成了《Java语言规范》（The Java Language Specification）及《Java虚拟机规范》（The Java Virtual Machine Specification）两部分。时至今日，商业企业和开源机构已经在Java语言之外发展出一大批运行在Java虚拟机之上的语言，如Kotlin、Clojure、Groovy、JRuby、JPython、Scala等。</p><p>实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不与包括Java语言在内的任何程序语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集、符号表以及若干其他辅助信息。</p><h3 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h3><p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：</p><ul><li>无符号数：属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li>表：由多个无符号数或者其他表作为数据项构成的复合数据类型，习惯性地以“_info”结尾。</li></ul><p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的“集合”。</p><ol><li>魔数</li></ol><p>每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以随意改动。</p><ol start="2"><li>版本号和次版本号</li></ol><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。（高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件）</p><ol start="3"><li>常量池</li></ol><p>紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。</p><p>与Java中语言习惯不同，这个容量计数是从1而不是0开始的，如图6-3所示，常量池容量（偏移地址：0x00000008）为十六进制数0x0016，即十进制的22，这就代表常量池中有21项常量，索引值范围为1～21。而0表达“不引用任何一个常量池项目”的含义。Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始。</p><p>常量池中主要存放两大类常量：</p><ul><li>字面量（Literal）：接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等</li><li>符号引用（Symbolic References）<ul><li>被模块导出或者开放的包（Package）</li><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li><li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li><li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li></ul></li></ul><p>Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。</p><p>常量池中每一项常量都是一个表，最初常量表中共有11种结构各不相同的表结构数据，后来为了更好地支持动态语言调用，额外增加了4种动态语言相关的常量[1]，为了支持Java模块化系统（Jigsaw），又加入了CONSTANT_Module_info和CONSTANT_Package_info两个常量，所以截至JDK13，常量表中分别有17种不同类型的常量。</p><p>这17类表都有一个共同的特点，表结构起始的第一位是个u1类型的标志位，标志位的具体含义如下：</p><p><img src="/image/jdk/clc.png" alt="常量池"></p><p>17种数据类型的结构总表：</p><p><img src="/image/jdk/clc-type.png" alt="17种数据类型的结构总表"></p><p>在JDK的bin目录中，Oracle公司已经为我们准备好一个专门用于分析Class文件字节码的工具：javap。</p><ol start="4"><li>访问标志</li></ol><p>在常量池结束之后，紧接着的2个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final。访问标志细节如下：</p><p><img src="/image/jdk/clc-tag.png" alt="访问标志"></p><ol start="5"><li>类索引、父类索引与接口索引集合</li></ol><p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。</p><p>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中</p><p>对于接口索引集合，入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节</p><ol start="6"><li>字段表集合</li></ol><p>字段表（field_info）用于描述接口或者类中声明的变量。Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p><p>字段可以包括修饰符有字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。</p><p>跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。</p><p>对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava/lang/String；”，一个整型数组“int[]”将被记录成“[I”。用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。</p><p>字段表所包含的固定数据项目到descriptor_index为止就全部结束了，不过在descrip-tor_index之后跟随着一个属性表集合，用于存储一些额外的信息。</p><p><img src="/image/jdk/clc-field.png" alt="字段表集合"></p><ol start="7"><li>方法表集合</li></ol><p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。</p><p>因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对，synchronized、native、strictfp和abstract关键字可以修饰方法，方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志</p><p><img src="/image/jdk/clc-method-t.png" alt="方法表集合"></p><p>方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面。</p><p>在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名[2]。特征签名是指一个方法中各个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式之中，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。</p><ol start="8"><li>属性表集合</li></ol><p>属性表（attribute_info）在前面的讲解之中已经出现过数次，Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景的专有信息。</p><p>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。</p><p>对于每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。</p><p>8.1 Code属性（方法表）</p><p><img src="/image/jdk/sxb-code.png" alt="Code属性"></p><p>Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内</p><ul><li>attribute_name_index：指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”</li><li>attribute_length：指示了属性值的长度</li><li>max_stack：代表了操作数栈（Operand Stack）深度的最大值，虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。<ul><li>对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long这两种64位的数据类型则需要两个变量槽来存放。</li><li>max_locals的值不等于局部变量所占 变量槽 数量之和，因为局部变量超出作用域后，变量槽可以被其它局部变量使用。Javac编译器会根据变量的作用域来分配变量槽给各个变量使用，根据同时生存的最大局部变量数量和类型计算出max_locals的大小。</li></ul></li><li>max_locals：代表了局部变量表所需的存储空间，单位是变量槽（Slot）</li><li>code_length代表字节码长度</li><li>code是用于存储字节码指令的一系列字节流</li><li>显式异常处理表集合（异常表、try-catch-finally）：从第start_pc行[1]到第end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理。</li></ul><blockquote><p>《Java虚拟机规范》中明确要求Java语言的编译器应当选择使用异常表而不是通过跳转指令来实现Java异常及finally处理机制</p></blockquote><p>8.2 Exceptions属性</p><p>Exceptions属性是在方法表中与Code属性平级的一项属性，与异常表是不同的。Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。</p><ul><li>attribute_name_index：指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”</li><li>attribute_length：指示了属性值的长度</li><li>number_of_exceptions：表示方法可能抛出number_of_exceptions种受查异常</li><li>exception_index_table：受检查异常的列表</li></ul><p>8.3 LineNumberTable属性</p><p>LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系，它并不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：lines选项来取消或要求生成这项信息。</p><p><img src="/image/jdk/sxb-LineNumberTable.png" alt="LineNumberTable属性"></p><p>8.4 LocalVariableTable及LocalVariableTypeTable属性</p><p>LocalVariableTable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系，它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：vars选项来取消或要求生成这项信息。</p><p>LocalVariableTypeTable属性，使用字段的特征签名来完成泛型的描述。</p><p>8.5 SourceFile及SourceDebugExtension属性</p><p>SourceFile属性用于记录生成这个Class文件的源码文件名称。这个属性也是可选的，可以使用Javac的-g：none或-g：source选项来关闭或要求生成这项信息。在JDK 5时，新增了SourceDebugExtension属性用于存储额外的代码调试信息。</p><p>8.6 ConstantValue属性</p><p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才可以使用这项属性。对非static类型的变量（也就是实例变量）的赋值是在实例构造器<init>()方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器<clinit>()方法中或者使用ConstantValue属性。</clinit></init></p><p>目前Oracle公司实现的Javac编译器的选择是，如果同时使用final和static来修饰一个变量（按照习惯，这里称“常量”更贴切），并且这个变量的数据类型是基本类型或者java.lang.String的话，就将会生成ConstantValue属性来进行初始化；如果这个变量没有被final修饰，或者并非基本类型及字符串，则将会选择在<clinit>()方法中进行初始化。</clinit></p><p>8.7 InnerClasses属性</p><p>InnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。</p><p><img src="/image/jdk/sxb-InnerClasses.png" alt="InnerClasses属性"></p><p>8.8 Deprecated及Synthetic属性</p><p>Deprecated和Synthetic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。</p><ul><li>Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用“@deprecated”注解进行设置。</li><li>Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的，在JDK 5之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的ACC_SYNTHETIC标志位。</li></ul><p>8.9 StackMapTable属性</p><p>StackMapTable属性在JDK 6增加到Class文件规范之中，它是一个相当复杂的变长属性，位于Code属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用。</p><p>StackMapTable属性中包含零至多个栈映射帧（Stack Map Frame），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示执行到该字节码时局部变量表和操作数栈的验证类型。</p><p>8.10 Signature属性</p><p>任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variable）或参数化类型（ParameterizedType），则Signature属性会为它记录泛型签名信息</p><ul><li>parameterized types：参数化类型，对应ParameterizedType，带有类型参数的类型，即常说的泛型，如：List<t>、Map&lt;Integer, String&gt;、List&lt;? extends Number&gt;。</t></li><li>type variables：类型变量，对应TypeVariable<d>，如参数化类型中的E、K等类型变量，表示泛指任何类。</d></li></ul><p>8.11 BootstrapMethods属性和MethodParameters属性</p><p>BootstrapMethods属性在JDK 7时增加到Class文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokedynamic指令引用的引导方法限定符。<br>MethodParameters是在JDK 8时新加入到Class文件格式中的，它是一个用在方法表中的变长属性。MethodParameters的作用是记录方法的各个形参名称和信息</p><p>8.12 模块化相关属性</p><p>JDK 9的一个重量级功能是Java的模块化功能，因为模块描述文件（module-info.java）最终是要编译成一个独立的Class文件来存储的，所以，Class文件格式也扩展了Module、ModulePackages和ModuleMainClass三个属性用于支持Java模块化相关功能。</p><p><img src="/image/jdk/sxb-module-info.png" alt="模块化相关属性"></p><p>8.13 运行时注解相关属性</p><p>Java语言的语法提供了对注解（Annotation）的支持，增加了RuntimeVisibleAnnotations、RuntimeInvisibleAnnotations、RuntimeVisibleParameterAnnotations、RuntimeInvisibleParameter-Annotations、RuntimeVisibleTypeAnnotations和RuntimeInvisibleTypeAnnotations 几个属性。这六个属性不论结构还是功能都比较雷同，以RuntimeVisibleAnnotations为例。</p><p><img src="/image/jdk/sxb-Annotations.png" alt="运行时注解相关属性"></p><h1 id="二、字节码指令"><a href="#二、字节码指令" class="headerlink" title="二、字节码指令"></a>二、字节码指令</h1><p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成。由于Java虚拟机采用面向操作数栈而不是面向寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。</p><ul><li><p>缺点</p><ul><li>由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不能够超过256条。</li><li>Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机在处理那些超过一个字节的数据时，不得不在运行时从字节中重建出具体数据的结构，导致解释执行字节码时将损失一些性能。</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 譬如要将一个16位长度的无符号整数使用两个无符号字节存储起来</span><br><span class="line">(byte1 &lt;&lt; 8) | byte2</span><br></pre></td></tr></table></figure></li></ul></li><li><p>优点</p><ul><li>使用多个无符号字节存储长度超过一个字节的数据，放弃了操作数长度对齐，就意味着可以省略掉大量的填充和间隔符号。</li><li>编译代码短小精干，这是小数据量、高传输效率的设计。</li></ul></li></ul><h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><p>在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。例如，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。</p><p><img src="/image/jdk/zjm-lx.png" alt="字节码与数据类型"></p><p>大部分指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的对int类型作为运算类型（Computational Type）来进行的。</p><blockquote><p>注：i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference</p></blockquote><ol><li>加载和存储指令</li></ol><p>用于将数据在栈帧中的局部变量表和操作数栈之间传输</p><ul><li>将一个局部变量加载到操作栈：iload、iload_<n>、lload、lload_<n>、fload、fload_<n>、dload、dload_<n>、aload、aload_<n></n></n></n></n></n></li><li>将一个数值从操作数栈存储到局部变量表：istore、istore_<n>、lstore、lstore_<n>、fstore、fstore_<n>、dstore、dstore_<n>、astore、astore_<n></n></n></n></n></n></li><li>将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_<i>、lconst_<l>、fconst_<f>、dconst_<d></d></f></l></i></li><li>扩充局部变量表的访问索引的指令：wide</li></ul><ol start="2"><li>运算指令</li></ol><p>用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶</p><ul><li>加法指令：iadd、ladd、fadd、dadd</li><li>减法指令：isub、lsub、fsub、dsub</li><li>乘法指令：imul、lmul、fmul、dmul</li><li>除法指令：idiv、ldiv、fdiv、ddiv</li><li>求余指令：irem、lrem、frem、drem</li><li>取反指令：ineg、lneg、fneg、dneg</li><li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr</li><li>按位或指令：ior、lor</li><li>按位与指令：iand、land</li><li>按位异或指令：ixor、lxor</li><li>局部变量自增指令：iinc</li><li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp</li></ul><ol start="3"><li>类型转换指令</li></ol><p>可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p><p>Java虚拟机直接支持（即转换时无须显式的转换指令）以下数值类型的宽化类型转换（Widening Numeric Conversion，即小范围类型向大范围类型的安全转换）：</p><ul><li>int类型到long、float或者double类型</li><li>long类型到float、double类型</li><li>float类型到double类型</li></ul><p>处理窄化类型转换（Narrowing Numeric Conversion）时，就必须显式地使用转换指令来完成，这些转换指令包括i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。</p><ol start="4"><li>对象创建与访问指令</li></ol><p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令（在下一章会讲到数组和普通类的类型创建过程是不同的）。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：</p><ul><li>创建类实例的指令：new</li><li>创建数组的指令：newarray、anewarray、multianewarray</li><li>访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic</li><li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、aload、aaload</li><li>将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、astore、aastore</li><li>取数组长度的指令：arraylength</li><li>检查类实例类型的指令：instanceof、checkcast</li></ul><ol start="5"><li>操作数栈管理指令</li></ol><p>Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：</p><ul><li>将操作数栈的栈顶一个或两个元素出栈：pop、pop2</li><li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、up2_x1、dup_x2、dup2_x2</li><li>将栈最顶端的两个数值互换：swap</li></ul><ol start="6"><li>控制转移指令</li></ol><p>控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存器的值。控制转移指令包括：</p><ul><li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、f_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne</li><li>复合条件分支：tableswitch、lookupswitch</li><li>无条件分支：goto、goto_w、jsr、jsr_w、ret</li></ul><ol start="6"><li>方法调用和返回指令</li></ol><ul><li>invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），也是Java语言中最常见的方法分派方式。</li><li>invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找适合的方法进行调用。</li><li>invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和类方法。</li><li>invokestatic指令：用于调用类静态方法（static方法）。</li><li>invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li></ul><ol start="7"><li>异常处理指令</li></ol><p>在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语句显式抛出异常的情况之外。而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的而是采用异常表来完成。</p><ol start="8"><li>同步指令</li></ol><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。</p><p>方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。</p><p>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持。</p><blockquote><p>注：指令助记符以尖括号结尾（例如iload_<n>），这些指令助记符实际上代表了一组指令（例如iload_<n>，它代表了iload_0、iload_1、iload_2和iload_3这几条指令）。这几组指令都是某个带有一个操作数的通用指令（例如iload）的特殊形式，对于这几组特殊指令，它们省略掉了显式的操作数，不需要进行取操作数的动作，因为实际上操作数就隐含在指令中</n></n></p></blockquote><h3 id="公有设计，私有实现"><a href="#公有设计，私有实现" class="headerlink" title="公有设计，私有实现"></a>公有设计，私有实现</h3><p>《Java虚拟机规范》描绘了Java虚拟机应有的共同程序存储格式：Class文件格式以及字节码指令集。</p><p>虚拟机实现者可以使用这种伸缩性来让Java虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性，选择哪种特性取决于Java虚拟机实现的目标和关注点是什么，虚拟机实现的方式主要有以下两种：</p><ul><li>将输入的Java虚拟机代码在加载时或执行时翻译成另一种虚拟机的指令集</li><li>将输入的Java虚拟机代码在加载时或执行时翻译成宿主机处理程序的本地指令集（即即时编译器代码生成技术）。</li></ul><h1 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h1><blockquote><p><a href>深入理解Java虚拟机：JVM高级特性与最佳实践（第3版） ————虚拟机执行部分————类文件结构</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Class文件结构&quot;&gt;&lt;a href=&quot;#一、Class文件结构&quot; class=&quot;headerlink&quot; title=&quot;一、Class文件结构&quot;&gt;&lt;/a&gt;一、Class文件结构&lt;/h1&gt;&lt;p&gt;Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格</summary>
      
    
    
    
    
    <category term="jdk" scheme="http://zws6672.top/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 使用 AOP（面向切面编程）</title>
    <link href="http://zws6672.top/2021/04/04/springboot-aop/"/>
    <id>http://zws6672.top/2021/04/04/springboot-aop/</id>
    <published>2021-04-04T13:44:37.000Z</published>
    <updated>2021-04-06T03:05:22.651Z</updated>
    
    <content type="html"><![CDATA[<p>AOP （Aspect Orient Programming）,译为 面向切面编程，AOP 是一种编程思想，是面向对象编程（OOP）的一种补充。</p><h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p>面向切面编程实现了横切关注点的模块化，即多应用对象相同的处理逻辑被抽象为模块。在多个模块中，如果存在重复的代码，我们可以通过将该代码段抽取成特定的方法使用。但是，如果有新的需求，又需要重复增加新的方法。这时，我们可以通过AOP在不修改源码的情况下，为系统的多个组件添加相同的功能。</p><ol><li>分类</li></ol><p>AOP可以分为两类：</p><ul><li>静态 AOP 实现：代理类和被代理的类实现了同样的接口，代理类同时持有被代理类的引用，通过该引用代理类可以调用被代理类的方法</li><li>动态 AOP 实现： AOP 框架在运行阶段动态生成代理对象<ul><li>JDK 动态代理：利用反射机制生成一个实现代理接口的类，在调用具体方法前调用InvokeHandler来处理；针对实现接口的类生成代理。</li><li>CGlib 动态代理：利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理；针对类实现代理，不能代理final修饰的类。</li></ul></li></ul><ol start="2"><li>实现</li></ol><p>AOP 实现的比较：<br><img src="/image/ssm/aop.png" alt="AOP 实现"></p><ol start="3"><li>术语</li></ol><ul><li>连接点（Joinpoint）：程序执行的某个特定位置，如类开始初始化前、类初始化后、类某个方法调用前、调用后、方法抛出异常后。一个类或一段程序代码拥有一些具有边界性质的特定点，这些点中的特定点就称为“连接点”。Spring仅支持方法的连接点，即仅能在方法调用前、方法调用后、方法抛出异常时以及方法调用前后这些程序执行点织入增强</li><li>切点（Pointcut）：每个程序都可以拥有多个连接点，而AOP通过切点查询连接点。切点与连接点的关系是一对多的关系。在Spring中，切点通过org.springframework.aop.Pointcut接口进行描述，它使用类和方法作为连接点的查询条件，Spring AOP的规则解析引擎负责切点所设定的查询条件，找到对应的连接点。</li><li>增强（Advice）；增强是织入到目标类连接点上的一段程序代码，在Spring中，增强除用于描述一段程序代码外，还拥有另一个和连接点相关的信息，这便是执行点的方位。结合执行点方位信息和切点信息，我们就可以找到特定的连接点</li><li>目标对象（Target）：    增强逻辑的织入目标类。如果没有AOP，目标业务类需要自己实现所有逻辑，而在AOP的帮助下，目标业务类只实现那些非横切逻辑的程序逻辑，而性能监视和事务管理等这些横切逻辑则可以使用AOP动态织入到特定的连接点上。</li><li>引介（Introduction）：引介是一种特殊的增强，它为类添加一些属性和方法</li><li>织入（Weaving）：织入是将增强添加对目标类具体连接点上的过程；织入方式如下：<ul><li>编译期织入，这要求使用特殊的Java编译器。</li><li>类装载期织入，这要求使用特殊的类装载器。</li><li>动态代理织入，在运行期为目标类添加增强生成子类的方式。（Spring采用的方式）</li></ul></li><li>切面（Aspect）：切面由切点和增强（引介）组成，它既包括了横切逻辑的定义，也包括了连接点的定义，Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。</li></ul><p>通知（Advice）类型：</p><ul><li>前置通知（Before advice）：在某连接点（JoinPoint）之前执行的通知，但这个通知不能阻止连接点前的执行</li><li>后置通知（After advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）</li><li>返回后通知（After return advice）：在某连接点正常完成后执行的通知，不包括抛出异常的情况</li><li>环绕通知（Around advice）：包围一个连接点的通知，类似Web中Servlet规范中的Filter的doFilter方法。可以在方法的调用前后完成自定义的行为，也可以选择不执行</li><li>抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知</li></ul><h1 id="二、JDK-动态代理"><a href="#二、JDK-动态代理" class="headerlink" title="二、JDK 动态代理"></a>二、JDK 动态代理</h1><p>Java动态代理类位于java.lang.reflect包下，是使用InvocationHandler和Proxy实现的。</p><ol><li>InvocationHandler</li></ol><p>InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法。 相关源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Object proxy 代理类</span><br><span class="line">// Method method 被代理的方法</span><br><span class="line">// Object[] args 方法的参数数组</span><br><span class="line">public interface InvocationHandler &#123;</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">        throws Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个接口，我们可以实现一个处理器，提供给代理类使用。</p><ol start="2"><li>Proxy</li></ol><p>Proxy类就是用来创建一个代理对象的类，一般通过 newProxyInstance 方法来生成对应类的代理类。</p><p>相关源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 返回代理类的一个实例，返回后的代理类可以当作被代理类使用(可使用被代理类的在接口中声明过的方法)</span><br><span class="line">// loader：classloader对象，定义了由哪个类加载器对象对生成的代理类进行加载</span><br><span class="line">// interfaces：接口数组，表示为代理对象提供的数组</span><br><span class="line">// h：InvocationHandler对象，表示的是当动态代理对象调用方法的时候会关联到哪一个InvocationHandler对象上，并最终由其调用</span><br><span class="line"></span><br><span class="line">@CallerSensitive</span><br><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">  Class&lt;?&gt;[] interfaces,</span><br><span class="line">  InvocationHandler h)</span><br></pre></td></tr></table></figure><ol start="3"><li>实例</li></ol><p>对应步骤如下：</p><ul><li>创建一个实现接口InvocationHandler的类，它必须实现invoke方法</li><li>创建被代理的类以及接口</li><li>通过Proxy的静态方法newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)创建一个代理</li><li>通过代理调用方法</li></ul><p>对应实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/4/3 23:16</span><br><span class="line"> * @Description JDK 代理模式</span><br><span class="line"> */</span><br><span class="line">public class JdkProxy &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        Weapon realWeapon = new Gun();</span><br><span class="line">        InvocationHandler handler = new MyInvocationHandler(realWeapon);</span><br><span class="line">        ClassLoader classLoader = realWeapon.getClass().getClassLoader();</span><br><span class="line">        Class[] clazz = realWeapon.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line">        Weapon weapon = (Weapon) Proxy.newProxyInstance(classLoader, clazz, handler);</span><br><span class="line">        System.out.println(realWeapon);</span><br><span class="line">        System.out.println(weapon);</span><br><span class="line"></span><br><span class="line">        weapon.description();</span><br><span class="line">        weapon.use();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用处理器实现类</span><br><span class="line">class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    private Object weapon;</span><br><span class="line"></span><br><span class="line">    public MyInvocationHandler(Object weapon) &#123;</span><br><span class="line">        this.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;在调用实际对象前，实现附加功能&quot;);</span><br><span class="line">        Object res = method.invoke(weapon, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;在调用实际对象后，实现附加功能&quot;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 动态代理的接口</span><br><span class="line">interface Weapon &#123;</span><br><span class="line">    void use();</span><br><span class="line">    void description();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代理的实际对象</span><br><span class="line">class Gun implements Weapon &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void use() &#123;</span><br><span class="line">        System.out.println(&quot;use gun&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void description() &#123;</span><br><span class="line">        System.out.println(&quot;This is a gun&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、CGlib-动态代理"><a href="#三、CGlib-动态代理" class="headerlink" title="三、CGlib 动态代理"></a>三、CGlib 动态代理</h1><ol><li>Enhancer</li></ol><p>我们需要使用setSuperclass方法设置父类(可以是接口或者是自定义类)，相关源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void setSuperclass(Class superclass) &#123;</span><br><span class="line">// 当传入的参数为接口。</span><br><span class="line">// Enhancer允许为非接口类型创建一个Java代理。Enhancer动态创建了给定类型的子类但是拦截了所有的方法。和Proxy不一样的是，不管是接口还是类他都能正常工作。</span><br><span class="line">if (superclass != null &amp;&amp; superclass.isInterface()) &#123;</span><br><span class="line">this.setInterfaces(new Class[]&#123;superclass&#125;);</span><br><span class="line">this.setContextClass(superclass);</span><br><span class="line">&#125; else if (superclass != null &amp;&amp; superclass.equals(Object.class)) &#123;</span><br><span class="line">// 当传入的参数为Object类</span><br><span class="line">this.superclass = null;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 当传入的是自定义类</span><br><span class="line">this.superclass = superclass;</span><br><span class="line">this.setContextClass(superclass);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过create方法可以创建对应的类，其实是调用另外一个私有的方法createHelper，相关源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//用于创建类</span><br><span class="line">public Object create() &#123;</span><br><span class="line">this.classOnly = false;</span><br><span class="line">this.argumentTypes = null;</span><br><span class="line">return this.createHelper();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// </span><br><span class="line">private Object createHelper() &#123;</span><br><span class="line">// 验证是否配置回调类型，验证过滤器是否为空</span><br><span class="line">        this.preValidate();</span><br><span class="line"></span><br><span class="line">        Object key = KEY_FACTORY.newInstance(this.superclass != null ? this.superclass.getName() : null, ReflectUtils.getNames(this.interfaces), this.filter == ALL_ZERO ? null : new WeakCacheKey(this.filter), this.callbackTypes, this.useFactory, this.interceptDuringConstruction, this.serialVersionUID);</span><br><span class="line">        this.currentKey = key;</span><br><span class="line">        Object result = super.create(key);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 静态代理工厂，用于创建类</span><br><span class="line">private static final Enhancer.EnhancerKey KEY_FACTORY;</span><br><span class="line"></span><br><span class="line">// 提供一个创建类的接口</span><br><span class="line">public interface EnhancerKey &#123;</span><br><span class="line">// String var1 被代理的类名</span><br><span class="line">// String[] var2 被代理的接口名</span><br><span class="line">// WeakCacheKey&lt;CallbackFilter&gt; var3 回调过滤器</span><br><span class="line">// Type[] var4 过滤器接口</span><br><span class="line">// boolean var5 使用工厂</span><br><span class="line">// boolean var6 使用构造器拦截器</span><br><span class="line">// Long var7 serialVersionUID 序列化ID</span><br><span class="line">Object newInstance(String var1, String[] var2, WeakCacheKey&lt;CallbackFilter&gt; var3, Type[] var4, boolean var5, boolean var6, Long var7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>实例</li></ol><p>对应实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/4/4 14:48</span><br><span class="line"> * @Description CGLIB 动态代理</span><br><span class="line"> */</span><br><span class="line">public class CGlibProxy &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">//  Enhancer是CGLIB的字节码增强器，可以很方便的对类进行拓展</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">//设置被代理的类</span><br><span class="line">        enhancer.setSuperclass(Hello.class);</span><br><span class="line">//        设置过滤器</span><br><span class="line">        enhancer.setCallback(new HelloMethodInterceptor());</span><br><span class="line">//        通过enhancer创建对象</span><br><span class="line">        Hello hello = (Hello) enhancer.create();</span><br><span class="line">        hello.ha();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Hello &#123;</span><br><span class="line">    void ha() &#123;</span><br><span class="line">        System.out.println(&quot;Hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HelloMethodInterceptor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;调用&quot;+method.getName()+&quot;方法前输出&quot;);</span><br><span class="line">        Object o1 = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(&quot;调用&quot;+method.getName()+&quot;方法后输出&quot;);</span><br><span class="line">        return o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CGLIB中，方法的调用并不是通过反射来完成的，而是直接对方法进行调用：FastClass对Class对象进行特别的处理，比如将会用数组保存method的引用，每次调用方法的时候都是通过一个index下标来保持对方法的引用，因此比JDK 动态代理速度快。但是，CGLIB无法代理被final修饰的方法。</p><ol start="3"><li>FastClass机制</li></ol><p>Cglib动态代理执行代理方法效率之所以比JDK的高是因为Cglib采用了FastClass机制，它的原理简单来说就是：为代理类和被代理类各生成一个Class，这个Class会为代理类或被代理类的方法分配一个index(int类型)。这个index当做一个入参，FastClass就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比JDK动态代理通过反射调用高。</p><h1 id="四、SpringBoot-使用-AOP"><a href="#四、SpringBoot-使用-AOP" class="headerlink" title="四、SpringBoot 使用 AOP"></a>四、SpringBoot 使用 AOP</h1><ol><li>AOP标准</li></ol><p>AOP联盟标准：<br><img src="/image/ssm/aop-gf.png" alt="AOP 规范"></p><p>AOP 实现方式有很多种，包括反射、元数据处理、程序处理、拦截器处理等。而Spring AOP的实现使用的是Java语言本身的特性，即Java Proxy代理类、拦截器技术实现。</p><p>Springboot使用 aop 可以通过maven引入相应包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  springboot web 模块 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--  aop--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>PCD</li></ol><p>PCD(pointcut designators )就是SpringAOP的切点表达式。SpringAOP的PCD是完全兼容AspectJ的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">语法格式如下：</span><br><span class="line">execution(&lt;修饰符模式&gt;? &lt;返回类型模式&gt; &lt;方法名模式&gt;(&lt;参数模式&gt;) &lt;异常模式&gt;?)</span><br><span class="line"></span><br><span class="line">除了返回类型模式、方法名模式和参数模式外，其它项都是可选的。</span><br><span class="line"></span><br><span class="line">-- 所有公有方法的执行</span><br><span class="line">execution(public * *(..))</span><br><span class="line"></span><br><span class="line">-- 设置指定格式开头的方法</span><br><span class="line">execution(* test*(..))</span><br><span class="line"></span><br><span class="line">-- AccountService接口下的所有方法的执行</span><br><span class="line">execution(* com.service.AccountService.*(..))</span><br><span class="line"></span><br><span class="line">-- 匹配com.xyz.service包下的所有类的所有方法（不含子包）</span><br><span class="line">within(com.xyz.service.*)</span><br></pre></td></tr></table></figure><ol start="3"><li>aop 实例：拦截控制器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/4/4 16:52</span><br><span class="line"> * @Description 控制器切面</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class ControllerAop &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 指定切点</span><br><span class="line">     * 匹配 com.wsz.tool.rabbitmq.controller包及其子包下的所有类的所有方法</span><br><span class="line">     */</span><br><span class="line">//    @Pointcut(&quot;execution(public * com.wsz.tool.rabbitmq.controller..*.*(..))&quot;)</span><br><span class="line">    @Pointcut(&quot;execution(public * com.wsz.tool.rabbitmq.controller.*Controller.*(..))&quot;)</span><br><span class="line">    public void log() &#123;</span><br><span class="line">        System.out.println(&quot;日志输出：&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;log()&quot;)</span><br><span class="line">    public void doBefore(JoinPoint joinPoint) &#123;</span><br><span class="line">        System.out.println(&quot;前置通知&quot;);</span><br><span class="line">//        目标方法的参数信息</span><br><span class="line">        Object[] objects = joinPoint.getArgs();</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line"></span><br><span class="line">//        代理方法名</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;代理方法名：&quot;+signature.getName());</span><br><span class="line">        System.out.println(&quot;代理类名：&quot;+signature.getDeclaringTypeName());</span><br><span class="line">        signature.getDeclaringType();</span><br><span class="line">        MethodSignature ms = (MethodSignature) signature;</span><br><span class="line">        System.out.println(&quot;参数名：&quot;+ Arrays.toString(ms.getParameterNames()));</span><br><span class="line">        System.out.println(&quot;参数值：&quot;+ Arrays.toString(joinPoint.getArgs()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 接收到请求，记录请求内容</span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest req = attributes.getRequest();</span><br><span class="line">        // 记录下请求内容</span><br><span class="line">        System.out.println(&quot;请求URL : &quot; + req.getRequestURL().toString());</span><br><span class="line">        System.out.println(&quot;HTTP_METHOD : &quot; + req.getMethod());</span><br><span class="line">        System.out.println(&quot;IP : &quot; + req.getRemoteAddr());</span><br><span class="line">        System.out.println(&quot;CLASS_METHOD : &quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    后置异常通知</span><br><span class="line">    @AfterThrowing(&quot;log()&quot;)</span><br><span class="line">    public void throwss(JoinPoint jp) &#123;</span><br><span class="line">        System.out.println(&quot;异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @After(&quot;log()&quot;)</span><br><span class="line">    public void after (JoinPoint jp) &#123;</span><br><span class="line">        System.out.println(&quot;后置通知&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>aop实例：拦截自定义注解</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/4/4 20:12</span><br><span class="line"> * @Description 自定义Log注解</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">*注解的作用目标：</span><br><span class="line">*　@Target(ElementType.TYPE)                      // 接口、类、枚举、注解</span><br><span class="line">*　@Target(ElementType.FIELD)                     // 字段、枚举的常量</span><br><span class="line">*　@Target(ElementType.METHOD)                 // 方法</span><br><span class="line">*  @Target(ElementType.PARAMETER)            // 方法参数</span><br><span class="line">*　@Target(ElementType.CONSTRUCTOR)       // 构造函数</span><br><span class="line">*　@Target(ElementType.LOCAL_VARIABLE)   // 局部变量</span><br><span class="line">*　@Target(ElementType.ANNOTATION_TYPE) // 注解</span><br><span class="line">*　@Target(ElementType.PACKAGE)               // 包</span><br><span class="line">*/</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Documented</span><br><span class="line">public @interface MyLog &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/4/4 20:20</span><br><span class="line"> * @Description 自定义注解使用</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class TestService &#123;</span><br><span class="line"></span><br><span class="line">    @MyLog(&quot;TestService&quot;)</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        System.out.println(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/4/4 20:13</span><br><span class="line"> * @Description AOP拦截自定义注解</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class MyLogAop &#123;</span><br><span class="line">    @Pointcut(&quot;execution(public * com.wsz.tool.rabbitmq.aop.MyLog.*(..))&quot;)</span><br><span class="line">    public void log() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * @Pointcut与@Around的区别：@Pointcut与@Around可以使用相同的PCD表达式，@Pointcut定义的可以重复使用，而@Around不可以</span><br><span class="line">     */</span><br><span class="line"> </span><br><span class="line">    @Around(value = &quot;@annotation(com.wsz.tool.rabbitmq.aop.MyLog)&quot;)</span><br><span class="line">    public void before(JoinPoint point) &#123;</span><br><span class="line">        System.out.println(&quot;MyLogAop前置通知&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>aop实例：日志<br><a href="https://github.com/xkcoding/spring-boot-demo/tree/master/demo-log-aop" target="_blank" rel="noopener">aop切面日志新增json参数打印和高并发场景</a></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class AopLog &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 切入点</span><br><span class="line">     */</span><br><span class="line">    @Pointcut(&quot;execution(public * com.xkcoding.log.aop.controller.*Controller.*(..))&quot;)</span><br><span class="line">    public void log() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 环绕操作</span><br><span class="line">     *</span><br><span class="line">     * @param point 切入点</span><br><span class="line">     * @return 原方法返回值</span><br><span class="line">     * @throws Throwable 异常信息</span><br><span class="line">     */</span><br><span class="line">    @Around(&quot;log()&quot;)</span><br><span class="line">    public Object aroundLog(ProceedingJoinPoint point) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">        // 开始打印请求日志</span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = Objects.requireNonNull(attributes).getRequest();</span><br><span class="line"></span><br><span class="line">        // 打印请求相关参数</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        Object result = point.proceed();</span><br><span class="line">        String header = request.getHeader(&quot;User-Agent&quot;);</span><br><span class="line">        UserAgent userAgent = UserAgent.parseUserAgentString(header);</span><br><span class="line"></span><br><span class="line">        final Log l = Log.builder()</span><br><span class="line">            .threadId(Long.toString(Thread.currentThread().getId()))</span><br><span class="line">            .threadName(Thread.currentThread().getName())</span><br><span class="line">            .ip(getIp(request))</span><br><span class="line">            .url(request.getRequestURL().toString())</span><br><span class="line">            .classMethod(String.format(&quot;%s.%s&quot;, point.getSignature().getDeclaringTypeName(),</span><br><span class="line">                point.getSignature().getName()))</span><br><span class="line">            .httpMethod(request.getMethod())</span><br><span class="line">            .requestParams(getNameAndValue(point))</span><br><span class="line">            .result(result)</span><br><span class="line">            .timeCost(System.currentTimeMillis() - startTime)</span><br><span class="line">            .userAgent(header)</span><br><span class="line">            .browser(userAgent.getBrowser().toString())</span><br><span class="line">            .os(userAgent.getOperatingSystem().toString()).build();</span><br><span class="line"></span><br><span class="line">        log.info(&quot;Request Log Info : &#123;&#125;&quot;, JSONUtil.toJsonStr(l));</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  获取方法参数名和参数值</span><br><span class="line">     * @param joinPoint</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Map&lt;String, Object&gt; getNameAndValue(ProceedingJoinPoint joinPoint) &#123;</span><br><span class="line"></span><br><span class="line">        final Signature signature = joinPoint.getSignature();</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">        final String[] names = methodSignature.getParameterNames();</span><br><span class="line">        final Object[] args = joinPoint.getArgs();</span><br><span class="line"></span><br><span class="line">        if (ArrayUtil.isEmpty(names) || ArrayUtil.isEmpty(args)) &#123;</span><br><span class="line">            return Collections.emptyMap();</span><br><span class="line">        &#125;</span><br><span class="line">        if (names.length != args.length) &#123;</span><br><span class="line">            log.warn(&quot;&#123;&#125;方法参数名和参数值数量不一致&quot;, methodSignature.getName());</span><br><span class="line">            return Collections.emptyMap();</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Object&gt; map = Maps.newHashMap();</span><br><span class="line">        for (int i = 0; i &lt; names.length; i++) &#123;</span><br><span class="line">            map.put(names[i], args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final String UNKNOWN = &quot;unknown&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取ip地址</span><br><span class="line">     */</span><br><span class="line">    public static String getIp(HttpServletRequest request) &#123;</span><br><span class="line">        String ip = request.getHeader(&quot;x-forwarded-for&quot;);</span><br><span class="line">        if (ip == null || ip.length() == 0 || UNKNOWN.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || UNKNOWN.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || UNKNOWN.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line">        String comma = &quot;,&quot;;</span><br><span class="line">        String localhost = &quot;127.0.0.1&quot;;</span><br><span class="line">        if (ip.contains(comma)) &#123;</span><br><span class="line">            ip = ip.split(&quot;,&quot;)[0];</span><br><span class="line">        &#125;</span><br><span class="line">        if (localhost.equals(ip)) &#123;</span><br><span class="line">            // 获取本机真正的ip地址</span><br><span class="line">            try &#123;</span><br><span class="line">                ip = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">                log.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Data</span><br><span class="line">    @Builder</span><br><span class="line">    @NoArgsConstructor</span><br><span class="line">    @AllArgsConstructor</span><br><span class="line">    static class Log &#123;</span><br><span class="line">        // 线程id</span><br><span class="line">        private String threadId;</span><br><span class="line">        // 线程名称</span><br><span class="line">        private String threadName;</span><br><span class="line">        // ip</span><br><span class="line">        private String ip;</span><br><span class="line">        // url</span><br><span class="line">        private String url;</span><br><span class="line">        // http方法 GET POST PUT DELETE PATCH</span><br><span class="line">        private String httpMethod;</span><br><span class="line">        // 类方法</span><br><span class="line">        private String classMethod;</span><br><span class="line">        // 请求参数</span><br><span class="line">        private Object requestParams;</span><br><span class="line">        // 返回参数</span><br><span class="line">        private Object result;</span><br><span class="line">        // 接口耗时</span><br><span class="line">        private Long timeCost;</span><br><span class="line">        // 操作系统</span><br><span class="line">        private String os;</span><br><span class="line">        // 浏览器</span><br><span class="line">        private String browser;</span><br><span class="line">        // user-agent</span><br><span class="line">        private String userAgent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>如下代码，<code>@Transactional</code>有没有生效？</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class OrderService &#123;</span><br><span class="line"> </span><br><span class="line">private void insert() &#123;</span><br><span class="line">insertOrder();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Transactional</span><br><span class="line">public void insertOrder() &#123;</span><br><span class="line">//SQL操作</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有，<code>@Transactional</code>底层基于AOP实现，自身调用是无法生效的。因为在 Spring 的 AOP 代理下，只有目标方法由外部调用，目标方法才由 Spring 生成的代理对象来管理，这会造成自调用问题。insert()是由被代理对象调用的，而它内调的方法insertOrder() 就不会由代理对象调用，也就无法被添加事务。</p><h1 id="五、参考文章"><a href="#五、参考文章" class="headerlink" title="五、参考文章"></a>五、参考文章</h1><blockquote><p><a href="https://www.cnblogs.com/joy99/p/10941543.html" target="_blank" rel="noopener">Spring AOP——Spring 中面向切面编程</a><br><a href="https://blog.csdn.net/wyl6019/article/details/80136000" target="_blank" rel="noopener">Spring AOP实现原理简介</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;AOP （Aspect Orient Programming）,译为 面向切面编程，AOP 是一种编程思想，是面向对象编程（OOP）的一种补充。&lt;/p&gt;
&lt;h1 id=&quot;一、基础&quot;&gt;&lt;a href=&quot;#一、基础&quot; class=&quot;headerlink&quot; title=&quot;一、基础</summary>
      
    
    
    
    
    <category term="springboot" scheme="http://zws6672.top/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>mysql 引擎的行锁与表锁</title>
    <link href="http://zws6672.top/2021/03/30/mysql-lock/"/>
    <id>http://zws6672.top/2021/03/30/mysql-lock/</id>
    <published>2021-03-30T15:47:49.000Z</published>
    <updated>2021-03-30T15:48:50.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务基础"><a href="#事务基础" class="headerlink" title="事务基础"></a>事务基础</h1><ol><li>ACID属性</li></ol><ul><li>原子性：事务不可分</li><li>一致性：在事务开始和完成时，数据都必须保持一致状态。</li><li>隔离性：并发的事务是相互隔离的。</li><li>持久性：事务完成之后，它对于数据的修改是永久性的</li></ul><ol start="2"><li>并发事务的问题</li></ol><ul><li>更新丢失：多事务进行更新，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题最后的更 新覆盖了由其他事务所做的更新</li><li>脏读：事务在提交前，数据的修改可以被其它事务读取</li><li>不可重复读：同一个事务中前后两次读取的数据不一致</li><li>幻读：同一个事务中前后两次读取数据时，其他事务插入了满足其查询条件的新数据，导致读取的数据量不一致</li></ul><ol start="3"><li>事务隔离级别</li></ol><ul><li>未提交读（Read uncommitted）：读数据一致性</li><li>已提交读（Read committed）：不会导致脏读（语句级）</li><li>可重复读（Repeatable read）：不会导致不可重复读（事务级）</li><li>可序列化（Serializable）：不会导致幻读（事务级）</li></ul><h1 id="行锁和表锁"><a href="#行锁和表锁" class="headerlink" title="行锁和表锁"></a>行锁和表锁</h1><p>在mysql 的 InnoDB引擎支持行锁，与Oracle不同，mysql的行锁是通过索引加载的，即是行锁是加在索引响应的行上的。如果SQL语句没有走索引，那么就无法触发行锁，而是会使用表锁。</p><ul><li>表锁：不会出现死锁，发生锁冲突几率高，并发低。</li><li>行锁：会出现死锁，发生锁冲突几率低，并发高。</li></ul><ol><li>锁分类</li></ol><ul><li>共享锁：读锁。当一个事务对某几行上读锁时，允许其他事务对这几行进行读操作，但不允许其进行写操作，也不允许其他事务给这几行上排它锁，但允许上读锁</li><li>排它锁：写锁，当一个事务对某几个上写锁时，不允许其他事务写，但允许读；更不允许其他事务给这几行上任何锁（包括写锁）</li></ul><ol start="2"><li>要点</li></ol><ul><li>行锁必须有索引才能实现，否则会自动锁全表</li><li>两个事务不能锁同一个索引</li><li>语句涉及锁<ul><li>insert、delete、update在事务中都会自动默认加上排它锁</li><li>普通SELECT语句，InnoDB不会加任何锁</li><li>在insert操作时产生插入意向锁（不是意向锁）；在多事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等待</li><li>表级锁还有一种比较特殊的锁：AUTO-INC Locks；这种锁只在向自增主键中插入记录时出现，这种锁是为自增主键设计的。锁机制如下：在向自增主键中插入记录时，其他insert事务都需要等待直到本事务的插入完成才能继续插入自增记录。</li></ul></li><li>索引分为主键索引和非主键索引，如果SQL语句走主键索引MySQL会锁住该索引；如果SQL语句走普通索引，那么会锁住该普通索引，再锁住主键索引</li></ul><ol start="3"><li>遇到的问题</li></ol><ul><li>死锁：如果两事务同时执行，事务A锁住主键索引，等待非主键索引；然后事务B锁住非主键索引，等待主键索引；那么就会陷入死锁。</li><li>锁冲突：锁不相容，如读锁和写锁</li></ul><ol start="4"><li>处理锁冲突（意向锁）</li></ol><p>MySQL 为了解决锁冲突，引入了 意向锁。意向锁就是一种不与行级锁冲突的表级锁，分类如下：</p><ul><li>意向共享锁 （intention shared lock, IS）：事务有意向对表中的某些行加 共享锁（S锁）</li><li>意向排他锁 （intention exclusive lock, IX）：事务有意向对表中的某些行加 排他锁 （X锁）</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 意向共享锁 IS</span><br><span class="line">SELECT column FROM table ... LOCK IN SHARE MODE;</span><br><span class="line">-- 意向排他锁 IX</span><br><span class="line">SELECT column FROM table ... FOR UPDATE;</span><br></pre></td></tr></table></figure><p>意向锁由数据引擎自己维护的，在为数据行加共享/排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</p><p>模拟业务场景如下：</p><ul><li>事务A查询数据，在涉及的行上加共享锁（行锁）之前，会先加意向共享锁（表锁）。</li><li>如果事务B要添加数据，需要加排他锁；<ul><li>如果没有意向锁，那么需要检测每一行，效率低下；</li><li>有了意向锁后，发现有意向锁则表示：有其他事务有意向对表中的某些行加共享锁（S锁）；</li><li>排他锁加锁快速失败。</li></ul></li></ul><ol start="5"><li>表锁的兼容性图</li></ol><p><img src="/image/mysql/lock.png" alt="表锁的兼容性"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><blockquote><p><a href="https://www.linuxidc.com/Linux/2018-04/151914.htm" target="_blank" rel="noopener">MySQL锁机制深入理解</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事务基础&quot;&gt;&lt;a href=&quot;#事务基础&quot; class=&quot;headerlink&quot; title=&quot;事务基础&quot;&gt;&lt;/a&gt;事务基础&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;ACID属性&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;原子性：事务不可分&lt;/li&gt;
&lt;li&gt;一致性：在事务开始和</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://zws6672.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>结构型模式——实例</title>
    <link href="http://zws6672.top/2021/03/29/design-structure-eg/"/>
    <id>http://zws6672.top/2021/03/29/design-structure-eg/</id>
    <published>2021-03-29T06:12:18.000Z</published>
    <updated>2021-03-29T06:13:55.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="适配器模式（兼容）"><a href="#适配器模式（兼容）" class="headerlink" title="适配器模式（兼容）"></a>适配器模式（兼容）</h1><p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作；可以分为类适配器模式以及对象适配器模式。</p><ol><li>类适配器模式</li></ol><p>类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/29 12:50</span><br><span class="line"> * @Description 类适配器</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 适配器类：通过包装一个需要适配的对象，把原接口转换成目标接口。</span><br><span class="line">public class AdapterTest extends Adaptee implements AdapterTarget&#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        AdapterTarget target = new AdapterTest();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request2() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request3() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 目标接口：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类</span><br><span class="line">interface AdapterTarget &#123;</span><br><span class="line">    void request();</span><br><span class="line">    void request2();</span><br><span class="line">    void request3();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 适配者接口：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法</span><br><span class="line">class Adaptee &#123;</span><br><span class="line">    public void adapteeRequest() &#123;</span><br><span class="line">        System.out.println(&quot;适配者接口的业务代码&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>对象适配器模式：对于这种对象的适配器模式，实际上就是通过一个适配器类，把目标类和需要被适配的类进行组合。所以适配器类Adapter一般需要继承或实现Targert，并且还得持有Adaptee的实例引用。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 对象适配器</span><br><span class="line">class ObjectAdapter implements AdapterTarget &#123;</span><br><span class="line">    private Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    public ObjectAdapter(Adaptee adaptee) &#123;</span><br><span class="line">        this.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        adaptee.adapteeRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request2() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request3() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">public class AdapterTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        ObjectAdapter adapter = new ObjectAdapter(new Adaptee());</span><br><span class="line">        adapter.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>为什么使用适配器模式</li></ol><p>假如在旧的接口涉及到其它功能，这时候我们需要增加一个新的参数。如果在旧有的接口做修改，会影响到其它的实现类。所以，我们可以通过定义适配器来扩展接口，实现和老代码的兼容。但是，如果过渡使用适配器模式，会导致代码结构散乱，难以重构。</p><h1 id="代理模式（附加功能与核心功能解耦）"><a href="#代理模式（附加功能与核心功能解耦）" class="headerlink" title="代理模式（附加功能与核心功能解耦）"></a>代理模式（附加功能与核心功能解耦）</h1><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。代理模式通过增加中间层，为其他对象提供一种代理以控制对这个对象的访问，还可以想在访问一个类时做一些控制。代理模式分为:</p><ul><li>静态代理：所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</li><li>动态代理：动态代理是在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象。</li></ul><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/29 13:19</span><br><span class="line"> * @Description 代理模式</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class ProxyTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        ProxyTool tool = new ProxyTool(new RealTool());</span><br><span class="line">        tool.description();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//抽象接口</span><br><span class="line">interface Tool &#123;</span><br><span class="line">    void description();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RealTool implements Tool&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void description() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;这是一个被代理类的描述方法&quot;);</span><br><span class="line">            Thread.sleep((int) (Math.random()*1000));</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProxyTool implements Tool &#123;</span><br><span class="line">    Tool tool;</span><br><span class="line"></span><br><span class="line">    public ProxyTool(Tool tool) &#123;</span><br><span class="line">        this.tool = tool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void description() &#123;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        tool.description();</span><br><span class="line">        System.out.println((System.currentTimeMillis()-startTime) + &quot;毫秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在 RPC、缓存等应用场景中。</p><h1 id="桥接模式（多维度解耦）"><a href="#桥接模式（多维度解耦）" class="headerlink" title="桥接模式（多维度解耦）"></a>桥接模式（多维度解耦）</h1><p>如果一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。</p><p>桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。桥接模式将继承关系转化成关联关系，它降低了类与类之间的耦合度，减少了系统中类的数量，也减少了代码量。</p><ul><li>抽象化：其概念是将复杂物体的一个或几个特性抽出去而只注意其他特性的行动或过程。在面向对象就是将对象共同的性质抽取出去而形成类的过程。</li><li>实现化：针对抽象化给出的具体实现。它和抽象化是一个互逆的过程，实现化是对抽象化事物的进一步具体化。</li><li>脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。</li></ul><p>桥接模式主要包含如下几个角色：</p><ul><li>Abstraction：抽象类</li><li>RefinedAbstraction：扩充抽象类</li><li>Implementor：实现类接口</li><li>ConcreteImplementor：具体实现类</li></ul><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/29 13:33</span><br><span class="line"> * @Description 桥接模式</span><br><span class="line"> */</span><br><span class="line">public class BridgeTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        Shape shape = new Circle();</span><br><span class="line">        Color color = new White();</span><br><span class="line">        shape.setColor(color);</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 抽象类</span><br><span class="line">abstract class Shape &#123;</span><br><span class="line">    Color color;</span><br><span class="line"></span><br><span class="line">    public void setColor(Color color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void draw();</span><br><span class="line">&#125;</span><br><span class="line">// 扩充抽象类</span><br><span class="line">class Circle extends Shape&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        color.bepaint(&quot;正方形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现类接口</span><br><span class="line">interface Color &#123;</span><br><span class="line">    public void bepaint(String shape);</span><br><span class="line">&#125;</span><br><span class="line">// 具体实现类</span><br><span class="line">class White implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void bepaint(String shape) &#123;</span><br><span class="line">        System.out.println(&quot;白色的&quot; + shape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="装饰模式（扩展）"><a href="#装饰模式（扩展）" class="headerlink" title="装饰模式（扩展）"></a>装饰模式（扩展）</h1><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。装饰器模式是为了动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/29 13:40</span><br><span class="line"> * @Description 装饰器模式</span><br><span class="line"> */</span><br><span class="line">public class DecoratorTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        Bird bird = new Eagle();</span><br><span class="line">        BirdDecorator decorator = new WhiteBirdDecorator(bird);</span><br><span class="line">        decorator.des();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象</span><br><span class="line">interface Bird &#123;</span><br><span class="line">    void des();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体构件（Concrete Component）角色：定义一个将要接收附加责任的类</span><br><span class="line">class Eagle implements Bird &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void des() &#123;</span><br><span class="line">        System.out.println(&quot;小型至中型的白昼活动的鹰形类鸟&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口</span><br><span class="line">abstract class BirdDecorator implements Bird &#123;</span><br><span class="line">    public Bird bird;</span><br><span class="line"></span><br><span class="line">    public BirdDecorator(Bird bird) &#123;</span><br><span class="line">        this.bird = bird;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void des() &#123;</span><br><span class="line">        bird.des();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任</span><br><span class="line">class WhiteBirdDecorator extends  BirdDecorator &#123;</span><br><span class="line">    public WhiteBirdDecorator(Bird bird) &#123;</span><br><span class="line">        super(bird);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void des() &#123;</span><br><span class="line">        bird.des();</span><br><span class="line">        extend();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void extend() &#123;</span><br><span class="line">        System.out.println(&quot;白色的鸟&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="外观模式（同一接口）"><a href="#外观模式（同一接口）" class="headerlink" title="外观模式（同一接口）"></a>外观模式（同一接口）</h1><p>外观模式提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。</p><p>外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点：</p><ul><li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li><li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li></ul><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/29 13:57</span><br><span class="line"> * @Description 外观模式</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class FacadeTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        Facade facade = new Facade();</span><br><span class="line">        facade.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//外观角色</span><br><span class="line">class Facade &#123;</span><br><span class="line">    private SubSystem01 obj1 = new SubSystem01();</span><br><span class="line">    private SubSystem02 obj2 = new SubSystem02();</span><br><span class="line">    private SubSystem03 obj3 = new SubSystem03();</span><br><span class="line"></span><br><span class="line">    public void method() &#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem01 &#123;</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;子系统01的method1()被调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem02 &#123;</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;子系统02的method2()被调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem03 &#123;</span><br><span class="line">    public void method3() &#123;</span><br><span class="line">        System.out.println(&quot;子系统03的method3()被调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="享元模式（对象共享）"><a href="#享元模式（对象共享）" class="headerlink" title="享元模式（对象共享）"></a>享元模式（对象共享）</h1><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p><p>模式所涉及的角色：</p><ul><li>Flyweight： 享元接口，通过这个接口传入外部状态并作用于外部状态；</li><li>ConcreteFlyweight： 具体的享元实现对象，必须是可共享的，需要封装享元对象的内部状态；</li><li>UnsharedConcreteFlyweight： 非共享的享元实现对象，并不是所有的享元对象都可以共享，非共享的享元对象通常是享元对象的组合对象；</li><li>FlyweightFactory： 享元工厂，主要用来创建并管理共享的享元对象，并对外提供访问共享享元的接口；</li></ul><p>享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</p><p>享元对象能做到共享的关键是区分两个状态：<br>内部状态(Internal State)：存储在享元对象内部并且不会随环境改变而改变的状态<br>外部状态(External State)：随环境改变而改变的、不可以共享的状态</p><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">// 接口</span><br><span class="line">public interface Shape &#123;</span><br><span class="line">   void draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建实现接口的实体类</span><br><span class="line">public class Circle implements Shape &#123;</span><br><span class="line">   private String color;</span><br><span class="line">   private int x;</span><br><span class="line">   private int y;</span><br><span class="line">   private int radius;</span><br><span class="line"> </span><br><span class="line">   public Circle(String color)&#123;</span><br><span class="line">      this.color = color;     </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setX(int x) &#123;</span><br><span class="line">      this.x = x;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setY(int y) &#123;</span><br><span class="line">      this.y = y;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setRadius(int radius) &#123;</span><br><span class="line">      this.radius = radius;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Circle: Draw() [Color : &quot; + color </span><br><span class="line">         +&quot;, x : &quot; + x +&quot;, y :&quot; + y +&quot;, radius :&quot; + radius);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 享元工厂</span><br><span class="line"></span><br><span class="line">public class ShapeFactory &#123;</span><br><span class="line">   private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">   public static Shape getCircle(String color) &#123;</span><br><span class="line">      Circle circle = (Circle)circleMap.get(color);</span><br><span class="line"> </span><br><span class="line">      if(circle == null) &#123;</span><br><span class="line">         circle = new Circle(color);</span><br><span class="line">         circleMap.put(color, circle);</span><br><span class="line">         System.out.println(&quot;Creating circle of color : &quot; + color);</span><br><span class="line">      &#125;</span><br><span class="line">      return circle;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FlyweightPatternDemo &#123;</span><br><span class="line">   private static final String colors[] = </span><br><span class="line">      &#123; &quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;White&quot;, &quot;Black&quot; &#125;;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">      for(int i=0; i &lt; 20; ++i) &#123;</span><br><span class="line">         Circle circle = </span><br><span class="line">            (Circle)ShapeFactory.getCircle(getRandomColor());</span><br><span class="line">         circle.setX(getRandomX());</span><br><span class="line">         circle.setY(getRandomY());</span><br><span class="line">         circle.setRadius(100);</span><br><span class="line">         circle.draw();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   private static String getRandomColor() &#123;</span><br><span class="line">      return colors[(int)(Math.random()*colors.length)];</span><br><span class="line">   &#125;</span><br><span class="line">   private static int getRandomX() &#123;</span><br><span class="line">      return (int)(Math.random()*100 );</span><br><span class="line">   &#125;</span><br><span class="line">   private static int getRandomY() &#123;</span><br><span class="line">      return (int)(Math.random()*100);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合模式（部分-整体）"><a href="#组合模式（部分-整体）" class="headerlink" title="组合模式（部分-整体）"></a>组合模式（部分-整体）</h1><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">   private String name;</span><br><span class="line">   private String dept;</span><br><span class="line">   private int salary;</span><br><span class="line">   private List&lt;Employee&gt; subordinates;</span><br><span class="line"> </span><br><span class="line">   //构造函数</span><br><span class="line">   public Employee(String name,String dept, int sal) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">      this.dept = dept;</span><br><span class="line">      this.salary = sal;</span><br><span class="line">      subordinates = new ArrayList&lt;Employee&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void add(Employee e) &#123;</span><br><span class="line">      subordinates.add(e);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void remove(Employee e) &#123;</span><br><span class="line">      subordinates.remove(e);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public List&lt;Employee&gt; getSubordinates()&#123;</span><br><span class="line">     return subordinates;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String toString()&#123;</span><br><span class="line">      return (&quot;Employee :[ Name : &quot;+ name </span><br><span class="line">      +&quot;, dept : &quot;+ dept + &quot;, salary :&quot;</span><br><span class="line">      + salary+&quot; ]&quot;);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CompositePatternDemo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Employee CEO = new Employee(&quot;John&quot;,&quot;CEO&quot;, 30000);</span><br><span class="line"> </span><br><span class="line">      Employee headSales = new Employee(&quot;Robert&quot;,&quot;Head Sales&quot;, 20000);</span><br><span class="line"> </span><br><span class="line">      Employee headMarketing = new Employee(&quot;Michel&quot;,&quot;Head Marketing&quot;, 20000);</span><br><span class="line"> </span><br><span class="line">      Employee clerk1 = new Employee(&quot;Laura&quot;,&quot;Marketing&quot;, 10000);</span><br><span class="line">      Employee clerk2 = new Employee(&quot;Bob&quot;,&quot;Marketing&quot;, 10000);</span><br><span class="line"> </span><br><span class="line">      Employee salesExecutive1 = new Employee(&quot;Richard&quot;,&quot;Sales&quot;, 10000);</span><br><span class="line">      Employee salesExecutive2 = new Employee(&quot;Rob&quot;,&quot;Sales&quot;, 10000);</span><br><span class="line"> </span><br><span class="line">      CEO.add(headSales);</span><br><span class="line">      CEO.add(headMarketing);</span><br><span class="line"> </span><br><span class="line">      headSales.add(salesExecutive1);</span><br><span class="line">      headSales.add(salesExecutive2);</span><br><span class="line"> </span><br><span class="line">      headMarketing.add(clerk1);</span><br><span class="line">      headMarketing.add(clerk2);</span><br><span class="line"> </span><br><span class="line">      //打印该组织的所有员工</span><br><span class="line">      System.out.println(CEO); </span><br><span class="line">      for (Employee headEmployee : CEO.getSubordinates()) &#123;</span><br><span class="line">         System.out.println(headEmployee);</span><br><span class="line">         for (Employee employee : headEmployee.getSubordinates()) &#123;</span><br><span class="line">            System.out.println(employee);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;        </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;适配器模式（兼容）&quot;&gt;&lt;a href=&quot;#适配器模式（兼容）&quot; class=&quot;headerlink&quot; title=&quot;适配器模式（兼容）&quot;&gt;&lt;/a&gt;适配器模式（兼容）&lt;/h1&gt;&lt;p&gt;适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://zws6672.top/tags/设计模式/"/>
    
  </entry>
  
  <entry>
    <title>JDK8 语言新特性</title>
    <link href="http://zws6672.top/2021/03/29/jdk8/"/>
    <id>http://zws6672.top/2021/03/29/jdk8/</id>
    <published>2021-03-29T04:41:58.000Z</published>
    <updated>2021-03-29T04:43:05.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口新增默认方法与静态方法"><a href="#接口新增默认方法与静态方法" class="headerlink" title="接口新增默认方法与静态方法"></a>接口新增默认方法与静态方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/24 19:01</span><br><span class="line"> * @Description 接口新增默认方法与静态方法</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public interface Interface1 &#123;</span><br><span class="line">    void method1();</span><br><span class="line">    default void test() &#123;</span><br><span class="line">        System.out.println(&quot;接口的默认方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static void test2() &#123;</span><br><span class="line">        System.out.println(&quot;接口的静态方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用-FunctionalInterface限制函数接口的转换"><a href="#使用-FunctionalInterface限制函数接口的转换" class="headerlink" title="使用@FunctionalInterface限制函数接口的转换"></a>使用@FunctionalInterface限制函数接口的转换</h1><ul><li>函数式接口仅仅只有一个方法(非默认或静态方法)，用于显示转换成ladbma表达式。</li><li>java.lang.Runnable接口、java.util.concurrent.Callable接口是两个最典型的函数式接口。</li><li>如果一个函数式接口添加一个普通方法，就变成了非函数式接口（一般定义的接口）。</li><li>Jdk8 规范里添加了注解@FunctionalInterface来限制函数式接口不能修改为普通的接口.</li></ul><blockquote><p>注：函数形接口 、供给形接口、消费型接口、判断型接口</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/24 19:03</span><br><span class="line"> * @Description 使用@FunctionalInterface限制接口只能有一个方法</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Functional1 &#123;</span><br><span class="line">    void test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lambda表达式-与-stream-流"><a href="#Lambda表达式-与-stream-流" class="headerlink" title="Lambda表达式 与 stream 流"></a>Lambda表达式 与 stream 流</h1><p>Lambda表达式（基于函数的匿名表达式）,相关语法如下：<br><code>( object str,....)[参数列表]   -&gt;[箭头符号]     代码块或表达式</code></p><p>Stream是元素的集合，可以支持顺序和并行的对原Stream进行汇聚的操作。创建stream：</p><ul><li>通过Stream接口的静态工厂方法</li><li>通过Collection接口的默认方法 stream()，把一个Collection对象转换成Stream</li></ul><p>stream相关的几个方法：</p><ul><li>转换<ul><li>distinct：去重</li><li>filter：对于Stream中包含的元素使用给定的过滤函数进行过滤操作</li><li>map：对于Stream中包含的元素使用给定的转换函数进行转换操作，支持类型转换（mapToInt，mapToLong和mapToDouble）</li><li>peek：生成一个包含原Stream的所有元素的新Stream，同时会提供一个消费函数（Consumer实例），新Stream每个元素被消费的时候都会执行给定的消费函数</li><li>limit: 对一个Stream进行截断操作，获取其前N个元素，如果原Stream中包含的元素个数小于N，那就获取其所有的元素</li><li>skip: 返回一个丢弃原Stream的前N个元素后剩下元素组成的新Stream，如果原Stream中包含的元素个数小于N，那么返回空Stream</li><li>sorted：排序</li><li>forEach：遍历</li></ul></li><li>汇聚（Reduce）Stream<ul><li>count：统计个数</li><li>concat：组合多个流</li><li>collect：流中多个元素合并为一个元素<br>相关实例如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">//        1. Lambda 表达式实现Runnable</span><br><span class="line">        new Thread(()-&gt;System.out.println(&quot;1. Lambda 表达式实现Runnable，相关的内部类都可以这么写&quot;)).start();</span><br><span class="line">//        2. Lambda 表达式迭代list</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;2. Lambda 表达式迭代list&quot;);</span><br><span class="line">        List list = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;f&quot;);</span><br><span class="line">        list.forEach(n-&gt;System.out.println(n));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//        3. Lambda 表达式map</span><br><span class="line">        System.out.println(&quot;3. Lambda 表达式map&quot;);</span><br><span class="line">        List&lt;Integer&gt; list2 = Arrays.asList(11,52,7,9,40);</span><br><span class="line">        list2.stream().map((num)-&gt; num*2).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">//        4. Lambda 表达式过滤数据</span><br><span class="line">        System.out.println(&quot;4. Lambda 表达式过滤数据 输出三个字节以下的数据&quot;);</span><br><span class="line">        List&lt;String&gt; list3 = Arrays.asList(&quot;ad&quot;,&quot;bsdfd&quot;,&quot;cdf&quot;,&quot;ddfd&quot;,&quot;fs&quot;);</span><br><span class="line">        list3.stream().filter(str-&gt;str.length()&lt;3).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">//        5. Lambda 表达式连接字符</span><br><span class="line">        System.out.println(&quot;5. Lambda 表达式连接字符&quot;);</span><br><span class="line">        List&lt;String&gt; list4 = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;);</span><br><span class="line">        String res = list4.stream().map((cr)-&gt;cr.toUpperCase()).collect(Collectors.joining(&quot;-&quot;));</span><br><span class="line">        System.out.println(res);</span><br><span class="line">//        6. Lambda 表达式计算集合元素</span><br><span class="line">        System.out.println(&quot;计算集合元素的最大值、最小值、总和以及平均值&quot;);</span><br><span class="line">        List&lt;Integer&gt; primes = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);</span><br><span class="line">        IntSummaryStatistics stats = primes.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">        System.out.println(&quot;Highest prime number in List : &quot; + stats.getMax());</span><br><span class="line">        System.out.println(&quot;Lowest prime number in List : &quot; + stats.getMin());</span><br><span class="line">        System.out.println(&quot;Sum of all prime numbers : &quot; + stats.getSum());</span><br><span class="line">        System.out.println(&quot;Average of all prime numbers : &quot; + stats.getAverage());</span><br><span class="line"></span><br><span class="line">//        7. Lambda 表达式去重</span><br><span class="line">        System.out.println(&quot;7. Lambda 表达式去重&quot;);</span><br><span class="line">        List&lt;Integer&gt; list5 = Arrays.asList(2, 2, 5, null, 11, 11, 17, 19, 17, 2);</span><br><span class="line">//        filter(x-&gt;x!=null 避免为null的情况</span><br><span class="line">//        distinct() 去重</span><br><span class="line">        list5.stream().filter(x-&gt;x!=null).distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">//        8. Lambda 表达式排序</span><br><span class="line">        System.out.println(&quot;8. Lambda 表达式排序&quot;);</span><br><span class="line">        List&lt;Integer&gt; list6 = Arrays.asList(29, 2, 5, null, 11, 11, 17, 19, 17, 2);</span><br><span class="line">        list6.stream().filter(x-&gt;x!=null).sorted((a,b)-&gt;a-b).distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="新增方法引用"><a href="#新增方法引用" class="headerlink" title="新增方法引用"></a>新增方法引用</h1><p>方法引用是只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(str -&gt; System.out.print(str));</span><br><span class="line">list.forEach(System.out::print);//等价</span><br></pre></td></tr></table></figure><ul><li>分类<ul><li>构造器引用<ul><li>格式：<code>Class::new</code>，调用默认构造器</li></ul></li><li>静态方法引用<ul><li>格式：<code>Class::static_method</code></li></ul></li><li>类(任意对象)的方法引用（在流中会调用每个类）<ul><li>格式：<code>Class::method</code>，方法不能带参数</li></ul></li><li>实例对象的方法引用<ul><li>格式：<code>instance::method</code></li></ul></li></ul></li></ul><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/24 20:26</span><br><span class="line"> * @Description 方法引用</span><br><span class="line"> */</span><br><span class="line">public class MethodUseTest &#123;</span><br><span class="line">    public MethodUseTest() &#123;</span><br><span class="line">        System.out.println(&quot;默认构造器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String test() &#123;</span><br><span class="line">        System.out.println(&quot;静态方法&quot;);</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    void instance() &#123;</span><br><span class="line">        System.out.println(&quot;实例方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        List&lt;MethodUseTest&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">//        1.构造器引用 需要使用 Supplier(创建对象的工厂)</span><br><span class="line">        Supplier&lt;MethodUseTest&gt; mut = MethodUseTest::new;</span><br><span class="line">        Supplier&lt;MethodUseTest&gt; mut2 = MethodUseTest::new;</span><br><span class="line">//        2.静态方法引用。如果函数式接口的实现恰好是通过调用一个静态方法来实现，那么就可以使用静态方法引用</span><br><span class="line">        Supplier&lt;String&gt; test = MethodUseTest::test;</span><br><span class="line"></span><br><span class="line">        list.add(mut.get());</span><br><span class="line">        list.add(mut2.get());</span><br><span class="line">//        3.普通方法引用，方法不能带参数。</span><br><span class="line">        list.forEach(MethodUseTest::instance);</span><br><span class="line">//        4.实例对象的方法引用 需要以流元素作为参数</span><br><span class="line">        MethodUseTest mut3 = new MethodUseTest();</span><br><span class="line">        list.forEach(mut3::instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void instance(MethodUseTest methodUseTest) &#123;</span><br><span class="line">        methodUseTest.instance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><ol><li><p>重复注解<br>Java 5引入了注解机制，这一特性就变得非常流行并且广为使用，但是相同的注解在同一地方只能使用一次。Java 8引入了重复注解机制，使相同的注解可以在同一地方声明多次，重复注解机制本身必须用@Repeatable注解。</p></li><li><p>扩展注解的支持<br>JDK8 扩展了注解的上下文。现在几乎可以为任何东西添加注解：局部变量、泛型类、父类与接口的实现，就连方法的异常也能添加注解。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;接口新增默认方法与静态方法&quot;&gt;&lt;a href=&quot;#接口新增默认方法与静态方法&quot; class=&quot;headerlink&quot; title=&quot;接口新增默认方法与静态方法&quot;&gt;&lt;/a&gt;接口新增默认方法与静态方法&lt;/h1&gt;&lt;figure class=&quot;highlight plai</summary>
      
    
    
    
    
    <category term="java" scheme="http://zws6672.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>创建型模式——实例</title>
    <link href="http://zws6672.top/2021/03/29/design-creator-eg/"/>
    <id>http://zws6672.top/2021/03/29/design-creator-eg/</id>
    <published>2021-03-29T04:37:09.000Z</published>
    <updated>2021-03-29T06:14:15.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ol><li>懒汉式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized static Singleton getInstance() &#123;</span><br><span class="line">//       懒汉式 需要时再初始化</span><br><span class="line">         if (instance == null) &#123;</span><br><span class="line">             instance = new Singleton();</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             System.out.println(&quot;实例对象已创建&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>饿汉式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized static Singleton getInstance() &#123;</span><br><span class="line">//        饿汉式 定义时初始化</span><br><span class="line">return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DCL（即Double Check Lock，双重检查锁定）</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton instance;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>静态内部类</li></ol><p>第一次加载Singleton类时不会初始化instance，只有在第一次调用getInstance()方法时，虚拟机会加载SingletonHolder类，初始化instance。保证线程安全，单例对象的唯一，也延迟了单例的初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static Singleton instance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>枚举单例</li></ol><p>默认枚举实例的创建是线程安全的，即使反序列化也不会生成新的实例，任何情况下都是一个单例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;do something&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>用原型实例可以指定创建对象的种类，并通过拷贝这些原型创建新的对象。</p><p><a href="/image/degin-pattern/proto_use.png">原型模式</a></p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/27 14:59</span><br><span class="line"> * @Description 原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷 贝这些原型，创建新的对象 。</span><br><span class="line"> *  原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象， 无需知道如何创建的细节 。通过将一个原型对象传给那个要发动创建的对象，这个要发动创建 的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()。</span><br><span class="line"> */</span><br><span class="line">public class Prototype implements Cloneable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Date date;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDate(Date date) &#123;</span><br><span class="line">        this.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main (String[] args) throws CloneNotSupportedException, InterruptedException &#123;</span><br><span class="line">        Prototype prototype = new Prototype(&quot;test&quot;, new Date());</span><br><span class="line">        Prototype clone = prototype.clone();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        prototype.setDate(new Date());</span><br><span class="line">        prototype.setName(&quot;result&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(prototype.name+&quot;:&quot;+prototype.date);</span><br><span class="line">        System.out.println(clone.name+&quot;:&quot;+clone.date);</span><br><span class="line">    &#125;</span><br><span class="line">    public Prototype() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Prototype(String name, Date date) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Prototype clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Prototype prototype = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            prototype = (Prototype) super.clone();</span><br><span class="line">//            如果属性包含，自定义类需要实现clone方法，才能实现深拷贝，否则会指向同一块内存空间</span><br><span class="line">//            prototype.test = (Test) test.clone();</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line">            return prototype;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型模式需要注意的几点：</p><ul><li>克隆对象不会调用构造方法</li><li>访问权限对原型模式无效</li><li>当我们的类初始化需要消耗很多的资源时，就可以使用原型模式，因为我们的克隆不会执行构造方法，避免了初始化占有的时间和空间</li><li>一个对象被其她对象访问，并且能够修改时，访问权限都无效了，什么都能修改</li></ul><h1 id="建造者模式（创建与使用分离）"><a href="#建造者模式（创建与使用分离）" class="headerlink" title="建造者模式（创建与使用分离）"></a>建造者模式（创建与使用分离）</h1><p>建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。用户只需要给出指定复杂对象的类型和内容 建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)。</p><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/27 15:22</span><br><span class="line"> * @Description 建造者模式</span><br><span class="line"> */</span><br><span class="line">public class Builder &#123;</span><br><span class="line">    public static void main (String[] args) throws Exception &#123;</span><br><span class="line">        User user = User.builder().userName(&quot;test&quot;).id(1).address(&quot;bj&quot;).password(&quot;111&quot;).build();</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Integer id;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private String address;</span><br><span class="line">//    private String status;</span><br><span class="line">//    private String role;</span><br><span class="line">//    private String realname;</span><br><span class="line">//    private Date register_time;</span><br><span class="line">//    private String register_ip;</span><br><span class="line">//    private Date login_time;</span><br><span class="line">//    private String login_ip;</span><br><span class="line"></span><br><span class="line">    private User(Integer id, String username, String password, String address) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    public static UserBuilder builder() &#123;</span><br><span class="line">        return new UserBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">    static class UserBuilder &#123;</span><br><span class="line">        private Integer id;</span><br><span class="line">        private String username;</span><br><span class="line">        private String password;</span><br><span class="line">        private String address;</span><br><span class="line"></span><br><span class="line">        private UserBuilder() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public UserBuilder id(Integer id) &#123;</span><br><span class="line">            this.id = id;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public UserBuilder userName(String username) &#123;</span><br><span class="line">            this.username = username;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public UserBuilder password(String password) &#123;</span><br><span class="line">            this.password = password;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public UserBuilder address(String address) &#123;</span><br><span class="line">            this.address = address;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        public User build() throws Exception &#123;</span><br><span class="line">            if (username==null||password==null) &#123;</span><br><span class="line">                throw new Exception(&quot;用户名或密码不可为空&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return new User(id, username, password, address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式可以分为</p><ul><li>类模式，即工厂方法模式；</li><li>对象模式，即抽象工厂模式。</li></ul><p>工厂方法模式实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/23 18:07</span><br><span class="line"> * @Description 工厂方法 一个抽象工厂 多个实际工厂，一个抽象产品 多个实际产品，一个实际工厂对应一个实际产品</span><br><span class="line"> */</span><br><span class="line">public class FactoryMethod &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        AbstractFactory factory = new ConcreteFactory1();</span><br><span class="line">        factory.newProduct().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//抽象产品 产品规范</span><br><span class="line">interface Product &#123;</span><br><span class="line">    void show();</span><br><span class="line">&#125;</span><br><span class="line">//具体产品 产品细节</span><br><span class="line">class ConcreteProduct1 implements Product &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;实际产品1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ConcreteProduct2 implements Product &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;实际产品2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象工厂 创建产品的接口</span><br><span class="line">abstract class AbstractFactory &#123;</span><br><span class="line">    abstract Product newProduct();</span><br><span class="line">&#125;</span><br><span class="line">//具体工厂 创建产品</span><br><span class="line">class ConcreteFactory1 extends AbstractFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Product newProduct() &#123;</span><br><span class="line">        System.out.println(&quot;实际工厂1--&gt;&quot;);</span><br><span class="line">        return new ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConcreteFactory2 extends AbstractFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    Product newProduct() &#123;</span><br><span class="line">        System.out.println(&quot;实际工厂2--&gt;&quot;);</span><br><span class="line">        return new ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂模式实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/23 18:19</span><br><span class="line"> * @Description 抽象工厂模式：在工厂方法中，只考虑同种等级的产品；但是，在实际应用中，多产品才是主流。而 抽象工厂模式则考虑多等级产品的生产。</span><br><span class="line"> */</span><br><span class="line">public class AbstractFactoryMethod &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        AbstractFactory2 factory = new MyFactory1();</span><br><span class="line">        factory.newProduct1().show();</span><br><span class="line">        factory.newProduct2().show();</span><br><span class="line">        AbstractFactory2 factory2 = new MyFactory2();</span><br><span class="line">        factory2.newProduct1().show();</span><br><span class="line">        factory2.newProduct2().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//抽象工厂 创建产品的接口</span><br><span class="line">abstract class AbstractFactory2 &#123;</span><br><span class="line">    abstract Product2 newProduct1();</span><br><span class="line">    abstract Product2 newProduct2();</span><br><span class="line">&#125;</span><br><span class="line">interface Product2 &#123;</span><br><span class="line">    void show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Product211 implements Product2 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;实际产品1-1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Product212 implements Product2 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;实际产品1-2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Product221 implements Product2 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;实际产品2-1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Product222 implements Product2 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;实际产品2-2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyFactory1 extends AbstractFactory2 &#123;</span><br><span class="line">    public MyFactory1() &#123;</span><br><span class="line">        System.out.println(&quot;实际工厂1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Product2 newProduct1() &#123;</span><br><span class="line">        return new Product211();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Product2 newProduct2() &#123;</span><br><span class="line">        return new Product212();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyFactory2 extends AbstractFactory2 &#123;</span><br><span class="line">    public MyFactory2() &#123;</span><br><span class="line">        System.out.println(&quot;实际工厂2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    Product2 newProduct1() &#123;</span><br><span class="line">        return new Product221();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Product2 newProduct2() &#123;</span><br><span class="line">        return new Product222();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;懒汉式&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://zws6672.top/tags/设计模式/"/>
    
  </entry>
  
  <entry>
    <title>Netty————零拷贝</title>
    <link href="http://zws6672.top/2021/03/29/netty-zero-copy/"/>
    <id>http://zws6672.top/2021/03/29/netty-zero-copy/</id>
    <published>2021-03-29T04:18:39.000Z</published>
    <updated>2021-03-29T04:35:57.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是零拷贝-zero-copy"><a href="#什么是零拷贝-zero-copy" class="headerlink" title="什么是零拷贝(zero-copy)"></a>什么是零拷贝(zero-copy)</h1><p>零拷贝指的是没有CPU拷贝，而不是没有拷贝时间。操作系统可以分为用户态和内核态，在内核态缓冲区之间，没有数据是重复的。零拷贝意味着更少的数据复制、更少的上下文切换、CPU缓存伪共享以及无CPU检验和计算。零拷贝是网络编程的核心，很多性能优化都离不开。</p><p>文件复制可以分为两个流程，一部分是文件的读，另外一部分是文件的写。在传统的IO文件操作时，假如我们要读取文件，有以下几个流程：</p><ul><li>调用操作系统提供的底层标准IO系统调用函数read()，进行一次上下文切换（用户态—&gt;内核态）；</li><li>OS的内核代码将相应的文件数据读取到内核的IO 缓冲区，是一次DMA Copy（内核从磁盘上面读取数据 是 不消耗CPU时间的，是通过磁盘控制器完成）</li><li>数据再由内核的IO 缓冲区拷贝到进程的私有空间中，是一次CPU Copy</li><li>read调用返回后，会再进行一次上下文切换（内核态—&gt;用户态）</li></ul><p>假如我们要写入文件，有以下几个流程：</p><ul><li>应用发起写操作，OS进行一次上下文切换（从用户空间切换为内核空间）</li><li>数据copy到内核缓冲区Socket Buffer，做了一次CPU Copy</li><li>内核空间再把数据copy到磁盘或其他存储（网卡，进行网络传输），进行了DMA Copy</li><li>写入结束后返回，又从内核空间切换到用户空间</li></ul><p>综上，传统的复制操作会发生四次上下文切换、两次DMA复制、两次CPU复制。为此，零拷贝提供了mmap+write方式、sendfile方式提高复制效率。</p><h1 id="拷贝优化的演化"><a href="#拷贝优化的演化" class="headerlink" title="拷贝优化的演化"></a>拷贝优化的演化</h1><ol><li><p>mmap+write方式<br>mmap+write方式是使用虚拟内存的特性，将内核空间和用户空间的虚拟地址映射到同一个物理地址，这样就不需要来回复制了。读取时把数据存放到内核缓冲区而不必应用程序缓冲区，写入数据的时候直接从内核缓冲区读取到内核缓冲区即可，这需要花费一次CPU Copy。这个方式将花费四次上下文切换、两次DMA复制、一次CPU复制。</p></li><li><p>sendfile方式<br>sendfile方式这种方式可以替换上面的mmap+write方式，它少了一个应用程序发起write操作，直接发起sendfile操作。这个方式将花费两次上下文切换、两次DMA复制、一次CPU复制。</p></li><li><p>gather操作（零拷贝基础）<br>而Linux2.4内核进行了优化，提供了gather操作。这个操作在内核空间Read Buffer和Socket Buffer不做数据复制，而是将Read Buffer的内存地址、偏移量记录到相应的Socket Buffer中，这样就不需要复制。这个方式将花费两次上下文切换、两次DMA复制。</p></li></ol><p>JAVA零拷贝 java nio实现零拷贝，JAVA提供了一下方法类：</p><ul><li>MappedByteBuffer mmap+write方式</li><li>DirectByteBuffer 堆外内存</li><li>FileChannel.transferTo</li></ul><p>Linux提供的零拷贝技术 Java并不是全支持，支持2种(内存映射mmap、sendfile)：</p><ul><li><p>NIO提供的内存映射 MappedByteBuffer，底层就是调用Linux mmap()实现的。</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MappedByteBuffer mappedByteBuffer = new RandomAccessFile(file, &quot;r&quot;) </span><br><span class="line">                                .getChannel() </span><br><span class="line">                               .map(FileChannel.MapMode.READ_ONLY, 0, len);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>NIO提供的sendfile</p><ul><li>FileChannel.transferTo()方法直接将当前通道内容传输到另一个通道，没有涉及到Buffer的任何操作，NIO中 的Buffer是JVM堆或者堆外内存，但不论如何他们都是操作系统内核空间的内存</li><li>transferTo()的实现方式就是通过系统调用sendfile() (当然这是Linux中的系统调用)</li></ul></li></ul><h1 id="Netty的零拷贝"><a href="#Netty的零拷贝" class="headerlink" title="Netty的零拷贝"></a>Netty的零拷贝</h1><p>Netty中的Zero-copy与上面我们所提到到OS层面上的Zero-copy不太一样, Netty的Zero-copy完全是在用户态(Java层面)的，它的Zero-copy的更多的是偏向于优化数据操作这样的概念。</p><ul><li><p>应用层数据优化的零拷贝</p><ul><li><p>Netty提供了CompositeByteBuf类，它可以将多个ByteBuf合并为一个逻辑上的ByteBuf，避免了各个ByteBuf之间的拷贝。</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ByteBuf合并操作</span><br><span class="line">resultBuf.writeBytes(header);</span><br><span class="line">resultBuf.writeBytes(body);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ByteBuf 支持slice 操作，因此可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf，避免了内存的拷贝。</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ByteBuf分散操作</span><br><span class="line">ByteBuf header = byteBuf.slice(0,5);</span><br><span class="line">ByteBuf body = byteBuf.slice(5,10);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过wrap操作，我们可以将byte[]数组、ByteBuf、 ByteBuffer 等包装成一个 Netty ByteBuf对象，进而避免了拷贝操作。</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// byte[]--&gt; ByteBuf</span><br><span class="line">byte[] bytes;</span><br><span class="line">ByteBuf byteBuf = Unpooled.buffer();</span><br><span class="line">byteBuf.writeBytes(bytes);</span><br><span class="line">Unpooled.wrappedBuffer(bytes);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>操作系统级别的零拷贝</p><ul><li>通过FileRegion包装的FileChannel.tranferTo实现文件传输，可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。（底层依赖 Java NIO FileChannel.transferTo）</li></ul></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote><p><a href="https://juejin.cn/post/6844903984965091336" target="_blank" rel="noopener">零拷贝(zero-copy)</a><br><a href="https://blog.csdn.net/akunshouyoudou/article/details/104637539" target="_blank" rel="noopener">Java中的零拷贝</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是零拷贝-zero-copy&quot;&gt;&lt;a href=&quot;#什么是零拷贝-zero-copy&quot; class=&quot;headerlink&quot; title=&quot;什么是零拷贝(zero-copy)&quot;&gt;&lt;/a&gt;什么是零拷贝(zero-copy)&lt;/h1&gt;&lt;p&gt;零拷贝指的是没有CPU拷</summary>
      
    
    
    
    
    <category term="Netty" scheme="http://zws6672.top/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty（二）入门</title>
    <link href="http://zws6672.top/2021/03/21/netty-2-what/"/>
    <id>http://zws6672.top/2021/03/21/netty-2-what/</id>
    <published>2021-03-21T05:02:35.000Z</published>
    <updated>2021-03-21T06:49:58.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p>Netty是由JBOSS提供的一个java开源框架，现为 Github上的独立项目。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。</p><p>也就是说，Netty 是一个基于NIO的客户、服务器端的编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户、服务端应用。Netty相当于简化和流线化了网络应用的编程开发过程，例如：基于TCP和UDP的socket服务开发。</p><p>Netty和Tomcat的区别：Netty和Tomcat最大的区别就在于通信协议，Tomcat是基于Http协议的，他的实质是一个基于http协议的web容器，但是Netty不一样，他能通过编程自定义各种协议，因为netty能够通过codec自己来编码/解码字节流，完成类似redis访问的功能，这就是netty和tomcat最大的不同。</p><p>Netty的优点</p><ul><li>并发高：底层使用了NIO的网络I/O模型，该模型是非阻塞的，阻塞业务处理但不阻塞数据接收</li><li>传输快：依赖于零拷贝特性。当需要接收数据的时候，他会在堆内存之外开辟一块内存，数据就直接从IO读到了那块内存中去，在netty里面通过ByteBuf可以直接对这些数据进行直接操作，从而加快了传输速度。</li><li>封装好</li></ul><h3 id="Netty的线程模型"><a href="#Netty的线程模型" class="headerlink" title="Netty的线程模型"></a>Netty的线程模型</h3><ol><li>目前存在的线程模型</li></ol><ul><li>传统阻塞IO模型：采用阻塞式IO，每个连接都需要独立的线程进行处理；该模型的缺陷在于高并发时占用了大量的系统资源；阻塞模型需要等待资源到位，造成资源浪费。</li></ul><ul><li>Reactor模式<ul><li>单Reactor单线程</li><li>单Reactor多线程</li><li>主从Reactor多线程</li></ul></li></ul><p><img src="/image/netty/reactor.png" alt="线程模型简图"></p><ol start="2"><li>单Reactor单线程 AND 单Reactor多线程</li></ol><p><img src="/image/netty/reactor-1.png" alt="单Reactor单线程与单Reactor多线程"></p><p>如上图所示，单Reactor单线程有一个分发器，一个处理器。而单Reactor多线程是它的改进版本，相关细节如下：</p><ul><li>Reactor对象通过select监听客户端请求事件，收到事件后通过 dispatch 进行分发<ul><li>如果是请求连接事件，由Acceptor通过 accept处理连接请求，它会创建一个Handler对象处理连接完成后的各种事件。</li><li>非请求连接事件则由Reactor对象分发到对应的handler处理。<ul><li>handler只负责响应事件，不负责实际的业务处理，通过read读取数据后，会分发给后面的worker线程池的某个线程处理业务<ul><li>worker线程池会分配独立线程完成真正的业务，并将结果返回给handler；handler收到响应后，通过send返回结果给client。</li></ul></li></ul></li></ul></li></ul><ol start="3"><li>主从Reactor多线程</li></ol><p>但是，单Reactor多线程模型仍然存在缺陷。由单个Reactor分发线程，还是存在性能瓶颈。主从Reactor多线程就是为了解决单个Reactor的性能瓶颈，相关细节如下：</p><ul><li>Reactor主线程 MainReactor 对象通过select监听连接事件，收到事件后，通过Acceptor处理连接事件；<ul><li>当 Acceptor 处理连接事件后，MainReactor 将连接分配给 SubReactor；<ul><li>SubReactor 将连接加入到连接队列进行监听，并创建Handler进行事件处理；</li></ul></li></ul></li><li>当新事件发生时，SubReactor 就会调用对应的 handler 处理；<ul><li>handler 通过read读取数据，分发给后面的 worker线程池 处理；<ul><li>worker线程池 分配独立的 worker线程 进行业务处理，并返回结果；</li></ul></li><li>handler 收到响应结果后，再通过 send 将结果返回给 client。</li></ul></li></ul><p><img src="/image/netty/reactor-2.png" alt="主从Reactor多线程"></p><p>主从Reactor多线程实现了请求连接和处理的分离，将连接事件由主线程响应；而请求的读写事件等由子线程进行响应。</p><ol start="4"><li>Reactor模式的构成基础</li></ol><p>而Netty线程模型主要基于主从Reactor多线程模型的改进版本，主从Reactor多线程模型有多个Reactor.</p><ul><li>构成基础<ul><li>基于I/O复用模型（Reactor），多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接；只要有一个及以上的请求接入，就把它们包装成任务分配给其它线程处理。</li><li>基于线程池复用资源（Handlers），通过线程池分配资源执行任务。</li></ul></li><li>设计思想<ul><li>Reactor模式，通过一个或多个输入同时传递给服务器的模式（基于事件驱动）。服务器程序处理传入的多个请求并将它们分配给相应的处理线程，因此它也称之为Dispatcher模式（分发者模式）。</li><li>Reactor模式使用IO复用监听事件，手动事件后分给某个线程，这就是网络服务器高并发处理的关键。</li></ul></li></ul><p>如下图所示，Netty 抽象出两组线程池。其中，BossGroup 专门负责接收客户端连接；而 WorkerGroup 专门负责网络的读写。</p><ul><li>BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup；NioEventLoopGroup 相当于一个事件循环组，该组含有多个事件循环，每个事件循环都是一个 NioEventLoop。<ul><li>NioEventLoop 表示一个不断循环的执行处理任务的线程，每个 NioEventLoop 都有一个 selector, 用于监听绑定在其上的socket网络通讯</li><li>NioEventLoopGroup 可以拥有多个线程（含有多个 NioEventLoop）</li></ul></li><li>BossGroup 循环的步骤<ul><li>轮询 accept事件</li><li>处理 accept事件，与client建立连接，生成 NioSocketChannel，并将其注册到某个 worker NIOEventLoop 上的 selector中</li><li>处理任务队列的任务，即 runAllTasks</li></ul></li><li>WorkerGroup 循环的步骤<ul><li>轮询 read，write事件</li><li>处理I/O事件，调用对应 NioSocketChannel 处理</li><li>处理任务队列的任务，即 runAllTasks</li></ul></li></ul><p><img src="/image/netty/reactor-3.png" alt="Netty模型"></p><h1 id="二、入门"><a href="#二、入门" class="headerlink" title="二、入门"></a>二、入门</h1><p>访问的官网<a href="http://netty.io/，" target="_blank" rel="noopener">http://netty.io/，</a> 从【Downloads】标签页选择下载<code>netty-4.1.60.Final.tar.bz2</code>。如果你习惯使用包管理器，例如maven等。你可以新建一个项目，然后倒入以下的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/io.netty/netty-all --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.1.59.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>通过ServerBootstrap 服务端辅助类来启动服务端代码：</p><ul><li>定义两个线程组，处理客户端的 Accept和读写事件</li><li>绑定NIO服务端通道 NioServerSocketChannel</li><li>为读写事件的线程通道绑定handle，处理具体的业务逻辑</li><li>绑定监听</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import io.netty.bootstrap.Bootstrap;</span><br><span class="line">import io.netty.bootstrap.ServerBootstrap;</span><br><span class="line">import io.netty.buffer.ByteBuf;</span><br><span class="line">import io.netty.buffer.Unpooled;</span><br><span class="line">import io.netty.channel.*;</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line">import io.netty.channel.socket.SocketChannel;</span><br><span class="line">import io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line">import io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line">public class NettyTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class NettySer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new NettySer().bind(9132);</span><br><span class="line">    &#125;</span><br><span class="line">    public void bind(int port) throws Exception &#123;</span><br><span class="line">//            处理处理客户端的 Accept 事件</span><br><span class="line">        EventLoopGroup boss = null;</span><br><span class="line">//            处理客户端读写事件</span><br><span class="line">        EventLoopGroup worker =  null;</span><br><span class="line">//            服务端辅助类</span><br><span class="line">        ServerBootstrap b =  null;</span><br><span class="line">        try &#123;</span><br><span class="line">// 如果不设置线程池的大小，那么默认大小为 CPU核数*2</span><br><span class="line">            boss = new NioEventLoopGroup();</span><br><span class="line">            worker = new NioEventLoopGroup();</span><br><span class="line">            b = new ServerBootstrap();</span><br><span class="line"></span><br><span class="line">//            group：定义两个线程组，bgroup处理客户端的 Accept事件、workerGroup处理读写事件</span><br><span class="line">//            channel：绑定NIO服务端通道 NioServerSocketChannel</span><br><span class="line">//            option：backlog参数指定了等待队列的大小</span><br><span class="line">//            childHandler：绑定handler，处理读写事件，ChannelInitializer是给通道进行初始化</span><br><span class="line">            b.group(boss, worker)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, 1024)</span><br><span class="line">                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(new NettySerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">//          绑定端口</span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">//          监听服务器关闭监听</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class NettySerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">// 处理连接事件</span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;客户端接入&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">// 处理断开事件</span><br><span class="line">    @Override</span><br><span class="line">    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;客户端断开&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">// 处理读取事件</span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf)msg;</span><br><span class="line">        byte[] req = new byte[buf.readableBytes()];</span><br><span class="line">        buf.readBytes(req);</span><br><span class="line">        String body = new String(req, &quot;UTF-8&quot;);</span><br><span class="line">        System.out.println(&quot;From client:&quot;+body);</span><br><span class="line"></span><br><span class="line">        ByteBuf res = Unpooled.copiedBuffer(&quot;to Client: ok&quot;.getBytes());</span><br><span class="line">        ctx.writeAndFlush(res);</span><br><span class="line">    &#125;</span><br><span class="line">// 处理读取完成事件</span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 处理异常事件</span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class NettyCli &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new NettyCli().connect(&quot;127.0.0.1&quot;, 9132);</span><br><span class="line">    &#125;</span><br><span class="line">    public void connect(String host, int port) &#123;</span><br><span class="line">        EventLoopGroup worker =  null;</span><br><span class="line">        Bootstrap bootstrap = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            worker = new NioEventLoopGroup();</span><br><span class="line">            bootstrap = new Bootstrap();</span><br><span class="line">            bootstrap.group(worker)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                        socketChannel.pipeline().addLast(new NettyCliHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture f = bootstrap.connect(host, port).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class NettyCliHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;to Server: connect&quot;.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf)msg;</span><br><span class="line">        byte[] req = new byte[buf.readableBytes()];</span><br><span class="line">        buf.readBytes(req);</span><br><span class="line">        String body = new String(req, &quot;UTF-8&quot;);</span><br><span class="line">        System.out.println(&quot;From Server:&quot;+body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打包和部署"><a href="#打包和部署" class="headerlink" title="打包和部署"></a>打包和部署</h3><p>基于Netty开发的都是非Web的Java应用，它的打包形态非常简单，就是一个普通的jar包，通常情况下，在正式的商业开发中，我们会使用三种打包方式。</p><p>(1) 开发软件提供的导出功能。它可以将指定的Java 或者源码包、代码输出成指定的jar包，它基于下工操作， 在项目模块较多时非常不方便，所以一般不使用这种方式。<br>(2) 使用ant脚本对工程进行打包。将Netty的应用程序打包成指定的<code>．jar</code>    包，一般会输出一个软件安装包： <code>xxxx_install.gz</code><br>(3) 使用Maven进行上程构建。它可以对校块间的依赖进行管理，支持版本的自动化测试、编译和构建，是目前主流的项目管理工具。</p><h1 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h1><p><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">Scalable IO in Java</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、基础&quot;&gt;&lt;a href=&quot;#一、基础&quot; class=&quot;headerlink&quot; title=&quot;一、基础&quot;&gt;&lt;/a&gt;一、基础&lt;/h1&gt;&lt;p&gt;Netty是由JBOSS提供的一个java开源框架，现为 Github上的独立项目。Netty提供异步的、事件驱动的网络应用</summary>
      
    
    
    
    
    <category term="Netty" scheme="http://zws6672.top/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty（三）TCP粘包／拆包</title>
    <link href="http://zws6672.top/2021/03/15/netty-3-decoder/"/>
    <id>http://zws6672.top/2021/03/15/netty-3-decoder/</id>
    <published>2021-03-15T05:09:30.000Z</published>
    <updated>2021-03-15T14:07:40.453Z</updated>
    
    <content type="html"><![CDATA[<p>TCP是个 “流 ” 协议，所谓流，就是没有界限的一串数据。在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送， 也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。</p><h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p>假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下 4 种情况：</p><ul><li>服务端分两次读取到了两个独立的数据包，分别是 D1和D2, 没有粘包和拆包</li><li>服务端一次接收到了两个数据包，D1和D2 粘合在一起，被称为TCP粘包</li><li>服务端分两次读取到了两个数据包，第一次读取到了完整的D1和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包</li><li>服务端分两次读取到了两个数据包，第一次读取到了部分的D1包，第二次读取到了D1包的剩余内容和D2包，这被称为TCP拆包</li></ul><p>如果此时服务端TCP接收滑窗非常小，而数据包 D1和D2 比较大，很有可能会发生第5种可能，即服务端分多次才能将DI和02包接收完全，期间发生多次拆包。</p><ol><li>TCP 粘包／拆包发生的原因：</li></ol><ul><li>应用程序write写入的字节大小大于套接口发送缓冲区大小</li><li>进行MSS 大小的TCP分段</li><li>以太网帧的payload大千MTU进行IP分片</li></ul><ol start="2"><li>MTU和MSS</li></ol><ul><li>MTU: Maxitum Transmission Unit 最大传输单元，一般是 1500 字节</li><li>MSS: Maxitum Segment Size 最大分段大小，用MTU代替（MTU - 数据包包头的大小20Bytes- TCP数据段的包头20Bytes = 1460Bytes）</li></ul><p>在连接建立的时候，即在发送SYN段的时候，同时会将MSS发送给对方（MSS选项只能出现在SYN段中！！！），告诉对端他期望接收的TCP报文段数据部分最大长度。网络传输数据时，数据是最终是要交付到链路层协议上的，也就是说最后要封装成“帧”。二型以太网（Ethernet Type 2）中规定，帧的大小不能超过 1518 个字节（14 字节的帧头 + 4 字节帧校验和 + 最多 1500 字节数据）。所以 IP 数据报的大小如果超过了 1500 字节，要想交付给链路层就必须进行“分片”, 这个值我们就把它称之为MTU。</p><ol start="3"><li>粘包问题的解决策略</li></ol><p>由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决， 根据业界的主流协议的解决方案， 可以归纳如下：</p><ul><li>消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格</li><li>在包尾增加回车换行符进行分割， 例如FTP协议</li><li>将消息分为消息头和消息体， 消息头中包含表示消息总长度（或者消息体长度）的字段， 通常设计思路为消息头的第一个字段使用int32来表示消息的总长度</li><li>更复杂的应用层协议</li></ul><ol start="4"><li>Netty的粘包解决策略</li></ol><p>TCP以流的方式进行数据传输， 上层的应用协议为了对消息进行区分， 往往采用如下4种方式：</p><ul><li>消息长度固定（FixedLengthFrameDecoder）</li><li>将回车换行符作为消息结束符（LineBasedFrameDecoder）</li><li>将特殊的分隔符作为泭息的结束标志（DelimiterBasedFrameDecoder）</li><li>通过在消息头中定义长度字段来标识消息的总长度（LengthFieldBasedFrameDecoder ）</li></ul><p>Netty对上面4种应用做了统一的抽象，提供了4种解码器来解决对应的问题，使用起来非常方便。有了这些解码器， 用户不需要自己对读取的报文进行人工解码，也不需要考虑TCP的粘包和拆包。</p><h1 id="二、四种解码器"><a href="#二、四种解码器" class="headerlink" title="二、四种解码器"></a>二、四种解码器</h1><p>为了解决TCP粘包／拆包导致的半包读写问题，Netty默认提供了多种编解码器用千处理半包，只要能熟练掌握这类库的使用， TCP粘包问题从此会变得非常容易，你甚至不需要关心它们，这也是其他NIO框架和JDK原生的NIO API所无法匹敌的。</p><p>LineBasedFrameDecoder  的工作原理是“它依次遍历ByteBuf中的可读字节，判断看是否有‘\n’或者‘\r\n’，如果有，就在此位置为结束位置，从可读索引到结束位置区间的字节就组成了一行 ”。LineBasedFrameDecoder实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">serverBootstrap.group(boss, worker)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, 1024)</span><br><span class="line">                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(new LineBasedFrameDecoder(1024));</span><br><span class="line">                            socketChannel.pipeline().addLast(new StringDecoder());</span><br><span class="line">                            socketChannel.pipeline().addLast(new NettySerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure><p>LineBasedFrameDecoder 的工作原理是它依次遍历ByteBuf 中的可读字节，判断看是否有“ \n,, 或者” \r\n”， 如果有， 就以此位置为结束位置，从可读索引到结束位置区间的字节就组成了一行。它是以换行符为结束标志的解码器， 支持携带结束符或者不携带结束符两种解码方式，同时支持配置单行的最大长度。如果连续读取到最大长度后仍然没有发现换行符，就会抛出异常，同时忽略掉之前读到的异常码流。</p><p>StringDecoder 的功能非常简单，就是将接收到的对象转换成字符串，然后继续调用后面的Handler。LineBasedFrameDecoder + StringDecoder 组合就是按行切换的文本解码器，它被设计用来支持TCP 的粘包和拆包。</p><p>还有另外两种解码器：DelirnitcrBasedFrameDecoder和 FixedLengthFrameDecoder,前者可以自动完成以分隔符做结束标志的消息的解码， 后者可以自动完成对定长消息的解码，它们都能解决TCP粘包／拆包导致的读半包问题。</p><p>DelimiterBasedFrameDecoder实例如下，可以自定义分隔符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.group(boss, worker)</span><br><span class="line">.channel(NioServerSocketChannel.class)</span><br><span class="line">.option(ChannelOption.SO_BACKLOG, 1024)</span><br><span class="line">.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">socketChannel.pipeline().addLast(new LineBasedFrameDecoder(1024));</span><br><span class="line">socketChannel.pipeline().addLast(new StringDecoder());</span><br><span class="line">socketChannel.pipeline().addLast(new NettySerHandler());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">class NettySerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;客户端接入&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;客户端断开&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;From client:&quot;+msg);</span><br><span class="line">        ByteBuf res = Unpooled.copiedBuffer(&quot;to Client: ok$_$&quot;.getBytes());</span><br><span class="line">        ctx.writeAndFlush(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FixedLengthFrameDecoder 固定长度解码器，它能够按照指定的长度对消息进行自动解码，开发者不需要考虑 TCP 的粘包与拆包问题，非常实用。无论一次接收到多少数据报，它都会按照构造器中设置的固定长度进行解码，如果是半包消息，FixedLengthFrameDecoder  会缓存半包消息并等待下个包到达之后进行拼包合并，直到读取一个完整的消息包。</p><p>如果消息长度不够，则使用空位填补空缺，这样读取到了之后，只需要 trim 去掉空格即可。如果消息不够长，那么就会存储起来。</p><p>FixedLengthFrameDecoder 实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.group(worker)</span><br><span class="line">.channel(NioSocketChannel.class)</span><br><span class="line">.option(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">socketChannel.pipeline().addLast(new FixedLengthFrameDecoder(10));</span><br><span class="line">socketChannel.pipeline().addLast(new StringDecoder());</span><br><span class="line">socketChannel.pipeline().addLast(new NettyCliHandler());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TCP是个 “流 ” 协议，所谓流，就是没有界限的一串数据。在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送， 也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。&lt;/p&gt;
&lt;h1 id=&quot;一、基础&quot;&gt;&lt;a href=&quot;#一、基础&quot; </summary>
      
    
    
    
    
    <category term="Netty" scheme="http://zws6672.top/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty（一）网络I/O模型的Java实现</title>
    <link href="http://zws6672.top/2021/03/15/netty-1-unix/"/>
    <id>http://zws6672.top/2021/03/15/netty-1-unix/</id>
    <published>2021-03-15T05:01:03.000Z</published>
    <updated>2021-03-19T05:16:52.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p>Java 1.4之前的早期版本，Java对I/O的支持并不完善，开发人员在开发高性能I/O程序的时候，会面临一些巨大的挑战和困难，主要问题如下：</p><ul><li>没有数据缓冲区，I/O性能存在问题；</li><li>没有C或者C+＋中的Channel概念，只有输入和输出流；</li><li>同步阻塞式I/0通信(BIO)，通常会导致通信线程被长时间阻塞；</li><li>支持的字符集有限，硬件可移植性不好。</li></ul><p>Linux的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个 file descriptor (fd, 文件描述符）。而对一个 socket 的读写也会有相应的描述符，称为 socketfd (socket 描述符），描述符就是一个数字，它指向内核中的一个结构体（文件路径， 数据区等一些屈性）。</p><ol><li>UNIX的网络I/O模型</li></ol><p>UNIX提供了5种网络I/O模型:</p><ul><li><p>阻塞I/O模型：客户端向服务器端发出请求后，客户端会一直处于等待状态（不会再做其他事情），直到服务器端返回结果或者网络出现问题 ，服务器端同样如此。进程只处理一个请求，并且全程是阻塞的。</p></li><li><p>非阻塞I/O模型：recvfrom 从应用层到内核的时候， 如果该缓冲区没有数据的话，<br>就直接返回一个EWOULDBLOCK错误。一般都会对非阻塞I/O模型进行轮询，查看缓冲区是否有数据。进程只处理一个请求，通过轮询重复调用尝试获取结果。</p></li><li><p>I/O复用模型：Linux提供select/poll. 进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select操作上，这样select/poll 可以帮我们侦测多个fd是否处于就绪状态。select/poll是顺序扫描fd是否就绪，而且支持的fd数目有限，因此它的使用受到了一些制约。Linux还提供了 个epoll系统调用，epoll使用基于事件驱动方式代替顺序扫描，因此性能更高。当有fd就绪时，立即回调函数rollback。用户调用select时，进程被阻塞，这时候会轮询多个流，当有一个或多个准备好后返回；select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p></li><li><p>信号驱动I/O模型（嵌入式使用较多）：首先开启套接口信号驱动I/O功能，并通过系统调用sigaction 执行一个信号处理函数（此系统调用立即返回， 进程继续工作，它是非阻塞的）。当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom 来读取数据，并通知主循环函数处理数据。无论如何处理 SIGIO 信号，这种模型的优势在于等待数据报到达(第一阶段)期间，进程可以继续执行，不被阻塞。免去了select 的阻塞与轮询，当有活跃套接字时，由注册的 handler 处理。</p></li><li><p>异步I/O：告知内核启动某个操作，并让内核在整个操作完成后（包括将数据从 内核复制到用户自己的缓冲区）通知我们。 这种模型与信号驱动模型的主要区别是： 信号驱动I/O由内核通知我们何时可以开始一个I/O操作； 异步I/O模型由内核通知我们I/O操作何时已经完成。</p></li></ul><ol start="2"><li>I/O多路复用技术</li></ol><p>在I/O编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者I/O多路复用技术进们处理。I/O多路复用技术通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。目前支待I/O多路复用的系统调用有select、 pselect、 poll、 epoll，select轮询存在缺陷，所以Linux内核用了epoll替代了select。</p><p>epoll的特点如下：</p><ul><li>支持一个进程打开的 socket 描述符 (FD) 不受限制（仅受限于操作系统的最大文件句柄数，）。select最大的缺陷就是单个进程所打开的 FD 是有一定限制的， 它由 FD_SETSIZE 设置，默认值是1024。epoll 并没有这个限制，它所支持的 FD 上限是操作系统的最大文件句柄数，具体的值可以通过 cat /proc/sys/fs/file- max 查看。</li><li>I/O效率不会随若 FD数目的增加而线性下降。epoll 是根据每个 fd 上面的 callback 函数实现的，只有 “活跃 ” 的 socket 才会去主动调用 callback 函数。</li><li>使用 mmap 加速内核与用户空间的消息传递。</li><li>epoll的API更加简单。</li></ul><ol start="3"><li>Java 的I/O</li></ol><p>在JDK1.4推出Java NIO之前，基于Java的所有Socket通信都采用了同步阻塞模式(BIO)，这种请求————应答的通信梑型简化了上层的应用开发 ，但是在性能和可靠性方面 却存在若巨大的瓶颈。JDKl.4版本提供了新的NIO类库，也可以支持非阻塞I/O了。</p><p>JDK1.4 时 ， NIO 以 JSR-51 的身份正式随 JDK 发布。 它新增了个 java.nio 包， 提供了很多 进行异步I/O开发的 API 和类库， 主要的类和接口如下：</p><ul><li>进行异步I/O操作的缓冲区 ByteBuffer 等； 进行异步I/O操作的管道 Pipe;</li><li>进行各种I/O操作（异步或者同步）的 Channel, 包括 ServerSocketChannel 和SocketChannel; </li><li>多种字符集的编码能力和解码能力；</li><li>实现非阳塞I/O操作的多路复用器 selector;</li><li>基于流行的 Perl 实现的正则表达式类库；</li><li>文件通道 FileChannel。</li></ul><ol start="4"><li>AIO</li></ol><p>NIO 2.0引入了新的异步通道的概念，并提供了异步文件通道和异步套接宇通道的实现。异步通道提供以下两种方式获取获取操作结果：</p><ul><li>通过java.uti.concurrent.Future类来表示异步操作的结果 </li><li>使用回调函数</li></ul><p>NIO 2.0的异步套接字通道是真正的异步非阻塞I/O,对应的UNIX网络编程中的事件 驱动I/O (AIO)。 它不需要通过多路复用器(Selector)对注册的通道进行轮询操作即可实现异步读写，从而简化了NIO的编程模型。</p><h1 id="二、同步阻塞式I-O（BIO）"><a href="#二、同步阻塞式I-O（BIO）" class="headerlink" title="二、同步阻塞式I/O（BIO）"></a>二、同步阻塞式I/O（BIO）</h1><p>网络编程的基本模型是 Clieot/Server 模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息（绑定的IP地址和监听端口）， 客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接;如果连接建立成功，双方就可以通过网络套接字 (Socket) 进行通信。</p><p>BIO服务端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">public class BIOServerTest &#123;</span><br><span class="line">    public static void main (String[] args) throws IOException &#123;</span><br><span class="line">        int port = 8080;</span><br><span class="line"></span><br><span class="line">        if(args!=null &amp;&amp; args.length&gt;0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                port = Integer.parseInt(args[0]);</span><br><span class="line">            &#125;  catch (NumberFormatException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ServerSocket server = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //从连接队列中取出一个连接，如果没有则等待</span><br><span class="line">            server = new ServerSocket(port);</span><br><span class="line">            Socket socket = null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                socket = server.accept();</span><br><span class="line">                new Thread(new BIOServerHandler(socket)).start();</span><br><span class="line">            &#125;  catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;  finally &#123;</span><br><span class="line">                if (server != null) &#123;</span><br><span class="line">                    server.close();</span><br><span class="line">                    server = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line">            if (server!=null) &#123;</span><br><span class="line">                server.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BIOServerHandler implements Runnable&#123;</span><br><span class="line">    private Socket socket;</span><br><span class="line"></span><br><span class="line">    public BIOServerHandler(Socket socket) &#123;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        PrintWriter out = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = new PrintWriter(socket.getOutputStream(), true);</span><br><span class="line">            String body = null;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">//                获取客户端报文</span><br><span class="line">                body = in.readLine();</span><br><span class="line">                if (body == null) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">//                触发回馈</span><br><span class="line">                if (&quot;QUERY TIME ORDER&quot;.equals(body)) &#123;</span><br><span class="line">                    SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">                    out.println(format.format(new Date()));</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;Client body：&quot;+body);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line">            if(out != null) &#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(in != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                in = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(socket != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BIO客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class BIOClientTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        int port = 8080;</span><br><span class="line">        // 端口参数检测</span><br><span class="line">        if(args!=null &amp;&amp; args.length&gt;0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                port = Integer.parseInt(args[0]);</span><br><span class="line">            &#125;  catch (NumberFormatException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Socket socket = null;</span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        PrintWriter out = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            socket = new Socket(&quot;127.0.0.1&quot;, port);</span><br><span class="line">            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = new PrintWriter(socket.getOutputStream(), true);</span><br><span class="line">//            查询指令</span><br><span class="line">            out.println(&quot;QUERY TIME ORDER&quot;);</span><br><span class="line">//            获取回馈</span><br><span class="line">            String resp = in.readLine();</span><br><span class="line">            System.out.println(&quot;The resp：&quot;+ resp);</span><br><span class="line"></span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line">            if(out != null) &#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(in != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                in = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(socket != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步式IO的相关代码如上所示。但是存在一个问题，就是当存在一个服务端连接只能处理一个客户端连接，效率过低。而高性能的服务器，需要同时处理成千上万的客户端连接，这种模型是无法满足并发要求的。当然我们也可以基于线程池和同步阻塞式I/O构建伪异步IO,将Socket封装成任务异步调用，客户端代码不变，底层仍然是同步阻塞的。</p><h1 id="三、非阻塞式IO（NIO）编程"><a href="#三、非阻塞式IO（NIO）编程" class="headerlink" title="三、非阻塞式IO（NIO）编程"></a>三、非阻塞式IO（NIO）编程</h1><p>NIO（JDK1.4）模型是一种同步非阻塞IO，主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector（多路复用器）。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(多路复用器)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol start="0"><li>NIO和BIO的比较</li></ol><p>BIO，即阻塞IO；而NIO是非阻塞IO。<br>BIO是以流的方式处理数据；而NIO是以块的方式处理数据。<br>BIO是基于字节流和字符流操作；而NIO基于 Channel和Buffer 进行操作，通过通道读取数据到缓冲区，或者通过缓冲区写入到通道中。Selector（选择器）用于监听多个通道的事件，因此可以通过单线程监听多个连接。</p><ol><li>缓冲区Buffer</li></ol><p>Buffer是一个对象，它包含一些要写入或者要读出的数据。在 NIO 类库中加入 Buffer对象，体现了新库与原IO的一个重要区别。在“面向流的”IO 中，可以将数据直接写入或者将数据直接读到 Stream 对象中。</p><p>它是NIO重要的组成部分，表明了NIO是面向缓冲区的而不是流。在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，写入到缓冲区中。任何时候访问 NIO 中的数据，都是通过缓冲区进行操作。</p><p>缓冲区是一个可读取的内存，实质上是一个数组。通常它是一个字节数组 (ByteBuffer)， 也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组。缓冲区提供了对数据的结构化访问以及维护读写位置 (limit) 等信息 。</p><ul><li>Buffer<ul><li>ByteBuffer: 字节缓冲区<ul><li>MappedByteBuffer：支持文件在内存中修改，使用的是堆外内存</li></ul></li><li>CharBuffer: 字符缓冲区</li><li>ShortBuffer：短整型缓冲区</li><li>IntBuffer：整形缓冲区</li><li>LongBuffer: 长整形缓冲区</li><li>FloatBuffer：浮点型缓冲区</li><li>DoubleBuffer: 双精度浮点型缓冲区</li></ul></li></ul><p>Buffer读写数据的步骤如下：</p><ul><li>把数据写入buffer；</li><li>调用flip，把buffer从写模式调整为读模式；在读模式下，可以读取所有已经写入的数据。</li><li>从Buffer中读取数据；</li><li>调用buffer.clear()或者buffer.compact()；clear会清空整个buffer，compact则只清空已读取的数据。</li></ul><p>Buffer缓冲区实质上就是一块内存，可以进行读取和写入。Buffer有四个属性是必备的，分别是：</p><ul><li>capacity容量：是缓冲区可容纳的最大数据量，缓冲区创建时设置且不可更改。</li><li>limit限制：表示缓冲区的当前终点，不能对超过的位置进行读写操作</li><li>position位置：下一个要读或者要写的索引，每次读写缓冲区都会改值</li><li>mask：标记，用于position的临时保存。调用mask()设置mask=position，再调用reset()可以让position恢复它原来的位置</li></ul><blockquote><p>注：NIO还支持通过多个Buffer数组完成读写操作，即Buffer的分散和聚集。分散，是数据写入多个buffer；聚集是从多个buffer读取数据<br>Buffer的常见方法：</p></blockquote><table><thead><tr><th align="left">方法</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">abstract Object array()</td><td align="left">返回支持此缓冲区的数组 （可选操作）</td></tr><tr><td align="left">abstract int arrayOffset()</td><td align="left">返回该缓冲区的缓冲区的第一个元素的在数组中的偏移量 （可选操作）</td></tr><tr><td align="left">int capacity()</td><td align="left">返回此缓冲区的容量</td></tr><tr><td align="left">Buffer clear()</td><td align="left">清除此缓存区。将position = 0;limit = capacity;mark = -1;</td></tr><tr><td align="left">Buffer flip()</td><td align="left">flip()方法可以吧Buffer从写模式切换到读模式。调用flip方法会把position归零，并设置limit为之前的position的值。 也就是说，现在position代表的是读取位置，limit标示的是已写入的数据位置。</td></tr><tr><td align="left">abstract boolean hasArray()</td><td align="left">告诉这个缓冲区是否由可访问的数组支持</td></tr><tr><td align="left">boolean hasRemaining()</td><td align="left">return position &lt; limit，返回是否还有未读内容</td></tr><tr><td align="left">abstract boolean isDirect()</td><td align="left">判断个缓冲区是否为 direct</td></tr><tr><td align="left">abstract boolean isReadOnly()</td><td align="left">判断告知这个缓冲区是否是只读的</td></tr><tr><td align="left">int limit()</td><td align="left">返回此缓冲区的限制</td></tr><tr><td align="left">Buffer position(int newPosition)</td><td align="left">设置这个缓冲区的位置</td></tr><tr><td align="left">int remaining()</td><td align="left">return limit - position; 返回limit和position之间相对位置差</td></tr><tr><td align="left">Buffer rewind()</td><td align="left">把position设为0，mark设为-1，不改变limit的值</td></tr><tr><td align="left">Buffer mark()</td><td align="left">将此缓冲区的标记设置在其位置</td></tr></tbody></table><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main (String[] args) &#123;</span><br><span class="line">        IntBuffer intBuffer = IntBuffer.allocate(24);</span><br><span class="line">        for (int i=0; i&lt;24; i++) &#123;</span><br><span class="line">            intBuffer.put((int) (Math.random()*100));</span><br><span class="line">        &#125;</span><br><span class="line">        intBuffer.flip(); // 读写切换</span><br><span class="line"></span><br><span class="line">        while (intBuffer.hasRemaining()) &#123; // 测试是否有数据</span><br><span class="line">            // Buffer 内部维持一个索引</span><br><span class="line">            System.out.println(intBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">intBuffer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>通道Channel</li></ol><p>Channel是一个通道，网络数据通过Channel同时读取和写入。通道与流的不同之处在千通道是双向的，流只是在一个方向上移动（一个流必须是InputStream 或者 OutputStream 的子类），而通道可以用于读、写或者二者同时进行。因为 Channel 是全双工的，所以它可以比流更好地映射底层操作系统的 API。</p><ul><li>特点<ul><li>同时读写</li><li>异步读写</li><li>可以从缓冲区读写数据</li></ul></li><li>常用Channel（抽象类）<ul><li>FileChannel： 文件的数据读写                </li><li>SocketChannel： TCP的数据读写，一般是客户端实现</li><li>ServerSocketChannel: 允许我们监听TCP链接请求，每个请求会创建会一个SocketChannel，一般是服务器实现</li><li>DatagramChannel： UDP的数据读写</li></ul></li><li>相关方法<ul><li>int read(ByteBuffer dst) 从通道读取数据</li><li>int write(ByteBuffer src) 写入数据到通道</li><li>long transferFrom(ReadableByteChannel src,long position, long count) 从目标通道复制数据到当前通道</li><li>long transferTo(long position, long count,WritableByteChannel target) 从当前通道复制数据到目标通道</li></ul></li></ul><p>接口源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Channel extends Closeable &#123;</span><br><span class="line">    public boolean isOpen();</span><br><span class="line">    public void close() throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>transferFrom实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main (String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    FileInputStream fis = new FileInputStream(&quot;E:\\wsz6672\\ws6672.github\\source\\image\\19819\\a2.png&quot;);</span><br><span class="line">    FileOutputStream fos = new FileOutputStream(new File(&quot;E:\\wsz6672\\ws6672.github\\source\\image\\19819\\b1-copy.png&quot;));</span><br><span class="line"></span><br><span class="line">    FileChannel fromC = fis.getChannel();</span><br><span class="line">    FileChannel toC = fos.getChannel();</span><br><span class="line">    toC.transferFrom(fromC, 0,fromC.size());</span><br><span class="line"></span><br><span class="line">    fromC.close();</span><br><span class="line">    toC.close();</span><br><span class="line">    fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通道Channel的实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class ChannelTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FileChannel fileChannel = null;</span><br><span class="line">        RandomAccessFile raf = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            raf = new RandomAccessFile(&quot;F://test.txt&quot;,&quot;rw&quot;);</span><br><span class="line">            fileChannel = raf.getChannel();</span><br><span class="line">            int buf_size = 512;</span><br><span class="line">            if(buf_size&gt;fileChannel.size()) &#123;</span><br><span class="line">                buf_size = (int)fileChannel.size();</span><br><span class="line">            &#125;</span><br><span class="line">            ByteBuffer readbuf = ByteBuffer.allocate(buf_size);</span><br><span class="line">//            ByteBuffer writebuf = ByteBuffer.allocate(buf_size);</span><br><span class="line"></span><br><span class="line">            while (fileChannel.read(readbuf) &gt;0) &#123;</span><br><span class="line">                readbuf.flip();</span><br><span class="line">// 就是判断position和limit之间是否有元素</span><br><span class="line">                System.out.print(Charset.forName(&quot;UTF-8&quot;).decode(readbuf).toString());</span><br><span class="line">                readbuf.clear();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (fileChannel != null) &#123;</span><br><span class="line">                    fileChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if (fileChannel != null) &#123;</span><br><span class="line">                    fileChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if (raf != null) &#123;</span><br><span class="line">                    raf.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>多路复用器Selector</li></ol><p>多路复用器提供选择已经就绪的任务的能力，Selector会不断地轮询注册在其上的 Channel, 如果某个 Channel 上面发生读或者写事件， 这个 Channel 就处于就绪状态，会被 Selector 轮询出来，然后通过 SelectionKey 可以获取就绪 Channel 的集合，进行后续的 I/O 操作。一个多路复用器 Selector 可以同时轮询多个 Channel, 由千 JDK 使用了 epoll(）代替传统的 select 实现 ， 所以它并没有最大连接句柄 1024/2048 的限制。这也就意味着只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端.</p><p>Selector能够检测多个注册的通道是否有事件发生，多个Channel以事件的方式注册到同一个 Selector。只有在连接通道有读写事件发生时才进行相应的处理，减少了多线程切换的开销，避免了阻塞导致的性能下降。一个I/O线程可以并发处理N个客户端连接和读写操作，从根本上解决了同步阻塞模型一连接一线程模型的低效问题，架构的性能、弹性伸缩能力和可靠性得到了极大的提升。</p><ul><li>源码<ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Selector implements Closeable &#123;</span><br><span class="line"></span><br><span class="line">// 初始化类实例</span><br><span class="line">protected Selector() &#123; &#125;</span><br><span class="line"></span><br><span class="line">//打开一个多路复用器</span><br><span class="line">public static Selector open() throws IOException &#123;</span><br><span class="line">return SelectorProvider.provider().openSelector();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试多路复用器是否打开</span><br><span class="line">public abstract boolean isOpen();</span><br><span class="line">//返回通道创建者</span><br><span class="line">public abstract SelectorProvider provider();</span><br><span class="line">//当前连接的keys</span><br><span class="line">public abstract Set&lt;SelectionKey&gt; keys();</span><br><span class="line">//访问“已选择键集（selected key set）”中的就绪通道</span><br><span class="line">public abstract Set&lt;SelectionKey&gt; selectedKeys();</span><br><span class="line"></span><br><span class="line">//不会阻塞，不管什么通道就绪都立刻返回</span><br><span class="line">public abstract int selectNow() throws IOException;</span><br><span class="line"></span><br><span class="line">//和select()一样，除了设置最长阻塞时间timeout毫秒</span><br><span class="line">public abstract int select(long timeout) throws IOException;</span><br><span class="line">//阻塞,直到至少有一个通道就绪</span><br><span class="line">public abstract int select() throws IOException;</span><br><span class="line">public abstract void close() throws IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="4"><li>三大核心的关系</li></ol><ul><li>Selector 对应一个线程，一个线程对应多个Channel；每个Channel对应一个Buffer。</li><li>Selector切换到哪一个通道由监听到的事件决定，它会根据不同的事件在不同的通道上切换。</li><li>Buffer是一个内存块，底层是一个数组；可读可写，但是需要通过flip 方法切换。</li><li>channel是双向的</li></ul><h3 id="java实现NIO"><a href="#java实现NIO" class="headerlink" title="java实现NIO"></a>java实现NIO</h3><ol><li>reactor（反应器）模式</li></ol><p>使用单线程模拟多线程，提高资源利用率和程序的效率，增加系统吞吐量。单线程下要多个操作执行完成后才处理其它请求，伪多线程是在单线程处理某些需要长时间等待的操作时，先处理其它请求。</p><ol start="2"><li>服务端和客户端序列图 </li></ol><p><img src="/image/netty/nio-server-time.png" alt="NIO 服务端序列图"></p><p><img src="/image/netty/nio-client-time.png" alt="NIO 客户端序列图"></p><ol start="3"><li>SocketChannel的方法</li></ol><p>register() 方法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final SelectionKey register(Selector sel, int ops)</span><br><span class="line">        throws ClosedChannelException</span><br></pre></td></tr></table></figure><p>第一个参数是 多路复用器，第二个参数是监听的事件，相关事件如下：</p><ul><li>SelectionKey.OP_ACCEPT 接收就绪（服务器准备好接收连接）,16</li><li>SelectionKey.OP_CONNECT 连接就绪（通道连接到服务器）,8</li><li>SelectionKey.OP_WRITE 写就绪,4</li><li>SelectionKey.OP_READ 读就绪,1</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static final int OP_ACCEPT = 1 &lt;&lt; 4;</span><br><span class="line">public static final int OP_CONNECT = 1 &lt;&lt; 3;</span><br><span class="line">public static final int OP_WRITE = 1 &lt;&lt; 2;</span><br><span class="line">public static final int OP_READ = 1 &lt;&lt; 0;</span><br></pre></td></tr></table></figure></li></ul><p>我们也可以同时监听多个事件：<code>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE</code>。</p><ol start="4"><li>SelectionKey</li></ol><p>SelectionKey表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key.attachment(); //返回SelectionKey的attachment，attachment可以在注册channel的时候指定。</span><br><span class="line">key.channel(); // 返回该SelectionKey对应的channel。</span><br><span class="line">key.selector(); // 返回该SelectionKey对应的Selector。</span><br><span class="line">key.interestOps(); //返回代表需要Selector监控的IO操作的bit mask</span><br><span class="line">key.readyOps(); // 返回一个bit mask，代表在相应channel上可以进行的IO操作。</span><br></pre></td></tr></table></figure><ol start="5"><li>NIO 服务端和客户端示例</li></ol><p>服务端如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.ServerSocketChannel;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/8 13:55</span><br><span class="line"> * @Description TODO</span><br><span class="line"> */</span><br><span class="line">public class NIOTest implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private int port;</span><br><span class="line">    //用于轮询的多路复用器</span><br><span class="line">    private Selector selector;</span><br><span class="line">    // 服务器通道</span><br><span class="line">    private ServerSocketChannel acceptor;</span><br><span class="line"></span><br><span class="line">    private ServerSocket serverSocket;</span><br><span class="line"></span><br><span class="line">    public NIOTest() &#123;</span><br><span class="line">        this(9999);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NIOTest(int port) &#123;</span><br><span class="line">        this.port = port;</span><br><span class="line">        try &#123;</span><br><span class="line">//          1. 监听客户端连接</span><br><span class="line">            acceptor = ServerSocketChannel.open();</span><br><span class="line">//          2. 绑定端口、用通道对象生成服务器对象、为服务端Socket绑定监听端口</span><br><span class="line">            acceptor.configureBlocking(false);</span><br><span class="line">            serverSocket = acceptor.socket();</span><br><span class="line">            serverSocket.bind(new InetSocketAddress(&quot;localhost&quot;, port));</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            acceptor.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            System.out.println(&quot;Server Start&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (selector!=null &amp;&amp; selector.isOpen()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                selector.select(1000);</span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">                SelectionKey key = null;</span><br><span class="line">                while (it.hasNext()) &#123;</span><br><span class="line">                    key = it.next();</span><br><span class="line">                    it.remove();</span><br><span class="line">                    handleAccept(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void handleAccept(SelectionKey key) &#123;</span><br><span class="line"></span><br><span class="line">        if (key.isValid()) &#123;</span><br><span class="line">            if (key.isAcceptable()) &#123;</span><br><span class="line">//                在多路复用器注册客户端连接</span><br><span class="line">                SocketChannel sc = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    sc = ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line">                    if (sc != null) &#123;</span><br><span class="line">                        sc.configureBlocking(false);</span><br><span class="line">                        sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;  catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (key.isReadable()) &#123;</span><br><span class="line">//               处理客户端连接请求</span><br><span class="line">                handleRead(key);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;客户端请求完成&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void handleRead(SelectionKey key) &#123;</span><br><span class="line">        SocketChannel sc = null;</span><br><span class="line">        ByteBuffer buffer = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            sc = (SocketChannel)key.channel();</span><br><span class="line">            //创建缓存区</span><br><span class="line">            buffer = ByteBuffer.allocate(1024);</span><br><span class="line">            int byteSize = sc.read(buffer);</span><br><span class="line">            if (byteSize==-1) &#123;</span><br><span class="line">                sc.shutdownInput();</span><br><span class="line">                sc.shutdownOutput();</span><br><span class="line">                sc.close();</span><br><span class="line">                System.out.println(&quot;连接断开&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                byte[] data = new byte[buffer.remaining()];</span><br><span class="line">                buffer.get(data);</span><br><span class="line">                buffer.clear();</span><br><span class="line">                String content = new String(data);</span><br><span class="line">                System.out.println(&quot;Server receiver message: &quot;+content);</span><br><span class="line">                respon(sc, &quot;from Server&apos;s respon&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void respon(SocketChannel sc, String message) &#123;</span><br><span class="line">        ByteBuffer buffer = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (message != null &amp;&amp; message.length() != 0) &#123;</span><br><span class="line">                byte[] data = message.getBytes();</span><br><span class="line">                buffer = ByteBuffer.allocate(1024);</span><br><span class="line">                buffer.put(data);</span><br><span class="line">                buffer.flip();</span><br><span class="line">                sc.write(buffer);</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        NIOTest nioTest = new NIOTest(9999);</span><br><span class="line">        new Thread(nioTest).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/9 22:15</span><br><span class="line"> * @Description TODO</span><br><span class="line"> */</span><br><span class="line">public class NIOClient implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private String  host;</span><br><span class="line">    private int port;</span><br><span class="line">    private Selector selector;</span><br><span class="line">    private SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    public NIOClient() &#123;</span><br><span class="line">        this(&quot;localhost&quot;, 9999);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NIOClient(String  host, int port) &#123;</span><br><span class="line">        this.host = host;</span><br><span class="line">        this.port = port;</span><br><span class="line">        try &#123;</span><br><span class="line">            socketChannel = SocketChannel.open();</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            socketChannel.configureBlocking(false);</span><br><span class="line">            socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;,port));</span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (selector != null &amp;&amp; selector.isOpen()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                selector.select(1000);</span><br><span class="line">                //获得所有已就绪的通道</span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">                SelectionKey key = null;</span><br><span class="line">                while(it.hasNext()) &#123;</span><br><span class="line">                    key = it.next();</span><br><span class="line">                    it.remove();</span><br><span class="line">                    handleInput(key);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;  catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void send (SocketChannel sc,String content) &#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);</span><br><span class="line">        if (content!=null &amp;&amp; content.length() != 0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                byte[] data = content.getBytes();</span><br><span class="line">                byteBuffer.put(data);</span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                sc.write(byteBuffer);</span><br><span class="line">            &#125;  catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void handleInput(SelectionKey key) &#123;</span><br><span class="line">        SocketChannel sc = null;</span><br><span class="line">        if (key.isValid()) &#123;</span><br><span class="line">            if (key.isConnectable()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    sc = (SocketChannel) key.channel();</span><br><span class="line">                    if (sc.finishConnect()) &#123;</span><br><span class="line">                        sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                        send(sc, &quot;client send message&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;  catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (key.isReadable()) &#123;</span><br><span class="line">                handleRead(key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void handleRead(SelectionKey key) &#123;</span><br><span class="line">        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">        try &#123;</span><br><span class="line">            int byte_size = sc.read(buffer);</span><br><span class="line">            if (byte_size&gt;0) &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                byte[] data = new byte[buffer.remaining()];</span><br><span class="line">                buffer.get(data);</span><br><span class="line">                buffer.clear();</span><br><span class="line">                String content = new String(data);</span><br><span class="line">                System.out.println(content);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //表示读取数据失败,需要释放资源</span><br><span class="line">                key.cancel();</span><br><span class="line">                sc.close();</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        NIOClient nioClient = new NIOClient();</span><br><span class="line">        new Thread(nioClient).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上例子可知，NIO编程的难度确实比同步阻塞BIO的大很多，在上面的实例中还没考虑半包读、半包写、编码解码等问题。虽然NIO编写复杂，但是它还是在网络编程中应用广泛，优点如下：</p><ul><li>客户端发起的连接操作是异步的，无须阻塞</li><li>SocketChannel的读写操作都是异步的， 如果没有可读写的数据它不会同步 等待，直接返回 ， 这样I/O通信线程就可以处理其他的链路， 不需要同步等待这个链路可用。</li><li>线程模型的优化，通过epoll避免了连接限制。</li></ul><hr><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>虽然有五种网络通信的IO方式，但是Java只实现了四种（没有信号驱动I/O模型）。</p><p>相关概念如下：</p><ul><li>异步非阻塞 I/O：很多人喜欢将JDK 1.4提供的NlO框架称为异步非阻塞 I/O， 但是，如果严格按照UNIX网络编程 模型和JDK的实现进行区分， 实际上它只能被称为非阻塞VO, 不能叫异步非阻塞 I/O。由JDKl.7提供的NIO2.0新增了异步的套接字通道， 它是真正的异步 I/O, 在异步 I/O 操作的时候可以传递信号变晁， 当操作完成之后会回调相关的方法，异步I/O也被称为AIO</li><li>多路复用器 Selector：多路复用的核心就是通过 Selector 来轮询注册在其上的 Channel，当发现某个或者多个 Channel 处于就绪状态后 ，从阻塞状态返回就绪的 Channel 的选择键集合，进行 I/O 操作 。 </li><li>伪异步I/O：在通信线程和业务线程之间做个缓冲区， 这个缓冲区用千隔离I/O线程和业务线程间的直接访问， 这样业务线程就不会被 I/O线程阻塞。线程接收连接，将连接封装为Task后放到线程池中然后返回去处理其它的请求。</li></ul><p>基于NIO的网络框架NIO是一种网络并发解决方案，使用广泛。但是，Netty不是全能的，具体选择什么样的I/O 模型或者NIO框架， 完全基于业务的实际应用场景和性能诉求，如果客户端并发连接数不多，周边对接的网元不多，服务器的负载也不重， 那就完全没必要选择NlO做服务端；如果是相反情况，那就要考虑选择合适的 NIO框架进行开发。</p><p>不选择 Java 原生 NIO 编程的原因：</p><ul><li>NIO 的类库和 API 繁杂，使用麻烦， 你需要熟练掌握 Selector 、 ServerSocketChannel、 SocketChannel、 ByteBuffer</li><li>需要熟悉 Java 多线程编程等额外技能</li><li>可靠性差</li><li>JDK NIO 的 BUG, 例如臭名昭著的 epoll bug, 它会导致 Selector 空轮询， 最终导 致 CPU 100%</li></ul><p>如果需要开发一个网络并发组件，那么Netty值得一试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、基础&quot;&gt;&lt;a href=&quot;#一、基础&quot; class=&quot;headerlink&quot; title=&quot;一、基础&quot;&gt;&lt;/a&gt;一、基础&lt;/h1&gt;&lt;p&gt;Java 1.4之前的早期版本，Java对I/O的支持并不完善，开发人员在开发高性能I/O程序的时候，会面临一些巨大的挑战和</summary>
      
    
    
    
    
    <category term="Netty" scheme="http://zws6672.top/tags/Netty/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>微言术语</title>
  
  
  <link href="http://zws6672.top/atom.xml" rel="self"/>
  
  <link href="http://zws6672.top/"/>
  <updated>2021-05-15T14:22:56.016Z</updated>
  <id>http://zws6672.top/</id>
  
  <author>
    <name>古城烟雨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于FMI标准的仿真软件————Daccosim</title>
    <link href="http://zws6672.top/2021/05/15/fmi-daccosim/"/>
    <id>http://zws6672.top/2021/05/15/fmi-daccosim/</id>
    <published>2021-05-15T14:20:52.000Z</published>
    <updated>2021-05-15T14:22:56.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、FMI"><a href="#一、FMI" class="headerlink" title="一、FMI"></a>一、FMI</h1><ol><li>什么是FMI</li></ol><p>FMI代表“ Functional Mock-up Interface ”，是MODELISAR项目中的一项重要开发工作。FMI规范允许任何建模工具生成代表动态系统模型的C代码或二进制文件，然后可以将其无缝集成到另一个建模和仿真环境中。</p><p>共同仿真规范的FMI处理带有内置求解器和仿真工具耦合的模型。规范分为执行部分和模型描述部分（XML模式）。总之，实现任何FMI规范的FMU（功能模拟单元）均由以下组成：</p><ul><li>XML模型描述。</li><li>以二进制和/或源代码格式实现C函数接口。</li><li>资源，例如输入数据。</li><li>模型的图像和文档。</li></ul><p>遵循此标准导出的模型都可以与其他导出的模型进行协同仿真。在协同仿真的情况下，FMU包含使用XML标准格式表示的模型以及一些二进制文件，具体取决于与FMU兼容的平台。这些二进制文件是可由主算法（MA）加载的动态库。 ），并具有MA知道的标准接口。在这种情况下，FMU被视为MA命令的从属组件。MA是一种协调多个FMU（从站）执行的软件，这种协调主要涉及不同FMU模型之间的数据交换及其调度。</p><ol start="2"><li>FMI标准接口，需要包含以下文件：</li></ol><ul><li>模型描述文件 （XML）；</li><li>仿真程序代码（DLL）；</li><li>其他文件（图片、文档等）</li></ul><ol start="3"><li>FMI规范介绍-设计思想</li></ol><ul><li>Model Exchange（模型交换）</li><li>Co-Simulation（联合仿真）</li></ul><ol start="4"><li>FMI导出文件（FMU）</li></ol><ul><li>不包含求解器，只包括输入/输出接口以及与模型相关的信息；</li><li>FMU可以包含大量的变量；</li><li>FMU可用于嵌入式系统（只需很小的开销）；</li><li>多个FMU可以便捷高效的连在一起求解（各组件可以相互依赖，互相“协作”）</li></ul><p>通过遵循统一的FMI规范，输出统一的FMU文件格式，不同的仿真软件可以联合仿真</p><ul><li><a href="https://www.mathworks.com/help/hdlverifier/simulink-cosimulation.html" target="_blank" rel="noopener">Simulink协同仿真</a></li><li><a href="https://bitbucket.org/simulage/daccosim/src/master/" target="_blank" rel="noopener">daccosim源码</a></li></ul><h1 id="二、daccosim"><a href="#二、daccosim" class="headerlink" title="二、daccosim"></a>二、daccosim</h1><p>DACCOSIM NG是一个用于开发和运行由JavaFMI（fmu-wrapper和fmu-builder）支持的协同仿真用例的环境，JavaFMI是使用FMI标准的“协同仿真”部分实现互操作性的工具套件。DACCOSIM NG允许设计和执行协同仿真，从而提供了开发协同仿真图的机制。</p><h3 id="协同仿真图（co-simulation-graphs）"><a href="#协同仿真图（co-simulation-graphs）" class="headerlink" title="协同仿真图（co-simulation graphs）"></a>协同仿真图（co-simulation graphs）</h3><p>协同仿真图由顶点和连接顶点的箭头组成。一旦定义了顶点，就可以建立箭头来定义如何在它们之间交换变量。在协同仿真图中，可以包含不同类型的顶点：</p><ol><li>FMU<br>这种顶点代表了FMU，它保存文件路径，用作输入和输出的变量以及变量和参数的初始值。</li></ol><ol start="2"><li>External inputs/outputs（外部输入/输出）</li></ol><p>这类顶点允许提供固定值作为其他顶点的输入（外部输入）或者存储由输出提供的值（外部输出）。这两种顶点都可以具有多个变量，如外部输入将拥有几个可用于其他顶点的输出。</p><p>一旦定义了协同仿真图，就可以执行以下步骤：</p><ul><li>加载：该过程首先打开定义了协同仿真的文件并将图形加载到内存中，打开该文件并对其进行处理后，还将加载所使用的每个FMU</li><li>协同初始化：在执行了协同初始化过程后，将用户选择用于导出的变量初始值写入输出文件中，以便随后进行分析</li><li>协同执行：在达到模拟停止时间之前，将根据需要多次调用doStep方法</li><li>导出结果：到达停止时间后，通过终止所有FMU并关闭导出文件来完成仿真</li></ul><p>协同仿真的困难之一是：为所有组件设置一致的系统范围内的初始值。Daccosim协同初始化算法由基于FMU连接变量构建的全局依赖有向图开始，它使用用户建立的连接来查找源FMU的输出和宿主FMU的输入之间的外部依存关系。</p><p>关键思想是有向无环图（DAG）的拓扑排序会给出必须初始化的变量顺序，这导致研究如何将通用有向图转换为DAG。 找到的解决方案是建立与循环依赖关系相对应的强连接组件（SCC）图，将每个SCC收缩到单个顶点中的结果图是DAG。我们使用Tarjan的SCC算法（Tarjan，1972） 在许多Modelica工具中）以标识依赖关系图中的每个SCC（以线性时间运行）。 </p><p>遵循在收缩的SCC图上按拓扑排序获得的顺序： </p><ul><li>对于未收缩的顶点，只需传播其值</li><li>对于收缩的顶点（它们对应于循环依赖关系），我们使用迭代算法（称为JNRA（基于雅各布的牛顿-拉夫森算法））解决了初始化问题，该算法受传统牛顿-拉夫森算法的启发，经常被用于电力潮流计算。</li></ul><ol start="3"><li>运算符（Operator）顶点</li></ol><p>共有四个运算符：加法器，乘法器，偏移量和增益。 这些运算符允许使用其他顶点的输出进行计算，从而在要使用的输出中提供结果。 </p><ul><li>加法器和乘法器有两个或多个输入和一个输出</li><li>偏移量只有一个固定值和一个输入之和</li><li>增益定义为一个固定值，该值将乘以给定的输入</li></ul><p>所有这些顶点都可以使用实数，整数和布尔值。</p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>Daccosim文件结构如下：</p><p><img src="/image/co-simulation/Daccosim-NG-Modelica-f4.jpg" alt="Daccosim文件结构"></p><ul><li>simx：这是一个存档文件（zip），其中包含名为fmu的文件夹，以及在协同仿真图中使用的fmu文件以及sim，dng和dsg文件（sim，dng和dsg文件包含不同格式的协同仿真图的表示）<ul><li>sim 文件中包含要在编辑器中显示的可视化图形信息</li><li>dng 中包含以声明性语言显示的图形</li><li>dsg 中包含以json格式定义的序列化图形（协同仿真图的一种表示）</li><li>fmu 文件夹：包含相关的多个FMU文件</li></ul></li><li>dngx：此存档与simx具有相同的结构和内容，但不存在sim和dsg文件，只有dng文件<ul><li>dngx允许创建一个可运行文件，使用声明性语言定义了图形。</li></ul></li></ul><ol><li>fmu 文件</li></ol><p>这是一种ZIP压缩包，包括了模型的资源和文档，通过XML描述了资源的结构和作用。当使用daccosim加载simx时，会解析包含的每个FMU，将它转换为FMU顶点。当软件加载fum文件时，会将之渲染为fmu顶点。</p><p><img src="/image/co-simulation/Daccosim-NG-Modelica-f4.jpg" alt="Daccosim文件结构"></p><p>每次在doStep方法中调用FMU顶点时，它们通常需要消耗大量的系统资源。 因此，执行引擎还准备在分布式环境中运行，从而可以执行大规模的协同仿真方案。<br>归功于抽象机制的使用，执行引擎无需知道每个FMU的实际执行位置。引擎每次与FMU交互时，都会使用抽象接口。如下图所示，一共有三种实现：</p><p>![Daccosim文件结构](/image/co-simulation/Daccosim-NG-Modelica-    1.jpg)</p><p>Daccosim-NG-Modelica-f5.jpg</p><ul><li>FMULocal：使用文件系统中的FMU文件</li><li>FMUStub：使用与Java消息服务（JMS）的连接来与正在远程执行的FMU进行交互，源码中实现了FMUJMS接口，用于实现服务</li><li>FMUSoul：FMU在远程计算机中的表示</li></ul><p>在上图中，示例展示了如何在运行分布式仿真的机器之间通信。在此示例中，有三台计算机。 在第一个实例中，Daccosim内核的一个实例负责协调分布式执行。 此实例的执行引擎使用FMU接口与要协调的三个FMU进行通信。 其中，两个正在远程执行，一个在本地执行。 但是，由于引擎仅取决于接口，因此类似于执行位置等详细信息对其执行过程来说并不重要。<br>每当引擎发出命令时，FMUStub都会与FMUSoul通信以执行命令，将答案提供给引擎。尽管未显示，但通信是通过JMS进行的。 JMS的使用为设计不同的分发体系结构提供了灵活性，以支持大规模的协同仿真。</p><ol start="2"><li>dng文件（声明式语言）</li></ol><p>Daccosim NG中实现的声明性语言允许用户在文本编辑器上定义一个协同仿真图或通过程序自动生成它。为此，已经设计了一种领域特定的语言来简单地定义一个协同仿真图。该语言非常简单并且易于理解。其目的是创建无法在GUI中建模的非常宽的图，其中有数百个相互连接的顶点交换成千上万的变量。此功能允许预处理工具开发兼容的模型，以便在DaccosimNG中执行。</p><p>声明式语言实例如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 2021-05-08T03:33:24.918Z</span><br><span class="line">// Generated with Daccosim NG %%VERSION%%</span><br><span class="line"></span><br><span class="line">// 格式：FMU ID 文件相对路径 staitc？</span><br><span class="line">FMU equation1 &quot;fmu/equation1win3264.fmu&quot;</span><br><span class="line">// 格式：Output/Input FMU-ID 变量ID 变量类型 变量可变性</span><br><span class="line">Output equation1 x2 Real continuous</span><br><span class="line">Input equation1 x1 Real continuous</span><br><span class="line"></span><br><span class="line">FMU equation2 &quot;fmu/equation2win3264.fmu&quot;</span><br><span class="line">Output equation2 x1 Real continuous</span><br><span class="line">Input equation2 x2 Real continuous</span><br><span class="line"></span><br><span class="line">// 描述要连接的输入、输出</span><br><span class="line">Connection equation1.x2 equation2.x2</span><br><span class="line">Connection equation2.x1 equation1.x1</span><br><span class="line"></span><br><span class="line">Export ; . 2.0E-4</span><br><span class="line">Log equation1.x1 equation1.x2 equation2.x1 equation2.x2</span><br><span class="line">NewtonRaphsonInitializer 20 1.0E-5</span><br><span class="line">// 步长方法</span><br><span class="line">ConstantStepper 1.0</span><br><span class="line">// 仿真起始和结束时间</span><br><span class="line">Simulation 0.0 0.0</span><br><span class="line"></span><br><span class="line">// pipeline 管道配置：管道配置可以合并到dng文件中。在这种情况下，语法由＆和@之类的链接器组成。 ＆链接器表示＆两侧的FMU在同一阶段并行执行。 @链接器指示两侧的FMU在不同阶段执行</span><br><span class="line">Pipeline equation1&amp;equation2</span><br></pre></td></tr></table></figure><p>这个例子来自于<code>equationsPair.simx</code>，该文件实际是压缩文件，解压后就可打开后缀为”.dng”的文件。</p><ol start="3"><li>dsg 文件（DaccosimGraph）</li></ol><p>dsg 中包含以json格式定义的序列化图形（协同仿真图的一种表示）</p><p>相关示例如下，来自于<code>equationsPair.simx</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;settings&quot;: &#123;</span><br><span class="line">&quot;coInitialization&quot;: &#123;</span><br><span class="line">&quot;method&quot;: &quot;NewtonRaphson&quot;,</span><br><span class="line">&quot;residualsTolerance&quot;: 1.0E-5,</span><br><span class="line">&quot;maxIterations&quot;: 20</span><br><span class="line">&#125;,</span><br><span class="line">&quot;startTime&quot;: 0.0,</span><br><span class="line">&quot;stopTime&quot;: 0.0,</span><br><span class="line">&quot;pipeline&quot;: &quot;equation1\u0026equation2&quot;,</span><br><span class="line">&quot;stepper&quot;: &#123;</span><br><span class="line">&quot;method&quot;: &quot;ConstantStep&quot;,</span><br><span class="line">&quot;order&quot;: 3,</span><br><span class="line">&quot;stepSize&quot;: 1.0,</span><br><span class="line">&quot;safetyFactor&quot;: 0.9,</span><br><span class="line">&quot;stepperVariables&quot;: &#123;&#125;,</span><br><span class="line">&quot;transmitDerivatives&quot;: false</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;nodes&quot;: [&#123;</span><br><span class="line">&quot;CLASSNAME&quot;: &quot;eu.simulage.daccosim.view.FMU&quot;,</span><br><span class="line">&quot;INSTANCE&quot;: &#123;</span><br><span class="line">&quot;path&quot;: &quot;fmu/equation1win3264.fmu&quot;,</span><br><span class="line">&quot;beforeInitValues&quot;: [],</span><br><span class="line">&quot;inInitValues&quot;: [],</span><br><span class="line">&quot;flowVariables&quot;: [],</span><br><span class="line">&quot;static_&quot;: false,</span><br><span class="line">&quot;id&quot;: &quot;equation1&quot;,</span><br><span class="line">&quot;inputs&quot;: [&#123;</span><br><span class="line">&quot;id&quot;: &quot;x1&quot;,</span><br><span class="line">&quot;type&quot;: &quot;Real&quot;,</span><br><span class="line">&quot;value&quot;: 0.0,</span><br><span class="line">&quot;variability&quot;: &quot;continuous&quot;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;outputs&quot;: [&#123;</span><br><span class="line">&quot;id&quot;: &quot;x2&quot;,</span><br><span class="line">&quot;type&quot;: &quot;Real&quot;,</span><br><span class="line">&quot;value&quot;: 0.0,</span><br><span class="line">&quot;variability&quot;: &quot;continuous&quot;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;variables&quot;: []</span><br><span class="line">&#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;CLASSNAME&quot;: &quot;eu.simulage.daccosim.view.FMU&quot;,</span><br><span class="line">&quot;INSTANCE&quot;: &#123;</span><br><span class="line">&quot;path&quot;: &quot;fmu/equation2win3264.fmu&quot;,</span><br><span class="line">&quot;beforeInitValues&quot;: [],</span><br><span class="line">&quot;inInitValues&quot;: [],</span><br><span class="line">&quot;flowVariables&quot;: [],</span><br><span class="line">&quot;static_&quot;: false,</span><br><span class="line">&quot;id&quot;: &quot;equation2&quot;,</span><br><span class="line">&quot;inputs&quot;: [&#123;</span><br><span class="line">&quot;id&quot;: &quot;x2&quot;,</span><br><span class="line">&quot;type&quot;: &quot;Real&quot;,</span><br><span class="line">&quot;value&quot;: 0.0,</span><br><span class="line">&quot;variability&quot;: &quot;continuous&quot;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;outputs&quot;: [&#123;</span><br><span class="line">&quot;id&quot;: &quot;x1&quot;,</span><br><span class="line">&quot;type&quot;: &quot;Real&quot;,</span><br><span class="line">&quot;value&quot;: 0.0,</span><br><span class="line">&quot;variability&quot;: &quot;continuous&quot;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;variables&quot;: []</span><br><span class="line">&#125;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;arrows&quot;: [&#123;</span><br><span class="line">&quot;from&quot;: &quot;equation1.x2&quot;,</span><br><span class="line">&quot;to&quot;: &quot;equation2.x2&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;from&quot;: &quot;equation2.x1&quot;,</span><br><span class="line">&quot;to&quot;: &quot;equation1.x1&quot;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;export&quot;: &#123;</span><br><span class="line">&quot;cellSeparator&quot;: &quot;;&quot;,</span><br><span class="line">&quot;decimalSeparator&quot;: &quot;.&quot;,</span><br><span class="line">&quot;prefix&quot;: &quot;equationsPair&quot;,</span><br><span class="line">&quot;variables&quot;: [&quot;equation1.x1&quot;, &quot;equation1.x2&quot;, &quot;equation2.x1&quot;, &quot;equation2.x2&quot;],</span><br><span class="line">&quot;folder&quot;: &quot;.&quot;,</span><br><span class="line">&quot;interpolationInterval&quot;: 2.0E-4</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="daccosim-实例"><a href="#daccosim-实例" class="headerlink" title="daccosim 实例"></a>daccosim 实例</h3><p><a href="https://bitbucket.org/simulage/daccosim/downloads/" target="_blank" rel="noopener">下载daccosim 实例</a> ： daccosim-use-cases-windows-20201212.zip。其中，例子“1-coinit-only/1-equationsPair”就是以下两条算式：</p><ul><li>2<em>X1^X1+5</em>X2=42</li><li>X1-6*X2=4</li></ul><p>每条算式是一个顶点，通过协同合作，两个未知数由零开始递增，最终获得一个近似值。</p><p>Equation1.x2取决于Equation2.x1，而Equation2.x2取决于Equation1。 二者形成一个代数环路，其中对 Equation1.x1的修改会影响Equation1.x2，而对Equation2.x2的修改会影响Equation2.x1。 协同仿真程序将计算该图（为所有变量提供一致的初始值），程序将检测到一个SCC，并且在多次迭代后，x1和x2将达到以下值（x1 = 4.56，x2 = 0.09）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、FMI&quot;&gt;&lt;a href=&quot;#一、FMI&quot; class=&quot;headerlink&quot; title=&quot;一、FMI&quot;&gt;&lt;/a&gt;一、FMI&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;什么是FMI&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;FMI代表“ Functional Mock-up Inter</summary>
      
    
    
    
    
    <category term="fmi" scheme="http://zws6672.top/tags/fmi/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://zws6672.top/2021/05/15/vue_add_method/"/>
    <id>http://zws6672.top/2021/05/15/vue_add_method/</id>
    <published>2021-05-15T14:07:01.518Z</published>
    <updated>2021-01-23T07:55:02.197Z</updated>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0">  <title>My first Vue app</title>  <!-- 1. 引入vue.js -->  <!-- 开发环境版本，包含了有帮助的命令行警告 -->    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script><link rel="alternate" href="/atom.xml" title="微言术语" type="application/atom+xml"></head><body>  <div id="app"><p>计数：</p><button @click="add(10)">add</button><div><p>科目  分数</p><p v-for="item in results">  </p><p>总分：</p></div><div><p><input type="number" v-model="yc"> 英寸==> 厘米</p><p> 英寸 =  厘米 </p></div><my-component></my-component><child-component><child-component>  </child-component></child-component></div>  <script>Vue.component('my-component', {template: "<span style='color:red;'>通过component定义的全局组件</span>"})    //2. 创建Vue实例对象，设置el属性和data属性  var app = new Vue({el: '#app',data: {count:1,results: [{name: 'english', score: 70},{name: 'math', score: 80},{name: 'chinese', score: 90}],yc: 0},methods: {add: function(num) {if(num!='') {this.count+=num} else {this.count++}}},computed: {computedAvg: function() {let sum=0let rst = this.results;for (let i=0; i < rst.length; i++) {sum+=rst[i].score}return sum/rst.length},exchangeYC: function() {return this.yc * 2.54}},watch: {yc: {// yc值修改后触发handler(nv, ov) {// 后台输出值console.log(ov + "==>" + nv);},immediate: false, //网页加载完后不会立即调用一次deep: true //会进行深度监听，如果绑定的是变量，内部属性的变动也会触发}},components: {"child-component":{template:"<p>根实例中components属性定义的局部组件</p>"}}})  </script></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;meta name=&quot;generator&quot; content=&quot;Hexo 3.9.0&quot;&gt;
  &lt;title&gt;My first Vue app&lt;/title&gt;
  &lt;!-- 1. 引入vue.js --&gt;
  &lt;!-- 开发</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://zws6672.top/2021/05/15/test/"/>
    <id>http://zws6672.top/2021/05/15/test/</id>
    <published>2021-05-15T14:07:01.502Z</published>
    <updated>2021-01-20T09:20:07.323Z</updated>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0">  <title>My first Vue app</title>  <!-- 1. 引入vue.js -->  <!-- 开发环境版本，包含了有帮助的命令行警告 -->    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script><!-- 生产环境版本，优化了尺寸和速度 --><!-- <script src="https://cdn.jsdelivr.net/npm/vue"></script> --><link rel="alternate" href="/atom.xml" title="微言术语" type="application/atom+xml"></head><body>  <div id="app">    <!-- 3. 模板语法渲染数据 -->    <p>    </p><p>  </p></div>  <script>    //2. 创建Vue实例对象，设置el属性和data属性      var app = new Vue({      el: '#app',      data: {        message: 'Hello Vue!',list: [{name: 'jk',phone: 110}]      }    })  </script></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;meta name=&quot;generator&quot; content=&quot;Hexo 3.9.0&quot;&gt;
  &lt;title&gt;My first Vue app&lt;/title&gt;
  &lt;!-- 1. 引入vue.js --&gt;
  &lt;!-- 开发</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>springboot（一）入门</title>
    <link href="http://zws6672.top/2021/05/15/springboot-1/"/>
    <id>http://zws6672.top/2021/05/15/springboot-1/</id>
    <published>2021-05-15T14:07:01.486Z</published>
    <updated>2020-10-12T13:40:29.127Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-SpringBoot-快速入门"><a href="#1-SpringBoot-快速入门" class="headerlink" title="1. SpringBoot 快速入门"></a>1. SpringBoot 快速入门</h3><h5 id="1-1-什么是-SpringBoot"><a href="#1-1-什么是-SpringBoot" class="headerlink" title="1.1 什么是 SpringBoot"></a>1.1 什么是 SpringBoot</h5><p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。</p><blockquote><p>Spring 诞生时是 Java 企业版（Java Enterprise Edition，JEE，也称 J2EE）的<br>轻量级代替品。无需开发重量级的 Enterprise JavaBean（EJB），Spring 为企业级<br>Java 开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java 对象（Plain Old Java Object，POJO）实现了 EJB 的功能。<br>虽然 Spring 的组件代码是轻量级的，但它的配置却是重量级的。</p></blockquote><p><strong><em>Spring配置 发展三阶段</em></strong></p><p>第一阶段：xml配置<br>在Spring 1.x时代，使用Spring开发满眼都是xml配置的Bean，随着项目的扩大，我们需要把xml配置文件放到不同的配置文件里，那时需要频繁的在开发的类和配置文件之间进行切换</p><p>第二阶段：注解配置<br>在Spring 2.x 时代，随着JDK1.5带来的注解支持，Spring提供了声明Bean的注解（例如@Component、@Service），大大减少了配置量。主要使用的方式是应用的基本配置（如数据库配置）用xml，业务配置用注解</p><p>第三阶段：java配置<br>Spring 3.0 引入了基于 Java 的配置能力，这是一种类型安全的可重构配置方式，可以代替 XML。我们目前刚好处于这个时代，Spring4.x和Spring Boot都推荐使用Java配置。</p><p><code>Spring Boot</code> 四个核心</p><ul><li>自动配置：针对很多Spring应用程序常见的应用功能，Spring Boot能自动提供相关配置</li><li>起步依赖：告诉Spring Boot需要什么功能，它就能引入需要的库。</li><li>命令行界面：这是Spring Boot的可选特性，借此你只需写代码就能完成完整的应用程序，无需传统项目构建。</li><li>执行器：让你能够深入运行中的Spring Boot应用程序，一套究竟。</li></ul><p><code>Spring Boot</code>比起<code>Spring</code>，最大的好处是易于使用，是开发微服务、小项目的利器。</p><h5 id="1-2-使用IDEA构建项目"><a href="#1-2-使用IDEA构建项目" class="headerlink" title="1.2 使用IDEA构建项目"></a>1.2 使用IDEA构建项目</h5><p>使用IDEA的好处是可以通过勾选配置组件，不用担心相关包以及版本冲突，</p><p><strong><em>环境</em></strong></p><ul><li>JDK8</li><li>IDEA 20019</li><li>SpringBoot 2.2.3</li></ul><p><strong><em>使用IDEA配置</em></strong></p><p><img src="/iamge/springboot/init.png" alt="springboot项目建立"><br><img src="/iamge/springboot/text1.png" alt="springboot 文件"></p><p><strong><em>项目结构</em></strong></p><p>项目里面基本没有代码，除了几个空目录外，还包含如下几样东西。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line">  +- springboot</span><br><span class="line">    +- src</span><br><span class="line">+- main</span><br><span class="line">|  +- java（存放代码）</span><br><span class="line">|  |</span><br><span class="line">|  |</span><br><span class="line">|  +- resources</span><br><span class="line">|  |  +- static（静态文件 图标/图片）</span><br><span class="line">|  |  +- templates（模板 HTML文件）</span><br><span class="line">|  |  +- application.yml  配置属性</span><br><span class="line">|  |  +- application.profiles  配置属性</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">+- test（测试代码）</span><br><span class="line">+- pom.xml Maven的构建说明文件</span><br></pre></td></tr></table></figure><p><strong><em>pom 配置</em></strong></p><ul><li>spring-boot-starter-parent（父级依赖）：是一个特殊的首发，它用来提供相关的Maven默认依赖，使用它之后，常用的包依赖可以省去版本标签。</li><li>spring-boot-starter-xx（起步依赖）：Spring Boot提供了很多“开箱即用”的依赖模块，都是以spring-boot-starter-xx作为命名的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">// 1. 配置父级依赖</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.3.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.springboot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;example&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">    &lt;name&gt;example&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot（20200816）&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">// 2. 配置启动依赖</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">// 3. 配置其它依赖</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;reactor-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p><strong><em>Application.yml 配置</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8888</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/toolweb?serverTimezone=UTC&amp;useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br></pre></td></tr></table></figure><p><strong><em>启动器</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.springboot.demo;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">// 该注解表示这是一个 SpringBoot启动类</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ExampleApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ExampleApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>控制器</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String index() &#123;</span><br><span class="line">        return &quot;Hello World&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>测试</em></strong></p><p>启动主程序，打开浏览器访问<code>http://localhost:8888/hello</code>，可以看到页面输出Hello World</p><h5 id="YML"><a href="#YML" class="headerlink" title="YML"></a>YML</h5><p>YAML (YAML Ain’t a Markup Language)YAML不是一种标记语言，通常以.yml为后缀的文件，是一种直观的能够被电脑识别的数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，一种专门用来写配置文件的语言。可用于如： Java，C/C++, Ruby, Python, Perl, C#, PHP等。</p><p><strong><em>语法</em></strong></p><ol><li>约定格式</li></ol><ul><li>k: v 表示键值对关系，冒号后面必须有一个空格</li><li>使用空格的缩进表示层级关系，空格数目不重要，只要是左对齐的一列数据，都是同一个层级的</li><li>大小写敏感</li><li>缩进时不允许使用Tab键，只允许使用空格。</li><li>松散表示，java中对于驼峰命名法，可用原名或使用-代替驼峰，如java中的lastName属性,在yml中使用lastName或 last-name都可正确映射。</li></ul><ol start="2"><li>键值对的书写</li></ol><ul><li><p>字面值</p><ul><li>字符串默认不用加上单引号或者双绰号；</li><li>“”: 双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思<ul><li>“a\nb”===&gt; a换行b</li></ul></li><li>‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</li></ul></li><li><p>日期</p><ul><li>date: 2020/08/15</li></ul></li><li><p>对象(属性和值)、Map(键值对)</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">people:</span><br><span class="line">name: ws</span><br><span class="line">age: 1000</span><br><span class="line">people: &#123;name:ws,age: 1000&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数组、list、set</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pets:</span><br><span class="line">- dog</span><br><span class="line">- pig</span><br><span class="line">- cat</span><br><span class="line">pets: [dog,pig,cat]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数组对象、list对象、set对象</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">peoples:</span><br><span class="line">   - name: ws</span><br><span class="line">     age: 22</span><br><span class="line">   - name: lisi</span><br><span class="line">     age: 1000</span><br><span class="line">   - &#123;name: wangwu,age: 18&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="3"><li>文档块</li></ol><ul><li>对于生产、测试环境等可以使用不同的配置，可以写在一个文件中，使用<code>---</code>隔开<ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">active: test #激活</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  profiles: dev #生产环境</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8084</span><br><span class="line">spring:</span><br><span class="line">  profiles: test  #测试环境</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-SpringBoot-WEB"><a href="#2-SpringBoot-WEB" class="headerlink" title="2. SpringBoot WEB"></a>2. SpringBoot WEB</h3><p>前面，我们是使用IDEA快速搭建了一个 RESTful Service 的微服务项目，现在要快速配置一个WEB界面</p><h5 id="2-1-基础"><a href="#2-1-基础" class="headerlink" title="2.1 基础"></a>2.1 基础</h5><p><strong><em>约定配置</em></strong></p><p>Spring Boot默认提供静态资源目录位置需置于classpath下，目录名需符合如下规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/static</span><br><span class="line">/public</span><br><span class="line">/resources</span><br><span class="line">/META-INF/resources</span><br></pre></td></tr></table></figure><p><strong><em>模板引擎</em></strong></p><p><code>@RestController</code>返回的是JSON格式的数据，如果需要渲染页面，可以通过模板引擎实现。</p><p>Spring Boot提供了默认配置的模板引擎主要有以下几种：</p><ul><li><code>Thymeleaf</code></li><li>FreeMarker</li><li>Velocity</li><li>Groovy</li><li>Mustache</li></ul><blockquote><p>Spring Boot建议使用这些模板引擎，避免使用JSP，若一定要使用JSP将无法实现Spring Boot的多种特性</p></blockquote><h5 id="2-2-Thymeleaf"><a href="#2-2-Thymeleaf" class="headerlink" title="2.2 Thymeleaf"></a>2.2 Thymeleaf</h5><p>Thymeleaf是面向Web和独立环境的现代服务器端Java模板引擎，能够处理HTML，XML，JavaScript，CSS甚至纯文本。<br>Thymeleaf的主要目标是提供一个优雅和高度可维护的创建模板的方式。为了实现这一点，它建立在自然模板的概念上，将其逻辑注入到模板文件中，不会影响模板被用作设计原型。这改善了设计的沟通，弥合了设计和开发团队之间的差距。<br>Thymeleaf也从一开始就设计了Web标准 (特别是HTML5)允许您创建完全验证的模板，</p><p><strong><em>引用</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong><em>application.yml 配置</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring: </span><br><span class="line">  thymeleaf:</span><br><span class="line">    prefix: classpath:/templates/ # 前缀</span><br><span class="line">    suffix: .html #后缀</span><br><span class="line">    encoding: UTF-8 # 编码</span><br><span class="line">    mode: HTML5 # 模板模式</span><br><span class="line">    cache: false # 关闭模板缓存，实时更新</span><br><span class="line">    content-type: text/html</span><br></pre></td></tr></table></figure><p><strong><em>示例</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 控制器</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class IndexController &#123;</span><br><span class="line">    @RequestMapping(&quot;/&quot;)</span><br><span class="line">    public String index(ModelMap map) &#123;</span><br><span class="line">        // 加入一个属性，用来在模板中读取</span><br><span class="line">        map.addAttribute(&quot;host&quot;, &quot;https://www.cnblogs.com&quot;);</span><br><span class="line">        // 对应src/main/resources/templates/index.html</span><br><span class="line">        return &quot;index&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">// index.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head lang=&quot;en&quot;&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1 th:text=&quot;$&#123;host&#125;&quot;&gt;Hello World&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong><em>Thymeleaf IDEA 中语法无法识别</em></strong></p><p>在<code>&lt;html&gt;</code> 中添加 <code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code></p><blockquote><p>Thymeleaf主要以属性的方式加入到html标签中，浏览器在解析html时，当检查到没有的属性时候会忽略，所以Thymeleaf的模板可以通过浏览器直接打开展现，这样非常有利于前后端的分离。</p></blockquote><p><strong>* Error resolving template [index], template might not exist or might not be accessible by any of the configured Template Resolvers*</strong></p><p>可能的原因如下：</p><ul><li>路径配置错误，正确的配置 <code>prefix: classpath:/templates/ # 前缀</code></li><li>注解不是<code>@RestController</code>, 而是<code>@Controller</code></li><li>返回值是<code>&quot;/index&quot;</code>,去掉斜杆</li></ul><h3 id="3-RESTful-API与单元测试"><a href="#3-RESTful-API与单元测试" class="headerlink" title="3. RESTful API与单元测试"></a>3. RESTful API与单元测试</h3><p><strong><em>RESTful</em></strong></p><p>基于 RESTful 原则设计的 API 就是RESTful API。该原则如下：</p><ul><li>一个URI代表一种资源</li><li>客户端和服务器之间，传递这种资源的某种表现层</li><li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</li></ul><h5 id="3-1-RESTful-API-实例"><a href="#3-1-RESTful-API-实例" class="headerlink" title="3.1 RESTful API 实例"></a>3.1 RESTful API 实例</h5><p>RESTful API具体设计如下：<br><img src="/image/springboot/restful.png" alt="RESTful API"></p><p><strong><em>实体</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123; </span><br><span class="line"> </span><br><span class="line">    private Long id; </span><br><span class="line">    private String name; </span><br><span class="line">    private Integer age;  </span><br><span class="line">    // 省略setter和getter </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>操作接口</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@RestController </span><br><span class="line">@RequestMapping(value=&quot;/users&quot;)     // 通过这里配置使下面的映射都在/users下 </span><br><span class="line">public class UserController &#123; </span><br><span class="line"> </span><br><span class="line">    // 创建线程安全的Map </span><br><span class="line">    static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;()); </span><br><span class="line"> </span><br><span class="line">    @RequestMapping(value=&quot;/&quot;, method=RequestMethod.GET) </span><br><span class="line">    public List&lt;User&gt; getUserList() &#123; </span><br><span class="line">        // 处理&quot;/users/&quot;的GET请求，用来获取用户列表 </span><br><span class="line">        // 还可以通过@RequestParam从页面中传递参数来进行查询条件或者翻页信息的传递 </span><br><span class="line">        List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values()); </span><br><span class="line">        return r; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    @RequestMapping(value=&quot;/&quot;, method=RequestMethod.POST) </span><br><span class="line">    public String postUser(@ModelAttribute User user) &#123; </span><br><span class="line">        // 处理&quot;/users/&quot;的POST请求，用来创建User </span><br><span class="line">        // 除了@ModelAttribute绑定参数之外，还可以通过@RequestParam从页面中传递参数 </span><br><span class="line">        users.put(user.getId(), user); </span><br><span class="line">        return &quot;success&quot;; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    @RequestMapping(value=&quot;/&#123;id&#125;&quot;, method=RequestMethod.GET) </span><br><span class="line">    public User getUser(@PathVariable Long id) &#123; </span><br><span class="line">        // 处理&quot;/users/&#123;id&#125;&quot;的GET请求，用来获取url中id值的User信息 </span><br><span class="line">        // url中的id可通过@PathVariable绑定到函数的参数中 </span><br><span class="line">        return users.get(id); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    @RequestMapping(value=&quot;/&#123;id&#125;&quot;, method=RequestMethod.PUT) </span><br><span class="line">    public String putUser(@PathVariable Long id, @ModelAttribute User user) &#123; </span><br><span class="line">        // 处理&quot;/users/&#123;id&#125;&quot;的PUT请求，用来更新User信息 </span><br><span class="line">        User u = users.get(id); </span><br><span class="line">        u.setName(user.getName()); </span><br><span class="line">        u.setAge(user.getAge()); </span><br><span class="line">        users.put(id, u); </span><br><span class="line">        return &quot;success&quot;; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    @RequestMapping(value=&quot;/&#123;id&#125;&quot;, method=RequestMethod.DELETE) </span><br><span class="line">    public String deleteUser(@PathVariable Long id) &#123; </span><br><span class="line">        // 处理&quot;/users/&#123;id&#125;&quot;的DELETE请求，用来删除User </span><br><span class="line">        users.remove(id); </span><br><span class="line">        return &quot;success&quot;; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Representational State Transfer: REST</p></blockquote><p><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-SpringBoot-快速入门&quot;&gt;&lt;a href=&quot;#1-SpringBoot-快速入门&quot; class=&quot;headerlink&quot; title=&quot;1. SpringBoot 快速入门&quot;&gt;&lt;/a&gt;1. SpringBoot 快速入门&lt;/h3&gt;&lt;h5 id=&quot;1-1</summary>
      
    
    
    
    
    <category term="javaweb" scheme="http://zws6672.top/tags/javaweb/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机字节码执行引擎</title>
    <link href="http://zws6672.top/2021/04/26/jdk-bytecodeEngine/"/>
    <id>http://zws6672.top/2021/04/26/jdk-bytecodeEngine/</id>
    <published>2021-04-26T03:17:18.000Z</published>
    <updated>2021-04-26T03:18:17.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、运行时栈帧结构"><a href="#一、运行时栈帧结构" class="headerlink" title="一、运行时栈帧结构"></a>一、运行时栈帧结构</h1><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一<br>大步。</p><p>执行引擎在执行字节码的时候，通常会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备。</p><blockquote><p>有一些虚拟机（如Sun Classic VM）的内部只存在解释器，只能解释执行，另外一些虚拟机（如BEA JRockit）的内部只存在即时编译器，只能编译执行。</p></blockquote><p>Java虚拟机以方法作为最基本的执行单元，“栈帧”（Stack Frame）则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。每一个栈帧都包括了 局部变量表、操作数栈、动态连接、方法返回地址 和一些额外的 附加信息。</p><p>而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”（Current Stack Frame），与这个栈帧所关联的方法被称为“当前方法”（Current Method）</p><ol><li>局部变量表</li></ol><p>局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。局部变量表的容量以变量槽（Variable Slot）为最小单位，每个变量槽都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存储。</p><ol start="2"><li>操作数栈</li></ol><p>操作数栈（Operand Stack）也常被称为操作栈，它是一个后入先出（Last In First Out，LIFO）栈。操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项，操作数栈中元素的数据类型必须与字节码指令的序列严格匹配。Java虚拟机的解释执行引擎被称为“基于栈的执行引擎”，里面的“栈”就是操作数栈。</p><ol start="3"><li>动态连接</li></ol><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。</p><ol start="4"><li>方法返回地址</li></ol><p>当一个方法开始执行后，只有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者或者主调方法），方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为“正常调用完成”（Normal Method Invocation Completion）。</p><p>退出方法：</p><ul><li>Java虚拟机内部产生的异常</li><li>代码中使用athrow字节码指令产生的异常（throw、throws）</li></ul><p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：</p><ul><li>恢复上层方法的局部变量表和操作数栈</li><li>把返回值（如果有的话）压入调用者栈帧的操作数栈中</li><li>调整PC计数器的值以指向方法调用指令后面的一条指令等。=</li></ul><ol start="5"><li>附加信息</li></ol><p>Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现</p><h1 id="二、方法调用"><a href="#二、方法调用" class="headerlink" title="二、方法调用"></a>二、方法调用</h1><p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还未涉及方法内部的具体运行过程。</p><p>Class文件的编译过程中不包含传统程序语言编译的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（也就是之前说的直接引用）。</p><ul><li>解析：调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析（Resolution）。<ul><li>在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问。</li></ul></li><li>分派：分派（Dispatch）调用则要复杂许多，它可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派[1]。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况。<ul><li>静态分派：所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。静态分派的最典型应用表现就是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行</li><li>动态分派：在运行期根据实际类型确定方法执行版本的分派过程称为动态分派，动态分派 的最典型应用表现就是方法重写。</li><li>单分派与多分派：方法的接收者与方法的参数统称为方法的宗量，这个定义最早应该来源于著名的《Java与模式》一书。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。</li></ul></li><li>方法调用字节码指令<ul><li>invokestatic：用于调用静态方法。</li><li>invokespecial：用于调用实例构造器<init>()方法、私有方法和父类中的方法。</init></li><li>invokevirtual：用于调用所有的虚方法。</li><li>invokeinterface：用于调用接口方法，会在运行时再确定一个实现该接口的对象。</li><li>invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</li></ul></li><li>虚拟机动态分派的实现：Java虚拟机实现基于执行性能的考虑，真正运行时一般不会如此频繁地去反复搜索类型元数据。面对这种情况，一种基础而且常见的优化手段是为类型在方法区中建立一个虚方法表（Virtual Method Table，也称为vtable，与此对应的，在invokeinterface执行时也会用到接口方法表——Interface Method Table，简称itable），使用虚方法表索引来代替元数据查找以提高性能。<ul><li>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</li></ul></li></ul><blockquote></blockquote><p>Java语言是一门静态多分派、动态单分派的语言。 字段永远不参与多态，哪个类的方法访问某个名字的字段时，该名字指的就是这个类能看到的那个字段。当子类声明了与父类同名的字段时，虽然在子类的内存中两个字段都会存在，但是子类的字段会遮蔽父类的同名字段。</p><h1 id="三、动态类型语言"><a href="#三、动态类型语言" class="headerlink" title="三、动态类型语言"></a>三、动态类型语言</h1><p>JDK7 发布了字节码首位新成员——invokedynamic指令，用于实现动态类型语言（Dynamically Typed Language）支持，为JDK 8里可以顺利实现Lambda表达式而做的技术储备。</p><p>动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的，满足这个特征的语言有很多，常用的包括：APL、Clojure、Erlang、Groovy、JavaScript、Lisp、Lua、PHP、Prolog、Python、Ruby、Smalltalk、Tcl，等等。那相对地，在编译期就进行类型检查过程的语言，譬如C++和Java等就是最常用的静态类型语言。。“变量无类型而变量值才有类型”这个特点也是动态类型语言的一个核心特征。</p><p>动态类型方法调用的底层问题终归是应当在Java虚拟机层次上去解决才最合适。因此，在Java虚拟机层面上提供动态类型的直接支持就成为Java平台发展必须解决的问题，这便是JDK 7时JSR-292提案中invokedynamic指令以及java.lang.invoke包出现的技术背景。</p><ol><li>MethodHand（方法句柄）</li></ol><p>JDK 7时新加入的java.lang.invoke包是JSR 292的一个重要组成部分，这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这条路之外，提供一种新的动态确定目标方法的机制，称为“方法句柄”（Method Handle）。java7新增了一个字节码invokedynamic,可以在运行期动态决定调用的方法，区别于之前的 invokestatic(静态方法调用),invokespecial（构造方法，私有方法，父类方法），invokevirtual（实例方法），invokeinterface(接口方法)，不过在java7下javac不支持生成invokedynamic,java8中可以通过lambda来生成。</p><ol start="2"><li>Reflection 与 MethodHandle</li></ol><ul><li><p>Reflection 和MethodHandle机制本质上都是在模拟方法调用，但是Reflection是在模拟Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用。</p></li><li><p>在MethodHandles.Lookup上的3个方法findStatic()、findVirtual()、findSpecial()正是为了对应于 invokestatic、invokevirtual（以及invokeinterface）和invokespecial这几条字节码指令的执行权限校验行为，而这些底层细节在使用Reflection API时是不需要关心的。</p></li><li><p>Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的java.lang.invoke.MethodHandle对象所包含的信息来得多。前者是方法在Java端的全面映像，包含了方法的签名、描述符以及方法属性表中各种属性的Java端表示方式，还包含执行权限等的运行期信息。而后者仅包含执行该方法的相关信息。用开发人员通俗的话来讲，Reflection是重量级，而MethodHandle是轻量级。</p></li><li><p>由于MethodHandle是对字节码的方法指令调用的模拟，那理论上虚拟机在这方面做的各种优化（如方法内联），在MethodHandle上也应当可以采用类似思路去支持。</p></li><li><p>Reflection API的设计目标是只为Java语言服务的，而MethodHandle则设计为可服务于所有Java虚拟机之上的语言，其中也包括了Java语言而已，而且Java在这里并不是主角。</p></li></ul><ol start="3"><li>invokedynamic指令</li></ol><p>某种意义上可以说invokedynamic指令与MethodHandle机制的作用是一样的，都是为了解决原有4条“invoke*”指令方法分派规则完全固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中，让用户（广义的用户，包含其他程序语言的设计者）有更高的自由度。</p><p>每一处含有invokedynamic指令的位置都被称作“动态调用点（Dynamically-Computed Call Site）”，这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是变为 JDK7 时新加入的CONSTANT_InvokeDynamic_info常量，从这个新常量中可以得到3项信息：</p><ul><li>引导方法（Bootstrap Method，该方法存放在新增的BootstrapMethods属性中）</li><li>方法类型（MethodType）</li><li>名称</li></ul><p>invokedynamic指令与此前4条传统的“invoke*”指令的最大区别就是它的分派逻辑不是由虚拟机决定的，而是由程序员决定。但是，这个指令Java其实不太好用。准确的来说，它的设计是为了在Java虚拟机层面上提供动态类型的直接支持，而Java这种静态语言就很难用到这个指令。而在JDK8中，lamda表达式和默认方法就是围绕这个指令而设计的。</p><h1 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h1><p>许多Java虚拟机的执行引擎在执行Java代码的时候都有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择。只有确定了谈论对象是某种具体的Java实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较合理确切。</p><p><img src="/image/jdk/engine-jslc.png" alt="字节码解释执行引擎"></p><p>如今，基于物理机、Java虚拟机，或者是非Java的其他高级语言虚拟机（HLLVM）的代码执行过程，大体上都会遵循这种符合现代经典编译原理的思路，在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树（Abstract Syntax Tree，AST）。对于一门具体语言的实现来说，</p><ul><li>词法、语法分析以至后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是C/C++语言</li><li>也可以选择把其中一部分步骤（如生成抽象语法树之前的步骤）实现为一个半独立的编译器，这类代表是Java语言</li><li>又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子之中，如大多数的JavaScript执行引擎。</li></ul><p>在Java语言中，Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。</p><ol><li>基于栈的指令集与基于寄存器的指令集</li></ol><p>Javac编译器输出的字节码指令流，基本上[1]是一种基于栈的指令集架构（Instruction Set Architecture，ISA），字节码指令流里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作。与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的就是x86的二地址指令集。</p><p>基于栈的指令集主要优点是可移植，因为寄存器由硬件直接提供[2]，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束；栈架构指令集的主要缺点是理论上执行速度相对来说会稍慢一些。</p><p>在解释执行时，栈架构指令集的代码虽然紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构来得更多，因为出栈、入栈操作本身就产生了相当大量的指令。更重要的是栈实现在内存中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。尽管虚拟机可以采取栈顶缓存的优化方法，把最常用的操作映射到寄存器中避免直接内存访问，但这也只是优化措施而不是解决本质问题的方法。因此由于指令数量和内存访问的原因，导致了栈架构指令集的执行速度会相对慢上一点。</p><ol start="2"><li>基于栈的解释器执行过程</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int calc() &#123;</span><br><span class="line">int a = 100;</span><br><span class="line">int b = 200;</span><br><span class="line">int c = 300;</span><br><span class="line">return (a + b) * c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int calc();</span><br><span class="line">Code:</span><br><span class="line">Stack=2, Locals=4, Args_size=1</span><br><span class="line">0: bipush 100# Bipush指令的作用是将单字节的整型常量值（-128～127）推入操作数栈顶</span><br><span class="line">2: istore_1# istore_1指令的作用是将操作数栈顶的整型值出栈并存放到第1个局部变量槽中</span><br><span class="line">3: sipush 200</span><br><span class="line">6: istore_2</span><br><span class="line">7: sipush 300</span><br><span class="line">10: istore_3</span><br><span class="line">11: iload_1# iload_1指令的作用是将局部变量表第1个变量槽中的整型值复制到操作数栈顶</span><br><span class="line">12: iload_2# iload_2指令的作用是将局部变量表第2个变量槽中的整型值复制到操作数栈顶</span><br><span class="line">13: iadd# 栈顶取两数相加</span><br><span class="line">14: iload_3# iload_3指令的作用是将局部变量表第3个变量槽中的整型值复制到操作数栈顶</span><br><span class="line">15: imul# 栈顶取两数相除</span><br><span class="line">16: ireturn# ireturn指令是方法返回指令之一，它将结束方法执行并将操作数栈顶的整型值返回给该方法的调用者</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、运行时栈帧结构&quot;&gt;&lt;a href=&quot;#一、运行时栈帧结构&quot; class=&quot;headerlink&quot; title=&quot;一、运行时栈帧结构&quot;&gt;&lt;/a&gt;一、运行时栈帧结构&lt;/h1&gt;&lt;p&gt;代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一</summary>
      
    
    
    
    
    <category term="jdk" scheme="http://zws6672.top/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类加载机制</title>
    <link href="http://zws6672.top/2021/04/15/jdk-cload/"/>
    <id>http://zws6672.top/2021/04/15/jdk-cload/</id>
    <published>2021-04-15T14:37:42.000Z</published>
    <updated>2021-04-15T14:38:20.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、类加载的过程"><a href="#一、类加载的过程" class="headerlink" title="一、类加载的过程"></a>一、类加载的过程</h1><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。在了解了Class文件的结构后，还需要了解虚拟机如何加载字节码文件、加载字节码文件后数据发生了什么变化。</p><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的；而Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。（一般会在一个阶段执行的过程中调用、激活另一个阶段）</p><p><img src="/image/jdk/cload-lifeCycle.png" alt="类加载的过程"></p><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。</p><p>需要立即进行初始化的几种情况有且只有以下几种：</p><ul><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：<ul><li>使用new关键字实例化对象</li><li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）</li><li>调用一个类型的静态方法的时候。</li></ul></li><li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化</li><li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li>如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化</li><li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ul><p>除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。</p><ul><li>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</li><li>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</li></ul><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>“加载”（Loading）阶段是整个“类加载”（Class Loading）过程中的一个阶段，虚拟机完成以下三件事：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明二进制字节流必须得从某个Class文件中获取：从ZIP压缩包中读取、网络中获取、运行时计算生成、从数据库中读取等）</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ul><p>数组加载：</p><ul><li>对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，由Java虚拟机直接在内存中动态构造；但是数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载<ul><li>如果数组的组件类型是引用类型(Integer[])，递归采用加载过程去加载组件类型；数组将被标识在加载该组件类型的类加载器的类名称空间上</li><li>如果数组的组件类型是基本类型（int[]），Java虚拟机将会把数组C标记为与引导类加载器关联.数组类的可访问性将默认为public，可被所有的类和接口访问到。</li></ul></li></ul><p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><p>Class文件并不一定只能由Java源码编译而来，它可以使用包括靠键盘0和1直接在二进制编辑器中敲出Class文件在内的任何途径产生。Java虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有错误或有恶意企图的字节码流而导致整个系统受攻击甚至崩溃，所以验证字节码是Java虚拟机保护自身的一项必要措施。</p><p>文件格式验证</p><ul><li>是否以魔数0xCAFEBABE开头。</li><li>主、次版本号是否在当前Java虚拟机接受范围之内。</li><li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li><li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。</li><li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息等等<br>元数据验证：对字节码描述的信息进行语义分析</li><li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li><li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li><li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。<br>字节码验证</li><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作</li><li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上</li><li>保证方法体中的类型转换总是有效的（避免父类转换为子类）</li><li>符号引用验证（解析阶段）：发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生；查看该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源</li><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li><li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li><li>符号引用中的类、字段、方法的可访问性（private、protected、public、<package>）是否可被当<br>前类访问。</package></li></ul><blockquote><p>StackMapTable属性：在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化，把尽可能多的校验辅助措施挪到Javac编译器里进行；只需要检查 StackMapTable属性 中的记录是否合法即可。这项属性描述了方法体所有的基本块（Basic Block，指按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态。JDK 6的HotSpot虚拟机中提供了-XX：-UseSplitVerifier选项来关闭掉这项优化，或者使用参数-XX：+FailOverToOldVerifier要求在类型校验失败的时候退回到旧的类型推导方式进行校验。</p></blockquote><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域，在JDK 7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了</p><p>基本类型的初始化：<br><img src="/image/jdk/cload-basetypeinit.png" alt="基本数据类型的零值"></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。</p><ul><li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可</li><li>直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在</li></ul><p>《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行ane-warray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p><p>对同一个符号引用进行多次解析请求是很常见的事情。如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直能够成功；同样地，如果第一次解析失败了，其他指令对这个符号的解析请求也应该收到相同的异常，哪怕这个请求的符号在后来已成功加载进Java虚拟机内存之中。</p><ol><li>类或接口的解析</li></ol><p>类或接口的解析，假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：</p><ul><li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败。</li><li>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表该数组维度和元素的数组对象。</li><li>如果上面两步没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</li></ul><p>如果说一个D拥有C的访问权限，那就意味着以下3条规则中至少有其中一条成立：</p><ul><li>被访问类C是public的，并且与访问类D处于同一个模块。</li><li>被访问类C是public的，不与访问类D处于同一个模块，但是被访问类C的模块允许被访问类D的模块进行访问。</li><li>被访问类C不是public的，但是它与访问类D处于同一个包中。</li></ul><ol start="2"><li>字段解析<br>要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index[3]项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。</li></ol><ul><li>如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败、</li><li>如果解析成功完成，那把这个字段所属的类或接口用C表示<ul><li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束（本类的字段）</li><li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束（自定义类父接口的字段）</li><li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。（自定义类父类的字段）</li><li>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</li></ul></li></ul><p>在实际情况中，Javac编译器往往会采取比上述规范更加严格一些的约束，譬如有一个同名字段同时出现在某个类的接口和父类当中，或者同时在自己或父类的多个接口中出现，按照解析规则仍是可以确定唯一的访问字段，但Javac编译器就可能直接拒绝其编译为Class文件。</p><ol start="3"><li>方法解析</li></ol><p>方法解析的第一个步骤与字段解析一样，也是需要先解析出方法表的class_index[4]项中索引的方法所属的类或接口的符号引用，如果解析成功，那么我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的方法搜索：</p><ul><li>由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现class_index中索引的C是个接口的话，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li><li>如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出java.lang.AbstractMethodError异常。</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。</li></ul><ol start="4"><li>接口方法解析</li></ol><p>接口方法也是需要先解析出接口方法表的class_index[5]项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：</p><ul><li>与类的方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那么就直接抛出java.lang.IncompatibleClassChangeError异常。</li><li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>对于规则3，由于Java的接口允许多重继承，如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li></ul><p>在JDK 9之前，Java接口中的所有方法都默认是public的，也没有模块化的访问约束，所以不存在访问权限的问题，接口方法的符号解析就不可能抛出java.lang.IllegalAccessError异常。但在JDK 9中增加了接口的静态私有方法，也有了模块化的访问约束，所以从JDK 9起，接口方法的访问也完全有可能因访问权限控制而出现java.lang.IllegalAccessError异常</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通<br>过程序编码制定的主观计划去初始化类变量和其他资源。初始化阶段就是执行类构造器<clinit>()方法的过程，它是Javac编译器的自动生成。</clinit></p><ul><li><p><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</clinit></p></li><li><p><clinit>()方法与类的构造函数（即在虚拟机视角中的实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。</clinit></clinit></init></clinit></p></li><li><p>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作</clinit></p></li><li><p><clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</clinit></clinit></p></li><li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成</p></li><li><p><clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法</clinit></clinit></clinit></clinit></p></li><li><p>Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行完毕<clinit>()方法。</clinit></clinit></clinit></p></li></ul><h1 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h1><p>“类加载器”（Class Loader）将”通过一个类的全限定名来获取描述该类的二进制字节流”放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。</p><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。两个类进行比较时，只要加载它们的类加载器不同，那么这两个类必定不相等。</p><blockquote><p>“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况</p></blockquote><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现[1]，是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</p><ol><li>三层类加载器</li></ol><p>启动类加载器（Bootstrap Class Loader）：前面已经介绍过，这个类加载器负责加载存放在<java_home>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。</java_home></p><p>扩展类加载器（Extension Class Loader）：这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载<java_home>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。根据“扩展类加载器”这个名称，就可以推断出这是一种Java系统类库的扩展机制，JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK9之后，这种扩展机制被模块化带来的天然的扩展能力所取代。</java_home></p><p>应用程序类加载器（Application Class Loader）：这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><ol start="2"><li>双亲委派模型</li></ol><p>双亲委派模型如下：</p><p><img src="/image/jdk/cload-sq.png" alt="双亲委派模型"></p><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p><p>Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。如果定义一个和rt.jar类库中已有类重名的Java类，将会发现它可以正常编译，但永远无法被加载运行。</p><p>双亲委派模型的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">// a. 检查请求的类是否已经被加载过了</span><br><span class="line">Class c = findLoadedClass(name);</span><br><span class="line">if (c == null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">// b. 若没有则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。</span><br><span class="line">if (parent != null) &#123;</span><br><span class="line">c = parent.loadClass(name, false);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">c = findBootstrapClassOrNull(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">// 如果父类加载器抛出ClassNotFoundException，说明父类加载器无法完成加载请求</span><br><span class="line">&#125;</span><br><span class="line">if (c == null) &#123;</span><br><span class="line">// c. 在父类加载器无法加载时，再调用本身的findClass方法来进行类加载</span><br><span class="line">c = findClass(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (resolve) &#123;</span><br><span class="line">resolveClass(c);</span><br><span class="line">&#125;</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、Java模块化系统"><a href="#三、Java模块化系统" class="headerlink" title="三、Java模块化系统"></a>三、Java模块化系统</h1><p>在JDK 9中引入的Java模块化系统（Java Platform Module System，JPMS）是对Java技术的一次重要升级，为了能够实现模块化的关键目标——可配置的封装隔离机制。JDK 9的模块不仅仅像之前的JAR包那样只是简单地充当代码的容器，除了代码外，Java的模块定义还包含以下内容：</p><ul><li>依赖其他模块的列表。</li><li>导出的包列表，即其他模块可以使用的列表。</li><li>开放的包列表，即其他模块可反射访问模块的列表。</li><li>使用的服务列表。</li><li>提供服务的实现列表</li></ul><p>优点如下：</p><ul><li><p>可配置的封装隔离机制首先要解决JDK 9之前基于类路径（ClassPath）来查找依赖的可靠性问题（如果类路径中缺失了运行时依赖的类型，那就只能等程序运行到发生该类型的加载、链接时才会报出运行的异常）。而在JDK 9以后，如果启用了模块化进行封装，模块就可以声明对其他模块的显式依赖，这样Java虚拟机就能够在启动时验证应用程序开发阶段设定好的依赖关系在运行期是否完备，如有缺失那就直接启动失败，从而避免了很大一部分[1]由于类型依赖而引发的运行时异常。</p></li><li><p>可配置的封装隔离机制还解决了原来类路径上跨JAR文件的public类型的可访问性问题。JDK 9中的public类型不再意味着程序的所有地方的代码都可以随意访问到它们，模块提供了更精细的可访问性控制，必须明确声明其中哪一些public的类型可以被其他哪一些模块访问，这种访问控制也主要是在类加载过程中完成的。</p></li></ul><ol><li>模块兼容性</li></ol><p>模块化系统将按照以下规则来保证使用传统类路径依赖的Java程序可以不经修改地直接运行在JDK 9及以后的Java版本上：</p><ul><li>JAR文件在类路径的访问规则：所有类路径下的JAR文件及其他资源文件，都被视为自动打包在一个匿名模块（Unnamed Module）里，这个匿名模块几乎是没有任何隔离的，它可以看到和使用类路径上所有的包、JDK系统模块中所有的导出包，以及模块路径上所有模块中导出的包。</li><li>模块在模块路径的访问规则：模块路径下的具名模块（Named Module）只能访问到它依赖定义中列明依赖的模块和包，匿名模块里所有的内容对具名模块来说都是不可见的，即具名模块看不见传<br>统JAR包的内容。</li><li>JAR文件在模块路径的访问规则：如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个自动模块（Automatic Module）。尽管不包含module-info.class，但自动模块将默认依赖于整个模块路径中的所有模块，因此可以访问到所有模块导出的包，自动模块也默认导出自己所有的包。</li></ul><p>除了向后兼容性外，随着JDK 9模块化系统的引入，更值得关注的是它本身面临的模块间的管理和兼容性问题：如果同一个模块发行了多个不同的版本，那只能由开发者在编译打包时人工选择好正确版本的模块来保证依赖的正确性。</p><p>在JDK 9时加入Class文件格式的Module属性，里面有module_version_index这样的字段，用户可以在编译时使用“javac–module-version”来指定模块版本，在Java类库API中也存在java.lang.module.ModuleDescriptor.Version这样的接口可以在运行时获取到模块的版本号。</p><ol start="2"><li>模块化下的类加载器</li></ol><p>为了模块化系统的顺利施行，模块化下的类加载器仍然发生了一些应该被注意到变动，主要包括以下几个方面：</p><ul><li>扩展类加载器（Extension Class Loader）被平台类加载器（Platform Class Loader）取代</li><li>平台类加载器和应用程序类加载器都不再派生自java.net.URLClassLoader</li></ul><p>JDK 9中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载</p><p>三个类加载器负责各自加载的模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">启动类加载器负责加载的模块：</span><br><span class="line">java.base java.security.sasl</span><br><span class="line">java.datatransfer java.xml</span><br><span class="line">java.desktop jdk.httpserver</span><br><span class="line">java.instrument jdk.internal.vm.ci</span><br><span class="line">java.logging jdk.management</span><br><span class="line">java.management jdk.management.agent</span><br><span class="line">java.management.rmi jdk.naming.rmi</span><br><span class="line">java.naming jdk.net</span><br><span class="line">java.prefs jdk.sctp</span><br><span class="line">java.rmi jdk.unsupported</span><br><span class="line"></span><br><span class="line">平台类加载器负责加载的模块：</span><br><span class="line">java.activation* jdk.accessibility</span><br><span class="line">java.compiler* jdk.charsets</span><br><span class="line">java.corba* jdk.crypto.cryptoki</span><br><span class="line">java.scripting jdk.crypto.ec</span><br><span class="line">java.se jdk.dynalink</span><br><span class="line">java.se.ee jdk.incubator.httpclient</span><br><span class="line">java.security.jgss jdk.internal.vm.compiler*</span><br><span class="line">java.smartcardio jdk.jsobject</span><br><span class="line">java.sql jdk.localedata</span><br><span class="line">java.sql.rowset jdk.naming.dns</span><br><span class="line">java.transaction* jdk.scripting.nashorn</span><br><span class="line">java.xml.bind* jdk.security.auth</span><br><span class="line">java.xml.crypto jdk.security.jgss</span><br><span class="line">java.xml.ws* jdk.xml.dom</span><br><span class="line">java.xml.ws.annotation* jdk.zipfs</span><br><span class="line"></span><br><span class="line">应用程序类加载器负责加载的模块：</span><br><span class="line">jdk.aot jdk.jdeps</span><br><span class="line">jdk.attach jdk.jdi</span><br><span class="line">jdk.compiler jdk.jdwp.agent</span><br><span class="line">jdk.editpad jdk.jlink</span><br><span class="line">jdk.hotspot.agent jdk.jshell</span><br><span class="line">jdk.internal.ed jdk.jstatd</span><br><span class="line">jdk.internal.jvmstat jdk.pack</span><br><span class="line">jdk.internal.le jdk.policytool</span><br><span class="line">jdk.internal.opt jdk.rmic</span><br><span class="line">jdk.jartool jdk.scripting.nashorn.shell</span><br><span class="line">jdk.javadoc jdk.xml.bind*</span><br><span class="line">jdk.jcmd jdk.xml.ws*</span><br><span class="line">jdk.jconsole</span><br></pre></td></tr></table></figure><h1 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h1><blockquote><p><a href>深入理解Java虚拟机：JVM高级特性与最佳实践——虚拟机类加载机制</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、类加载的过程&quot;&gt;&lt;a href=&quot;#一、类加载的过程&quot; class=&quot;headerlink&quot; title=&quot;一、类加载的过程&quot;&gt;&lt;/a&gt;一、类加载的过程&lt;/h1&gt;&lt;p&gt;代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。在</summary>
      
    
    
    
    
    <category term="jdk" scheme="http://zws6672.top/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机——类文件结构</title>
    <link href="http://zws6672.top/2021/04/14/jdk-classesFileStruct/"/>
    <id>http://zws6672.top/2021/04/14/jdk-classesFileStruct/</id>
    <published>2021-04-14T15:19:18.000Z</published>
    <updated>2021-04-15T01:11:32.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Class文件结构"><a href="#一、Class文件结构" class="headerlink" title="一、Class文件结构"></a>一、Class文件结构</h1><p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。任何一个Class文件都对应着唯一的一个类或接口的定义信息，但是反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。</p><h3 id="无关性"><a href="#无关性" class="headerlink" title="无关性"></a>无关性</h3><p>Oracle公司以及其他虚拟机发行商发布过许多可以运行在各种不同硬件平台和操作系统上的Java虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写，到处运行”。</p><p>各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——字节码（Byte Code）是构成平台无关性的基石。但是，无关性不仅包括平台无关性，也包括了语言无关性。。但在Java技术发展之初，设计者们就曾经考虑过并实现了让其他语言运行在Java虚拟机之上的可能性，他们在发布规范文档的时候，也刻意把Java的规范拆分成了《Java语言规范》（The Java Language Specification）及《Java虚拟机规范》（The Java Virtual Machine Specification）两部分。时至今日，商业企业和开源机构已经在Java语言之外发展出一大批运行在Java虚拟机之上的语言，如Kotlin、Clojure、Groovy、JRuby、JPython、Scala等。</p><p>实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不与包括Java语言在内的任何程序语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集、符号表以及若干其他辅助信息。</p><h3 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h3><p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：</p><ul><li>无符号数：属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li>表：由多个无符号数或者其他表作为数据项构成的复合数据类型，习惯性地以“_info”结尾。</li></ul><p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的“集合”。</p><ol><li>魔数</li></ol><p>每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以随意改动。</p><ol start="2"><li>版本号和次版本号</li></ol><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。（高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件）</p><ol start="3"><li>常量池</li></ol><p>紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。</p><p>与Java中语言习惯不同，这个容量计数是从1而不是0开始的，如图6-3所示，常量池容量（偏移地址：0x00000008）为十六进制数0x0016，即十进制的22，这就代表常量池中有21项常量，索引值范围为1～21。而0表达“不引用任何一个常量池项目”的含义。Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始。</p><p>常量池中主要存放两大类常量：</p><ul><li>字面量（Literal）：接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等</li><li>符号引用（Symbolic References）<ul><li>被模块导出或者开放的包（Package）</li><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li><li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li><li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li></ul></li></ul><p>Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。</p><p>常量池中每一项常量都是一个表，最初常量表中共有11种结构各不相同的表结构数据，后来为了更好地支持动态语言调用，额外增加了4种动态语言相关的常量[1]，为了支持Java模块化系统（Jigsaw），又加入了CONSTANT_Module_info和CONSTANT_Package_info两个常量，所以截至JDK13，常量表中分别有17种不同类型的常量。</p><p>这17类表都有一个共同的特点，表结构起始的第一位是个u1类型的标志位，标志位的具体含义如下：</p><p><img src="/image/jdk/clc.png" alt="常量池"></p><p>17种数据类型的结构总表：</p><p><img src="/image/jdk/clc-type.png" alt="17种数据类型的结构总表"></p><p>在JDK的bin目录中，Oracle公司已经为我们准备好一个专门用于分析Class文件字节码的工具：javap。</p><ol start="4"><li>访问标志</li></ol><p>在常量池结束之后，紧接着的2个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final。访问标志细节如下：</p><p><img src="/image/jdk/clc-tag.png" alt="访问标志"></p><ol start="5"><li>类索引、父类索引与接口索引集合</li></ol><p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。</p><p>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中</p><p>对于接口索引集合，入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节</p><ol start="6"><li>字段表集合</li></ol><p>字段表（field_info）用于描述接口或者类中声明的变量。Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p><p>字段可以包括修饰符有字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。</p><p>跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。</p><p>对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava/lang/String；”，一个整型数组“int[]”将被记录成“[I”。用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。</p><p>字段表所包含的固定数据项目到descriptor_index为止就全部结束了，不过在descrip-tor_index之后跟随着一个属性表集合，用于存储一些额外的信息。</p><p><img src="/image/jdk/clc-field.png" alt="字段表集合"></p><ol start="7"><li>方法表集合</li></ol><p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。</p><p>因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对，synchronized、native、strictfp和abstract关键字可以修饰方法，方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志</p><p><img src="/image/jdk/clc-method-t.png" alt="方法表集合"></p><p>方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面。</p><p>在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名[2]。特征签名是指一个方法中各个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式之中，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。</p><ol start="8"><li>属性表集合</li></ol><p>属性表（attribute_info）在前面的讲解之中已经出现过数次，Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景的专有信息。</p><p>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。</p><p>对于每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。</p><p>8.1 Code属性（方法表）</p><p><img src="/image/jdk/sxb-code.png" alt="Code属性"></p><p>Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内</p><ul><li>attribute_name_index：指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”</li><li>attribute_length：指示了属性值的长度</li><li>max_stack：代表了操作数栈（Operand Stack）深度的最大值，虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。<ul><li>对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long这两种64位的数据类型则需要两个变量槽来存放。</li><li>max_locals的值不等于局部变量所占 变量槽 数量之和，因为局部变量超出作用域后，变量槽可以被其它局部变量使用。Javac编译器会根据变量的作用域来分配变量槽给各个变量使用，根据同时生存的最大局部变量数量和类型计算出max_locals的大小。</li></ul></li><li>max_locals：代表了局部变量表所需的存储空间，单位是变量槽（Slot）</li><li>code_length代表字节码长度</li><li>code是用于存储字节码指令的一系列字节流</li><li>显式异常处理表集合（异常表、try-catch-finally）：从第start_pc行[1]到第end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理。</li></ul><blockquote><p>《Java虚拟机规范》中明确要求Java语言的编译器应当选择使用异常表而不是通过跳转指令来实现Java异常及finally处理机制</p></blockquote><p>8.2 Exceptions属性</p><p>Exceptions属性是在方法表中与Code属性平级的一项属性，与异常表是不同的。Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。</p><ul><li>attribute_name_index：指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”</li><li>attribute_length：指示了属性值的长度</li><li>number_of_exceptions：表示方法可能抛出number_of_exceptions种受查异常</li><li>exception_index_table：受检查异常的列表</li></ul><p>8.3 LineNumberTable属性</p><p>LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系，它并不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：lines选项来取消或要求生成这项信息。</p><p><img src="/image/jdk/sxb-LineNumberTable.png" alt="LineNumberTable属性"></p><p>8.4 LocalVariableTable及LocalVariableTypeTable属性</p><p>LocalVariableTable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系，它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：vars选项来取消或要求生成这项信息。</p><p>LocalVariableTypeTable属性，使用字段的特征签名来完成泛型的描述。</p><p>8.5 SourceFile及SourceDebugExtension属性</p><p>SourceFile属性用于记录生成这个Class文件的源码文件名称。这个属性也是可选的，可以使用Javac的-g：none或-g：source选项来关闭或要求生成这项信息。在JDK 5时，新增了SourceDebugExtension属性用于存储额外的代码调试信息。</p><p>8.6 ConstantValue属性</p><p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才可以使用这项属性。对非static类型的变量（也就是实例变量）的赋值是在实例构造器<init>()方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器<clinit>()方法中或者使用ConstantValue属性。</clinit></init></p><p>目前Oracle公司实现的Javac编译器的选择是，如果同时使用final和static来修饰一个变量（按照习惯，这里称“常量”更贴切），并且这个变量的数据类型是基本类型或者java.lang.String的话，就将会生成ConstantValue属性来进行初始化；如果这个变量没有被final修饰，或者并非基本类型及字符串，则将会选择在<clinit>()方法中进行初始化。</clinit></p><p>8.7 InnerClasses属性</p><p>InnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。</p><p><img src="/image/jdk/sxb-InnerClasses.png" alt="InnerClasses属性"></p><p>8.8 Deprecated及Synthetic属性</p><p>Deprecated和Synthetic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。</p><ul><li>Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用“@deprecated”注解进行设置。</li><li>Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的，在JDK 5之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的ACC_SYNTHETIC标志位。</li></ul><p>8.9 StackMapTable属性</p><p>StackMapTable属性在JDK 6增加到Class文件规范之中，它是一个相当复杂的变长属性，位于Code属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用。</p><p>StackMapTable属性中包含零至多个栈映射帧（Stack Map Frame），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示执行到该字节码时局部变量表和操作数栈的验证类型。</p><p>8.10 Signature属性</p><p>任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variable）或参数化类型（ParameterizedType），则Signature属性会为它记录泛型签名信息</p><ul><li>parameterized types：参数化类型，对应ParameterizedType，带有类型参数的类型，即常说的泛型，如：List<t>、Map&lt;Integer, String&gt;、List&lt;? extends Number&gt;。</t></li><li>type variables：类型变量，对应TypeVariable<d>，如参数化类型中的E、K等类型变量，表示泛指任何类。</d></li></ul><p>8.11 BootstrapMethods属性和MethodParameters属性</p><p>BootstrapMethods属性在JDK 7时增加到Class文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokedynamic指令引用的引导方法限定符。<br>MethodParameters是在JDK 8时新加入到Class文件格式中的，它是一个用在方法表中的变长属性。MethodParameters的作用是记录方法的各个形参名称和信息</p><p>8.12 模块化相关属性</p><p>JDK 9的一个重量级功能是Java的模块化功能，因为模块描述文件（module-info.java）最终是要编译成一个独立的Class文件来存储的，所以，Class文件格式也扩展了Module、ModulePackages和ModuleMainClass三个属性用于支持Java模块化相关功能。</p><p><img src="/image/jdk/sxb-module-info.png" alt="模块化相关属性"></p><p>8.13 运行时注解相关属性</p><p>Java语言的语法提供了对注解（Annotation）的支持，增加了RuntimeVisibleAnnotations、RuntimeInvisibleAnnotations、RuntimeVisibleParameterAnnotations、RuntimeInvisibleParameter-Annotations、RuntimeVisibleTypeAnnotations和RuntimeInvisibleTypeAnnotations 几个属性。这六个属性不论结构还是功能都比较雷同，以RuntimeVisibleAnnotations为例。</p><p><img src="/image/jdk/sxb-Annotations.png" alt="运行时注解相关属性"></p><h1 id="二、字节码指令"><a href="#二、字节码指令" class="headerlink" title="二、字节码指令"></a>二、字节码指令</h1><p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成。由于Java虚拟机采用面向操作数栈而不是面向寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。</p><ul><li><p>缺点</p><ul><li>由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不能够超过256条。</li><li>Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机在处理那些超过一个字节的数据时，不得不在运行时从字节中重建出具体数据的结构，导致解释执行字节码时将损失一些性能。</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 譬如要将一个16位长度的无符号整数使用两个无符号字节存储起来</span><br><span class="line">(byte1 &lt;&lt; 8) | byte2</span><br></pre></td></tr></table></figure></li></ul></li><li><p>优点</p><ul><li>使用多个无符号字节存储长度超过一个字节的数据，放弃了操作数长度对齐，就意味着可以省略掉大量的填充和间隔符号。</li><li>编译代码短小精干，这是小数据量、高传输效率的设计。</li></ul></li></ul><h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><p>在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。例如，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。</p><p><img src="/image/jdk/zjm-lx.png" alt="字节码与数据类型"></p><p>大部分指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的对int类型作为运算类型（Computational Type）来进行的。</p><blockquote><p>注：i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference</p></blockquote><ol><li>加载和存储指令</li></ol><p>用于将数据在栈帧中的局部变量表和操作数栈之间传输</p><ul><li>将一个局部变量加载到操作栈：iload、iload_<n>、lload、lload_<n>、fload、fload_<n>、dload、dload_<n>、aload、aload_<n></n></n></n></n></n></li><li>将一个数值从操作数栈存储到局部变量表：istore、istore_<n>、lstore、lstore_<n>、fstore、fstore_<n>、dstore、dstore_<n>、astore、astore_<n></n></n></n></n></n></li><li>将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_<i>、lconst_<l>、fconst_<f>、dconst_<d></d></f></l></i></li><li>扩充局部变量表的访问索引的指令：wide</li></ul><ol start="2"><li>运算指令</li></ol><p>用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶</p><ul><li>加法指令：iadd、ladd、fadd、dadd</li><li>减法指令：isub、lsub、fsub、dsub</li><li>乘法指令：imul、lmul、fmul、dmul</li><li>除法指令：idiv、ldiv、fdiv、ddiv</li><li>求余指令：irem、lrem、frem、drem</li><li>取反指令：ineg、lneg、fneg、dneg</li><li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr</li><li>按位或指令：ior、lor</li><li>按位与指令：iand、land</li><li>按位异或指令：ixor、lxor</li><li>局部变量自增指令：iinc</li><li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp</li></ul><ol start="3"><li>类型转换指令</li></ol><p>可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p><p>Java虚拟机直接支持（即转换时无须显式的转换指令）以下数值类型的宽化类型转换（Widening Numeric Conversion，即小范围类型向大范围类型的安全转换）：</p><ul><li>int类型到long、float或者double类型</li><li>long类型到float、double类型</li><li>float类型到double类型</li></ul><p>处理窄化类型转换（Narrowing Numeric Conversion）时，就必须显式地使用转换指令来完成，这些转换指令包括i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。</p><ol start="4"><li>对象创建与访问指令</li></ol><p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令（在下一章会讲到数组和普通类的类型创建过程是不同的）。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：</p><ul><li>创建类实例的指令：new</li><li>创建数组的指令：newarray、anewarray、multianewarray</li><li>访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic</li><li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、aload、aaload</li><li>将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、astore、aastore</li><li>取数组长度的指令：arraylength</li><li>检查类实例类型的指令：instanceof、checkcast</li></ul><ol start="5"><li>操作数栈管理指令</li></ol><p>Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：</p><ul><li>将操作数栈的栈顶一个或两个元素出栈：pop、pop2</li><li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、up2_x1、dup_x2、dup2_x2</li><li>将栈最顶端的两个数值互换：swap</li></ul><ol start="6"><li>控制转移指令</li></ol><p>控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存器的值。控制转移指令包括：</p><ul><li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、f_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne</li><li>复合条件分支：tableswitch、lookupswitch</li><li>无条件分支：goto、goto_w、jsr、jsr_w、ret</li></ul><ol start="6"><li>方法调用和返回指令</li></ol><ul><li>invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），也是Java语言中最常见的方法分派方式。</li><li>invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找适合的方法进行调用。</li><li>invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和类方法。</li><li>invokestatic指令：用于调用类静态方法（static方法）。</li><li>invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li></ul><ol start="7"><li>异常处理指令</li></ol><p>在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语句显式抛出异常的情况之外。而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的而是采用异常表来完成。</p><ol start="8"><li>同步指令</li></ol><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。</p><p>方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。</p><p>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持。</p><blockquote><p>注：指令助记符以尖括号结尾（例如iload_<n>），这些指令助记符实际上代表了一组指令（例如iload_<n>，它代表了iload_0、iload_1、iload_2和iload_3这几条指令）。这几组指令都是某个带有一个操作数的通用指令（例如iload）的特殊形式，对于这几组特殊指令，它们省略掉了显式的操作数，不需要进行取操作数的动作，因为实际上操作数就隐含在指令中</n></n></p></blockquote><h3 id="公有设计，私有实现"><a href="#公有设计，私有实现" class="headerlink" title="公有设计，私有实现"></a>公有设计，私有实现</h3><p>《Java虚拟机规范》描绘了Java虚拟机应有的共同程序存储格式：Class文件格式以及字节码指令集。</p><p>虚拟机实现者可以使用这种伸缩性来让Java虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性，选择哪种特性取决于Java虚拟机实现的目标和关注点是什么，虚拟机实现的方式主要有以下两种：</p><ul><li>将输入的Java虚拟机代码在加载时或执行时翻译成另一种虚拟机的指令集</li><li>将输入的Java虚拟机代码在加载时或执行时翻译成宿主机处理程序的本地指令集（即即时编译器代码生成技术）。</li></ul><h1 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h1><blockquote><p><a href>深入理解Java虚拟机：JVM高级特性与最佳实践（第3版） ————虚拟机执行部分————类文件结构</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Class文件结构&quot;&gt;&lt;a href=&quot;#一、Class文件结构&quot; class=&quot;headerlink&quot; title=&quot;一、Class文件结构&quot;&gt;&lt;/a&gt;一、Class文件结构&lt;/h1&gt;&lt;p&gt;Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格</summary>
      
    
    
    
    
    <category term="jdk" scheme="http://zws6672.top/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 使用 AOP（面向切面编程）</title>
    <link href="http://zws6672.top/2021/04/04/springboot-aop/"/>
    <id>http://zws6672.top/2021/04/04/springboot-aop/</id>
    <published>2021-04-04T13:44:37.000Z</published>
    <updated>2021-04-06T03:05:22.651Z</updated>
    
    <content type="html"><![CDATA[<p>AOP （Aspect Orient Programming）,译为 面向切面编程，AOP 是一种编程思想，是面向对象编程（OOP）的一种补充。</p><h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p>面向切面编程实现了横切关注点的模块化，即多应用对象相同的处理逻辑被抽象为模块。在多个模块中，如果存在重复的代码，我们可以通过将该代码段抽取成特定的方法使用。但是，如果有新的需求，又需要重复增加新的方法。这时，我们可以通过AOP在不修改源码的情况下，为系统的多个组件添加相同的功能。</p><ol><li>分类</li></ol><p>AOP可以分为两类：</p><ul><li>静态 AOP 实现：代理类和被代理的类实现了同样的接口，代理类同时持有被代理类的引用，通过该引用代理类可以调用被代理类的方法</li><li>动态 AOP 实现： AOP 框架在运行阶段动态生成代理对象<ul><li>JDK 动态代理：利用反射机制生成一个实现代理接口的类，在调用具体方法前调用InvokeHandler来处理；针对实现接口的类生成代理。</li><li>CGlib 动态代理：利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理；针对类实现代理，不能代理final修饰的类。</li></ul></li></ul><ol start="2"><li>实现</li></ol><p>AOP 实现的比较：<br><img src="/image/ssm/aop.png" alt="AOP 实现"></p><ol start="3"><li>术语</li></ol><ul><li>连接点（Joinpoint）：程序执行的某个特定位置，如类开始初始化前、类初始化后、类某个方法调用前、调用后、方法抛出异常后。一个类或一段程序代码拥有一些具有边界性质的特定点，这些点中的特定点就称为“连接点”。Spring仅支持方法的连接点，即仅能在方法调用前、方法调用后、方法抛出异常时以及方法调用前后这些程序执行点织入增强</li><li>切点（Pointcut）：每个程序都可以拥有多个连接点，而AOP通过切点查询连接点。切点与连接点的关系是一对多的关系。在Spring中，切点通过org.springframework.aop.Pointcut接口进行描述，它使用类和方法作为连接点的查询条件，Spring AOP的规则解析引擎负责切点所设定的查询条件，找到对应的连接点。</li><li>增强（Advice）；增强是织入到目标类连接点上的一段程序代码，在Spring中，增强除用于描述一段程序代码外，还拥有另一个和连接点相关的信息，这便是执行点的方位。结合执行点方位信息和切点信息，我们就可以找到特定的连接点</li><li>目标对象（Target）：    增强逻辑的织入目标类。如果没有AOP，目标业务类需要自己实现所有逻辑，而在AOP的帮助下，目标业务类只实现那些非横切逻辑的程序逻辑，而性能监视和事务管理等这些横切逻辑则可以使用AOP动态织入到特定的连接点上。</li><li>引介（Introduction）：引介是一种特殊的增强，它为类添加一些属性和方法</li><li>织入（Weaving）：织入是将增强添加对目标类具体连接点上的过程；织入方式如下：<ul><li>编译期织入，这要求使用特殊的Java编译器。</li><li>类装载期织入，这要求使用特殊的类装载器。</li><li>动态代理织入，在运行期为目标类添加增强生成子类的方式。（Spring采用的方式）</li></ul></li><li>切面（Aspect）：切面由切点和增强（引介）组成，它既包括了横切逻辑的定义，也包括了连接点的定义，Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。</li></ul><p>通知（Advice）类型：</p><ul><li>前置通知（Before advice）：在某连接点（JoinPoint）之前执行的通知，但这个通知不能阻止连接点前的执行</li><li>后置通知（After advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）</li><li>返回后通知（After return advice）：在某连接点正常完成后执行的通知，不包括抛出异常的情况</li><li>环绕通知（Around advice）：包围一个连接点的通知，类似Web中Servlet规范中的Filter的doFilter方法。可以在方法的调用前后完成自定义的行为，也可以选择不执行</li><li>抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知</li></ul><h1 id="二、JDK-动态代理"><a href="#二、JDK-动态代理" class="headerlink" title="二、JDK 动态代理"></a>二、JDK 动态代理</h1><p>Java动态代理类位于java.lang.reflect包下，是使用InvocationHandler和Proxy实现的。</p><ol><li>InvocationHandler</li></ol><p>InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法。 相关源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Object proxy 代理类</span><br><span class="line">// Method method 被代理的方法</span><br><span class="line">// Object[] args 方法的参数数组</span><br><span class="line">public interface InvocationHandler &#123;</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">        throws Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个接口，我们可以实现一个处理器，提供给代理类使用。</p><ol start="2"><li>Proxy</li></ol><p>Proxy类就是用来创建一个代理对象的类，一般通过 newProxyInstance 方法来生成对应类的代理类。</p><p>相关源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 返回代理类的一个实例，返回后的代理类可以当作被代理类使用(可使用被代理类的在接口中声明过的方法)</span><br><span class="line">// loader：classloader对象，定义了由哪个类加载器对象对生成的代理类进行加载</span><br><span class="line">// interfaces：接口数组，表示为代理对象提供的数组</span><br><span class="line">// h：InvocationHandler对象，表示的是当动态代理对象调用方法的时候会关联到哪一个InvocationHandler对象上，并最终由其调用</span><br><span class="line"></span><br><span class="line">@CallerSensitive</span><br><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">  Class&lt;?&gt;[] interfaces,</span><br><span class="line">  InvocationHandler h)</span><br></pre></td></tr></table></figure><ol start="3"><li>实例</li></ol><p>对应步骤如下：</p><ul><li>创建一个实现接口InvocationHandler的类，它必须实现invoke方法</li><li>创建被代理的类以及接口</li><li>通过Proxy的静态方法newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)创建一个代理</li><li>通过代理调用方法</li></ul><p>对应实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/4/3 23:16</span><br><span class="line"> * @Description JDK 代理模式</span><br><span class="line"> */</span><br><span class="line">public class JdkProxy &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        Weapon realWeapon = new Gun();</span><br><span class="line">        InvocationHandler handler = new MyInvocationHandler(realWeapon);</span><br><span class="line">        ClassLoader classLoader = realWeapon.getClass().getClassLoader();</span><br><span class="line">        Class[] clazz = realWeapon.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line">        Weapon weapon = (Weapon) Proxy.newProxyInstance(classLoader, clazz, handler);</span><br><span class="line">        System.out.println(realWeapon);</span><br><span class="line">        System.out.println(weapon);</span><br><span class="line"></span><br><span class="line">        weapon.description();</span><br><span class="line">        weapon.use();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用处理器实现类</span><br><span class="line">class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    private Object weapon;</span><br><span class="line"></span><br><span class="line">    public MyInvocationHandler(Object weapon) &#123;</span><br><span class="line">        this.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;在调用实际对象前，实现附加功能&quot;);</span><br><span class="line">        Object res = method.invoke(weapon, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;在调用实际对象后，实现附加功能&quot;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 动态代理的接口</span><br><span class="line">interface Weapon &#123;</span><br><span class="line">    void use();</span><br><span class="line">    void description();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代理的实际对象</span><br><span class="line">class Gun implements Weapon &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void use() &#123;</span><br><span class="line">        System.out.println(&quot;use gun&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void description() &#123;</span><br><span class="line">        System.out.println(&quot;This is a gun&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、CGlib-动态代理"><a href="#三、CGlib-动态代理" class="headerlink" title="三、CGlib 动态代理"></a>三、CGlib 动态代理</h1><ol><li>Enhancer</li></ol><p>我们需要使用setSuperclass方法设置父类(可以是接口或者是自定义类)，相关源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void setSuperclass(Class superclass) &#123;</span><br><span class="line">// 当传入的参数为接口。</span><br><span class="line">// Enhancer允许为非接口类型创建一个Java代理。Enhancer动态创建了给定类型的子类但是拦截了所有的方法。和Proxy不一样的是，不管是接口还是类他都能正常工作。</span><br><span class="line">if (superclass != null &amp;&amp; superclass.isInterface()) &#123;</span><br><span class="line">this.setInterfaces(new Class[]&#123;superclass&#125;);</span><br><span class="line">this.setContextClass(superclass);</span><br><span class="line">&#125; else if (superclass != null &amp;&amp; superclass.equals(Object.class)) &#123;</span><br><span class="line">// 当传入的参数为Object类</span><br><span class="line">this.superclass = null;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 当传入的是自定义类</span><br><span class="line">this.superclass = superclass;</span><br><span class="line">this.setContextClass(superclass);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过create方法可以创建对应的类，其实是调用另外一个私有的方法createHelper，相关源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//用于创建类</span><br><span class="line">public Object create() &#123;</span><br><span class="line">this.classOnly = false;</span><br><span class="line">this.argumentTypes = null;</span><br><span class="line">return this.createHelper();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// </span><br><span class="line">private Object createHelper() &#123;</span><br><span class="line">// 验证是否配置回调类型，验证过滤器是否为空</span><br><span class="line">        this.preValidate();</span><br><span class="line"></span><br><span class="line">        Object key = KEY_FACTORY.newInstance(this.superclass != null ? this.superclass.getName() : null, ReflectUtils.getNames(this.interfaces), this.filter == ALL_ZERO ? null : new WeakCacheKey(this.filter), this.callbackTypes, this.useFactory, this.interceptDuringConstruction, this.serialVersionUID);</span><br><span class="line">        this.currentKey = key;</span><br><span class="line">        Object result = super.create(key);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 静态代理工厂，用于创建类</span><br><span class="line">private static final Enhancer.EnhancerKey KEY_FACTORY;</span><br><span class="line"></span><br><span class="line">// 提供一个创建类的接口</span><br><span class="line">public interface EnhancerKey &#123;</span><br><span class="line">// String var1 被代理的类名</span><br><span class="line">// String[] var2 被代理的接口名</span><br><span class="line">// WeakCacheKey&lt;CallbackFilter&gt; var3 回调过滤器</span><br><span class="line">// Type[] var4 过滤器接口</span><br><span class="line">// boolean var5 使用工厂</span><br><span class="line">// boolean var6 使用构造器拦截器</span><br><span class="line">// Long var7 serialVersionUID 序列化ID</span><br><span class="line">Object newInstance(String var1, String[] var2, WeakCacheKey&lt;CallbackFilter&gt; var3, Type[] var4, boolean var5, boolean var6, Long var7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>实例</li></ol><p>对应实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/4/4 14:48</span><br><span class="line"> * @Description CGLIB 动态代理</span><br><span class="line"> */</span><br><span class="line">public class CGlibProxy &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">//  Enhancer是CGLIB的字节码增强器，可以很方便的对类进行拓展</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">//设置被代理的类</span><br><span class="line">        enhancer.setSuperclass(Hello.class);</span><br><span class="line">//        设置过滤器</span><br><span class="line">        enhancer.setCallback(new HelloMethodInterceptor());</span><br><span class="line">//        通过enhancer创建对象</span><br><span class="line">        Hello hello = (Hello) enhancer.create();</span><br><span class="line">        hello.ha();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Hello &#123;</span><br><span class="line">    void ha() &#123;</span><br><span class="line">        System.out.println(&quot;Hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HelloMethodInterceptor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;调用&quot;+method.getName()+&quot;方法前输出&quot;);</span><br><span class="line">        Object o1 = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(&quot;调用&quot;+method.getName()+&quot;方法后输出&quot;);</span><br><span class="line">        return o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CGLIB中，方法的调用并不是通过反射来完成的，而是直接对方法进行调用：FastClass对Class对象进行特别的处理，比如将会用数组保存method的引用，每次调用方法的时候都是通过一个index下标来保持对方法的引用，因此比JDK 动态代理速度快。但是，CGLIB无法代理被final修饰的方法。</p><ol start="3"><li>FastClass机制</li></ol><p>Cglib动态代理执行代理方法效率之所以比JDK的高是因为Cglib采用了FastClass机制，它的原理简单来说就是：为代理类和被代理类各生成一个Class，这个Class会为代理类或被代理类的方法分配一个index(int类型)。这个index当做一个入参，FastClass就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比JDK动态代理通过反射调用高。</p><h1 id="四、SpringBoot-使用-AOP"><a href="#四、SpringBoot-使用-AOP" class="headerlink" title="四、SpringBoot 使用 AOP"></a>四、SpringBoot 使用 AOP</h1><ol><li>AOP标准</li></ol><p>AOP联盟标准：<br><img src="/image/ssm/aop-gf.png" alt="AOP 规范"></p><p>AOP 实现方式有很多种，包括反射、元数据处理、程序处理、拦截器处理等。而Spring AOP的实现使用的是Java语言本身的特性，即Java Proxy代理类、拦截器技术实现。</p><p>Springboot使用 aop 可以通过maven引入相应包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  springboot web 模块 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--  aop--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>PCD</li></ol><p>PCD(pointcut designators )就是SpringAOP的切点表达式。SpringAOP的PCD是完全兼容AspectJ的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">语法格式如下：</span><br><span class="line">execution(&lt;修饰符模式&gt;? &lt;返回类型模式&gt; &lt;方法名模式&gt;(&lt;参数模式&gt;) &lt;异常模式&gt;?)</span><br><span class="line"></span><br><span class="line">除了返回类型模式、方法名模式和参数模式外，其它项都是可选的。</span><br><span class="line"></span><br><span class="line">-- 所有公有方法的执行</span><br><span class="line">execution(public * *(..))</span><br><span class="line"></span><br><span class="line">-- 设置指定格式开头的方法</span><br><span class="line">execution(* test*(..))</span><br><span class="line"></span><br><span class="line">-- AccountService接口下的所有方法的执行</span><br><span class="line">execution(* com.service.AccountService.*(..))</span><br><span class="line"></span><br><span class="line">-- 匹配com.xyz.service包下的所有类的所有方法（不含子包）</span><br><span class="line">within(com.xyz.service.*)</span><br></pre></td></tr></table></figure><ol start="3"><li>aop 实例：拦截控制器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/4/4 16:52</span><br><span class="line"> * @Description 控制器切面</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class ControllerAop &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 指定切点</span><br><span class="line">     * 匹配 com.wsz.tool.rabbitmq.controller包及其子包下的所有类的所有方法</span><br><span class="line">     */</span><br><span class="line">//    @Pointcut(&quot;execution(public * com.wsz.tool.rabbitmq.controller..*.*(..))&quot;)</span><br><span class="line">    @Pointcut(&quot;execution(public * com.wsz.tool.rabbitmq.controller.*Controller.*(..))&quot;)</span><br><span class="line">    public void log() &#123;</span><br><span class="line">        System.out.println(&quot;日志输出：&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;log()&quot;)</span><br><span class="line">    public void doBefore(JoinPoint joinPoint) &#123;</span><br><span class="line">        System.out.println(&quot;前置通知&quot;);</span><br><span class="line">//        目标方法的参数信息</span><br><span class="line">        Object[] objects = joinPoint.getArgs();</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line"></span><br><span class="line">//        代理方法名</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;代理方法名：&quot;+signature.getName());</span><br><span class="line">        System.out.println(&quot;代理类名：&quot;+signature.getDeclaringTypeName());</span><br><span class="line">        signature.getDeclaringType();</span><br><span class="line">        MethodSignature ms = (MethodSignature) signature;</span><br><span class="line">        System.out.println(&quot;参数名：&quot;+ Arrays.toString(ms.getParameterNames()));</span><br><span class="line">        System.out.println(&quot;参数值：&quot;+ Arrays.toString(joinPoint.getArgs()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 接收到请求，记录请求内容</span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest req = attributes.getRequest();</span><br><span class="line">        // 记录下请求内容</span><br><span class="line">        System.out.println(&quot;请求URL : &quot; + req.getRequestURL().toString());</span><br><span class="line">        System.out.println(&quot;HTTP_METHOD : &quot; + req.getMethod());</span><br><span class="line">        System.out.println(&quot;IP : &quot; + req.getRemoteAddr());</span><br><span class="line">        System.out.println(&quot;CLASS_METHOD : &quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    后置异常通知</span><br><span class="line">    @AfterThrowing(&quot;log()&quot;)</span><br><span class="line">    public void throwss(JoinPoint jp) &#123;</span><br><span class="line">        System.out.println(&quot;异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @After(&quot;log()&quot;)</span><br><span class="line">    public void after (JoinPoint jp) &#123;</span><br><span class="line">        System.out.println(&quot;后置通知&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>aop实例：拦截自定义注解</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/4/4 20:12</span><br><span class="line"> * @Description 自定义Log注解</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">*注解的作用目标：</span><br><span class="line">*　@Target(ElementType.TYPE)                      // 接口、类、枚举、注解</span><br><span class="line">*　@Target(ElementType.FIELD)                     // 字段、枚举的常量</span><br><span class="line">*　@Target(ElementType.METHOD)                 // 方法</span><br><span class="line">*  @Target(ElementType.PARAMETER)            // 方法参数</span><br><span class="line">*　@Target(ElementType.CONSTRUCTOR)       // 构造函数</span><br><span class="line">*　@Target(ElementType.LOCAL_VARIABLE)   // 局部变量</span><br><span class="line">*　@Target(ElementType.ANNOTATION_TYPE) // 注解</span><br><span class="line">*　@Target(ElementType.PACKAGE)               // 包</span><br><span class="line">*/</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Documented</span><br><span class="line">public @interface MyLog &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/4/4 20:20</span><br><span class="line"> * @Description 自定义注解使用</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class TestService &#123;</span><br><span class="line"></span><br><span class="line">    @MyLog(&quot;TestService&quot;)</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        System.out.println(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/4/4 20:13</span><br><span class="line"> * @Description AOP拦截自定义注解</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class MyLogAop &#123;</span><br><span class="line">    @Pointcut(&quot;execution(public * com.wsz.tool.rabbitmq.aop.MyLog.*(..))&quot;)</span><br><span class="line">    public void log() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * @Pointcut与@Around的区别：@Pointcut与@Around可以使用相同的PCD表达式，@Pointcut定义的可以重复使用，而@Around不可以</span><br><span class="line">     */</span><br><span class="line"> </span><br><span class="line">    @Around(value = &quot;@annotation(com.wsz.tool.rabbitmq.aop.MyLog)&quot;)</span><br><span class="line">    public void before(JoinPoint point) &#123;</span><br><span class="line">        System.out.println(&quot;MyLogAop前置通知&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>aop实例：日志<br><a href="https://github.com/xkcoding/spring-boot-demo/tree/master/demo-log-aop" target="_blank" rel="noopener">aop切面日志新增json参数打印和高并发场景</a></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class AopLog &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 切入点</span><br><span class="line">     */</span><br><span class="line">    @Pointcut(&quot;execution(public * com.xkcoding.log.aop.controller.*Controller.*(..))&quot;)</span><br><span class="line">    public void log() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 环绕操作</span><br><span class="line">     *</span><br><span class="line">     * @param point 切入点</span><br><span class="line">     * @return 原方法返回值</span><br><span class="line">     * @throws Throwable 异常信息</span><br><span class="line">     */</span><br><span class="line">    @Around(&quot;log()&quot;)</span><br><span class="line">    public Object aroundLog(ProceedingJoinPoint point) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">        // 开始打印请求日志</span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = Objects.requireNonNull(attributes).getRequest();</span><br><span class="line"></span><br><span class="line">        // 打印请求相关参数</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        Object result = point.proceed();</span><br><span class="line">        String header = request.getHeader(&quot;User-Agent&quot;);</span><br><span class="line">        UserAgent userAgent = UserAgent.parseUserAgentString(header);</span><br><span class="line"></span><br><span class="line">        final Log l = Log.builder()</span><br><span class="line">            .threadId(Long.toString(Thread.currentThread().getId()))</span><br><span class="line">            .threadName(Thread.currentThread().getName())</span><br><span class="line">            .ip(getIp(request))</span><br><span class="line">            .url(request.getRequestURL().toString())</span><br><span class="line">            .classMethod(String.format(&quot;%s.%s&quot;, point.getSignature().getDeclaringTypeName(),</span><br><span class="line">                point.getSignature().getName()))</span><br><span class="line">            .httpMethod(request.getMethod())</span><br><span class="line">            .requestParams(getNameAndValue(point))</span><br><span class="line">            .result(result)</span><br><span class="line">            .timeCost(System.currentTimeMillis() - startTime)</span><br><span class="line">            .userAgent(header)</span><br><span class="line">            .browser(userAgent.getBrowser().toString())</span><br><span class="line">            .os(userAgent.getOperatingSystem().toString()).build();</span><br><span class="line"></span><br><span class="line">        log.info(&quot;Request Log Info : &#123;&#125;&quot;, JSONUtil.toJsonStr(l));</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  获取方法参数名和参数值</span><br><span class="line">     * @param joinPoint</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Map&lt;String, Object&gt; getNameAndValue(ProceedingJoinPoint joinPoint) &#123;</span><br><span class="line"></span><br><span class="line">        final Signature signature = joinPoint.getSignature();</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">        final String[] names = methodSignature.getParameterNames();</span><br><span class="line">        final Object[] args = joinPoint.getArgs();</span><br><span class="line"></span><br><span class="line">        if (ArrayUtil.isEmpty(names) || ArrayUtil.isEmpty(args)) &#123;</span><br><span class="line">            return Collections.emptyMap();</span><br><span class="line">        &#125;</span><br><span class="line">        if (names.length != args.length) &#123;</span><br><span class="line">            log.warn(&quot;&#123;&#125;方法参数名和参数值数量不一致&quot;, methodSignature.getName());</span><br><span class="line">            return Collections.emptyMap();</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Object&gt; map = Maps.newHashMap();</span><br><span class="line">        for (int i = 0; i &lt; names.length; i++) &#123;</span><br><span class="line">            map.put(names[i], args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final String UNKNOWN = &quot;unknown&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取ip地址</span><br><span class="line">     */</span><br><span class="line">    public static String getIp(HttpServletRequest request) &#123;</span><br><span class="line">        String ip = request.getHeader(&quot;x-forwarded-for&quot;);</span><br><span class="line">        if (ip == null || ip.length() == 0 || UNKNOWN.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || UNKNOWN.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || UNKNOWN.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line">        String comma = &quot;,&quot;;</span><br><span class="line">        String localhost = &quot;127.0.0.1&quot;;</span><br><span class="line">        if (ip.contains(comma)) &#123;</span><br><span class="line">            ip = ip.split(&quot;,&quot;)[0];</span><br><span class="line">        &#125;</span><br><span class="line">        if (localhost.equals(ip)) &#123;</span><br><span class="line">            // 获取本机真正的ip地址</span><br><span class="line">            try &#123;</span><br><span class="line">                ip = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">                log.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Data</span><br><span class="line">    @Builder</span><br><span class="line">    @NoArgsConstructor</span><br><span class="line">    @AllArgsConstructor</span><br><span class="line">    static class Log &#123;</span><br><span class="line">        // 线程id</span><br><span class="line">        private String threadId;</span><br><span class="line">        // 线程名称</span><br><span class="line">        private String threadName;</span><br><span class="line">        // ip</span><br><span class="line">        private String ip;</span><br><span class="line">        // url</span><br><span class="line">        private String url;</span><br><span class="line">        // http方法 GET POST PUT DELETE PATCH</span><br><span class="line">        private String httpMethod;</span><br><span class="line">        // 类方法</span><br><span class="line">        private String classMethod;</span><br><span class="line">        // 请求参数</span><br><span class="line">        private Object requestParams;</span><br><span class="line">        // 返回参数</span><br><span class="line">        private Object result;</span><br><span class="line">        // 接口耗时</span><br><span class="line">        private Long timeCost;</span><br><span class="line">        // 操作系统</span><br><span class="line">        private String os;</span><br><span class="line">        // 浏览器</span><br><span class="line">        private String browser;</span><br><span class="line">        // user-agent</span><br><span class="line">        private String userAgent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>如下代码，<code>@Transactional</code>有没有生效？</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class OrderService &#123;</span><br><span class="line"> </span><br><span class="line">private void insert() &#123;</span><br><span class="line">insertOrder();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Transactional</span><br><span class="line">public void insertOrder() &#123;</span><br><span class="line">//SQL操作</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有，<code>@Transactional</code>底层基于AOP实现，自身调用是无法生效的。因为在 Spring 的 AOP 代理下，只有目标方法由外部调用，目标方法才由 Spring 生成的代理对象来管理，这会造成自调用问题。insert()是由被代理对象调用的，而它内调的方法insertOrder() 就不会由代理对象调用，也就无法被添加事务。</p><h1 id="五、参考文章"><a href="#五、参考文章" class="headerlink" title="五、参考文章"></a>五、参考文章</h1><blockquote><p><a href="https://www.cnblogs.com/joy99/p/10941543.html" target="_blank" rel="noopener">Spring AOP——Spring 中面向切面编程</a><br><a href="https://blog.csdn.net/wyl6019/article/details/80136000" target="_blank" rel="noopener">Spring AOP实现原理简介</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;AOP （Aspect Orient Programming）,译为 面向切面编程，AOP 是一种编程思想，是面向对象编程（OOP）的一种补充。&lt;/p&gt;
&lt;h1 id=&quot;一、基础&quot;&gt;&lt;a href=&quot;#一、基础&quot; class=&quot;headerlink&quot; title=&quot;一、基础</summary>
      
    
    
    
    
    <category term="springboot" scheme="http://zws6672.top/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>mysql 引擎的行锁与表锁</title>
    <link href="http://zws6672.top/2021/03/30/mysql-lock/"/>
    <id>http://zws6672.top/2021/03/30/mysql-lock/</id>
    <published>2021-03-30T15:47:49.000Z</published>
    <updated>2021-03-30T15:48:50.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务基础"><a href="#事务基础" class="headerlink" title="事务基础"></a>事务基础</h1><ol><li>ACID属性</li></ol><ul><li>原子性：事务不可分</li><li>一致性：在事务开始和完成时，数据都必须保持一致状态。</li><li>隔离性：并发的事务是相互隔离的。</li><li>持久性：事务完成之后，它对于数据的修改是永久性的</li></ul><ol start="2"><li>并发事务的问题</li></ol><ul><li>更新丢失：多事务进行更新，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题最后的更 新覆盖了由其他事务所做的更新</li><li>脏读：事务在提交前，数据的修改可以被其它事务读取</li><li>不可重复读：同一个事务中前后两次读取的数据不一致</li><li>幻读：同一个事务中前后两次读取数据时，其他事务插入了满足其查询条件的新数据，导致读取的数据量不一致</li></ul><ol start="3"><li>事务隔离级别</li></ol><ul><li>未提交读（Read uncommitted）：读数据一致性</li><li>已提交读（Read committed）：不会导致脏读（语句级）</li><li>可重复读（Repeatable read）：不会导致不可重复读（事务级）</li><li>可序列化（Serializable）：不会导致幻读（事务级）</li></ul><h1 id="行锁和表锁"><a href="#行锁和表锁" class="headerlink" title="行锁和表锁"></a>行锁和表锁</h1><p>在mysql 的 InnoDB引擎支持行锁，与Oracle不同，mysql的行锁是通过索引加载的，即是行锁是加在索引响应的行上的。如果SQL语句没有走索引，那么就无法触发行锁，而是会使用表锁。</p><ul><li>表锁：不会出现死锁，发生锁冲突几率高，并发低。</li><li>行锁：会出现死锁，发生锁冲突几率低，并发高。</li></ul><ol><li>锁分类</li></ol><ul><li>共享锁：读锁。当一个事务对某几行上读锁时，允许其他事务对这几行进行读操作，但不允许其进行写操作，也不允许其他事务给这几行上排它锁，但允许上读锁</li><li>排它锁：写锁，当一个事务对某几个上写锁时，不允许其他事务写，但允许读；更不允许其他事务给这几行上任何锁（包括写锁）</li></ul><ol start="2"><li>要点</li></ol><ul><li>行锁必须有索引才能实现，否则会自动锁全表</li><li>两个事务不能锁同一个索引</li><li>语句涉及锁<ul><li>insert、delete、update在事务中都会自动默认加上排它锁</li><li>普通SELECT语句，InnoDB不会加任何锁</li><li>在insert操作时产生插入意向锁（不是意向锁）；在多事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等待</li><li>表级锁还有一种比较特殊的锁：AUTO-INC Locks；这种锁只在向自增主键中插入记录时出现，这种锁是为自增主键设计的。锁机制如下：在向自增主键中插入记录时，其他insert事务都需要等待直到本事务的插入完成才能继续插入自增记录。</li></ul></li><li>索引分为主键索引和非主键索引，如果SQL语句走主键索引MySQL会锁住该索引；如果SQL语句走普通索引，那么会锁住该普通索引，再锁住主键索引</li></ul><ol start="3"><li>遇到的问题</li></ol><ul><li>死锁：如果两事务同时执行，事务A锁住主键索引，等待非主键索引；然后事务B锁住非主键索引，等待主键索引；那么就会陷入死锁。</li><li>锁冲突：锁不相容，如读锁和写锁</li></ul><ol start="4"><li>处理锁冲突（意向锁）</li></ol><p>MySQL 为了解决锁冲突，引入了 意向锁。意向锁就是一种不与行级锁冲突的表级锁，分类如下：</p><ul><li>意向共享锁 （intention shared lock, IS）：事务有意向对表中的某些行加 共享锁（S锁）</li><li>意向排他锁 （intention exclusive lock, IX）：事务有意向对表中的某些行加 排他锁 （X锁）</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 意向共享锁 IS</span><br><span class="line">SELECT column FROM table ... LOCK IN SHARE MODE;</span><br><span class="line">-- 意向排他锁 IX</span><br><span class="line">SELECT column FROM table ... FOR UPDATE;</span><br></pre></td></tr></table></figure><p>意向锁由数据引擎自己维护的，在为数据行加共享/排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</p><p>模拟业务场景如下：</p><ul><li>事务A查询数据，在涉及的行上加共享锁（行锁）之前，会先加意向共享锁（表锁）。</li><li>如果事务B要添加数据，需要加排他锁；<ul><li>如果没有意向锁，那么需要检测每一行，效率低下；</li><li>有了意向锁后，发现有意向锁则表示：有其他事务有意向对表中的某些行加共享锁（S锁）；</li><li>排他锁加锁快速失败。</li></ul></li></ul><ol start="5"><li>表锁的兼容性图</li></ol><p><img src="/image/mysql/lock.png" alt="表锁的兼容性"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><blockquote><p><a href="https://www.linuxidc.com/Linux/2018-04/151914.htm" target="_blank" rel="noopener">MySQL锁机制深入理解</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事务基础&quot;&gt;&lt;a href=&quot;#事务基础&quot; class=&quot;headerlink&quot; title=&quot;事务基础&quot;&gt;&lt;/a&gt;事务基础&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;ACID属性&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;原子性：事务不可分&lt;/li&gt;
&lt;li&gt;一致性：在事务开始和</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://zws6672.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>结构型模式——实例</title>
    <link href="http://zws6672.top/2021/03/29/design-structure-eg/"/>
    <id>http://zws6672.top/2021/03/29/design-structure-eg/</id>
    <published>2021-03-29T06:12:18.000Z</published>
    <updated>2021-03-29T06:13:55.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="适配器模式（兼容）"><a href="#适配器模式（兼容）" class="headerlink" title="适配器模式（兼容）"></a>适配器模式（兼容）</h1><p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作；可以分为类适配器模式以及对象适配器模式。</p><ol><li>类适配器模式</li></ol><p>类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/29 12:50</span><br><span class="line"> * @Description 类适配器</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 适配器类：通过包装一个需要适配的对象，把原接口转换成目标接口。</span><br><span class="line">public class AdapterTest extends Adaptee implements AdapterTarget&#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        AdapterTarget target = new AdapterTest();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request2() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request3() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 目标接口：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类</span><br><span class="line">interface AdapterTarget &#123;</span><br><span class="line">    void request();</span><br><span class="line">    void request2();</span><br><span class="line">    void request3();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 适配者接口：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法</span><br><span class="line">class Adaptee &#123;</span><br><span class="line">    public void adapteeRequest() &#123;</span><br><span class="line">        System.out.println(&quot;适配者接口的业务代码&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>对象适配器模式：对于这种对象的适配器模式，实际上就是通过一个适配器类，把目标类和需要被适配的类进行组合。所以适配器类Adapter一般需要继承或实现Targert，并且还得持有Adaptee的实例引用。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 对象适配器</span><br><span class="line">class ObjectAdapter implements AdapterTarget &#123;</span><br><span class="line">    private Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    public ObjectAdapter(Adaptee adaptee) &#123;</span><br><span class="line">        this.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        adaptee.adapteeRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request2() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request3() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">public class AdapterTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        ObjectAdapter adapter = new ObjectAdapter(new Adaptee());</span><br><span class="line">        adapter.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>为什么使用适配器模式</li></ol><p>假如在旧的接口涉及到其它功能，这时候我们需要增加一个新的参数。如果在旧有的接口做修改，会影响到其它的实现类。所以，我们可以通过定义适配器来扩展接口，实现和老代码的兼容。但是，如果过渡使用适配器模式，会导致代码结构散乱，难以重构。</p><h1 id="代理模式（附加功能与核心功能解耦）"><a href="#代理模式（附加功能与核心功能解耦）" class="headerlink" title="代理模式（附加功能与核心功能解耦）"></a>代理模式（附加功能与核心功能解耦）</h1><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。代理模式通过增加中间层，为其他对象提供一种代理以控制对这个对象的访问，还可以想在访问一个类时做一些控制。代理模式分为:</p><ul><li>静态代理：所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</li><li>动态代理：动态代理是在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象。</li></ul><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/29 13:19</span><br><span class="line"> * @Description 代理模式</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class ProxyTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        ProxyTool tool = new ProxyTool(new RealTool());</span><br><span class="line">        tool.description();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//抽象接口</span><br><span class="line">interface Tool &#123;</span><br><span class="line">    void description();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RealTool implements Tool&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void description() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;这是一个被代理类的描述方法&quot;);</span><br><span class="line">            Thread.sleep((int) (Math.random()*1000));</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProxyTool implements Tool &#123;</span><br><span class="line">    Tool tool;</span><br><span class="line"></span><br><span class="line">    public ProxyTool(Tool tool) &#123;</span><br><span class="line">        this.tool = tool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void description() &#123;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        tool.description();</span><br><span class="line">        System.out.println((System.currentTimeMillis()-startTime) + &quot;毫秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在 RPC、缓存等应用场景中。</p><h1 id="桥接模式（多维度解耦）"><a href="#桥接模式（多维度解耦）" class="headerlink" title="桥接模式（多维度解耦）"></a>桥接模式（多维度解耦）</h1><p>如果一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。</p><p>桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。桥接模式将继承关系转化成关联关系，它降低了类与类之间的耦合度，减少了系统中类的数量，也减少了代码量。</p><ul><li>抽象化：其概念是将复杂物体的一个或几个特性抽出去而只注意其他特性的行动或过程。在面向对象就是将对象共同的性质抽取出去而形成类的过程。</li><li>实现化：针对抽象化给出的具体实现。它和抽象化是一个互逆的过程，实现化是对抽象化事物的进一步具体化。</li><li>脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。</li></ul><p>桥接模式主要包含如下几个角色：</p><ul><li>Abstraction：抽象类</li><li>RefinedAbstraction：扩充抽象类</li><li>Implementor：实现类接口</li><li>ConcreteImplementor：具体实现类</li></ul><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/29 13:33</span><br><span class="line"> * @Description 桥接模式</span><br><span class="line"> */</span><br><span class="line">public class BridgeTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        Shape shape = new Circle();</span><br><span class="line">        Color color = new White();</span><br><span class="line">        shape.setColor(color);</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 抽象类</span><br><span class="line">abstract class Shape &#123;</span><br><span class="line">    Color color;</span><br><span class="line"></span><br><span class="line">    public void setColor(Color color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void draw();</span><br><span class="line">&#125;</span><br><span class="line">// 扩充抽象类</span><br><span class="line">class Circle extends Shape&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        color.bepaint(&quot;正方形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现类接口</span><br><span class="line">interface Color &#123;</span><br><span class="line">    public void bepaint(String shape);</span><br><span class="line">&#125;</span><br><span class="line">// 具体实现类</span><br><span class="line">class White implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void bepaint(String shape) &#123;</span><br><span class="line">        System.out.println(&quot;白色的&quot; + shape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="装饰模式（扩展）"><a href="#装饰模式（扩展）" class="headerlink" title="装饰模式（扩展）"></a>装饰模式（扩展）</h1><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。装饰器模式是为了动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/29 13:40</span><br><span class="line"> * @Description 装饰器模式</span><br><span class="line"> */</span><br><span class="line">public class DecoratorTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        Bird bird = new Eagle();</span><br><span class="line">        BirdDecorator decorator = new WhiteBirdDecorator(bird);</span><br><span class="line">        decorator.des();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象</span><br><span class="line">interface Bird &#123;</span><br><span class="line">    void des();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体构件（Concrete Component）角色：定义一个将要接收附加责任的类</span><br><span class="line">class Eagle implements Bird &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void des() &#123;</span><br><span class="line">        System.out.println(&quot;小型至中型的白昼活动的鹰形类鸟&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口</span><br><span class="line">abstract class BirdDecorator implements Bird &#123;</span><br><span class="line">    public Bird bird;</span><br><span class="line"></span><br><span class="line">    public BirdDecorator(Bird bird) &#123;</span><br><span class="line">        this.bird = bird;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void des() &#123;</span><br><span class="line">        bird.des();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任</span><br><span class="line">class WhiteBirdDecorator extends  BirdDecorator &#123;</span><br><span class="line">    public WhiteBirdDecorator(Bird bird) &#123;</span><br><span class="line">        super(bird);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void des() &#123;</span><br><span class="line">        bird.des();</span><br><span class="line">        extend();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void extend() &#123;</span><br><span class="line">        System.out.println(&quot;白色的鸟&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="外观模式（同一接口）"><a href="#外观模式（同一接口）" class="headerlink" title="外观模式（同一接口）"></a>外观模式（同一接口）</h1><p>外观模式提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。</p><p>外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点：</p><ul><li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li><li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li></ul><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/29 13:57</span><br><span class="line"> * @Description 外观模式</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class FacadeTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        Facade facade = new Facade();</span><br><span class="line">        facade.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//外观角色</span><br><span class="line">class Facade &#123;</span><br><span class="line">    private SubSystem01 obj1 = new SubSystem01();</span><br><span class="line">    private SubSystem02 obj2 = new SubSystem02();</span><br><span class="line">    private SubSystem03 obj3 = new SubSystem03();</span><br><span class="line"></span><br><span class="line">    public void method() &#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem01 &#123;</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;子系统01的method1()被调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem02 &#123;</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;子系统02的method2()被调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem03 &#123;</span><br><span class="line">    public void method3() &#123;</span><br><span class="line">        System.out.println(&quot;子系统03的method3()被调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="享元模式（对象共享）"><a href="#享元模式（对象共享）" class="headerlink" title="享元模式（对象共享）"></a>享元模式（对象共享）</h1><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p><p>模式所涉及的角色：</p><ul><li>Flyweight： 享元接口，通过这个接口传入外部状态并作用于外部状态；</li><li>ConcreteFlyweight： 具体的享元实现对象，必须是可共享的，需要封装享元对象的内部状态；</li><li>UnsharedConcreteFlyweight： 非共享的享元实现对象，并不是所有的享元对象都可以共享，非共享的享元对象通常是享元对象的组合对象；</li><li>FlyweightFactory： 享元工厂，主要用来创建并管理共享的享元对象，并对外提供访问共享享元的接口；</li></ul><p>享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</p><p>享元对象能做到共享的关键是区分两个状态：<br>内部状态(Internal State)：存储在享元对象内部并且不会随环境改变而改变的状态<br>外部状态(External State)：随环境改变而改变的、不可以共享的状态</p><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">// 接口</span><br><span class="line">public interface Shape &#123;</span><br><span class="line">   void draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建实现接口的实体类</span><br><span class="line">public class Circle implements Shape &#123;</span><br><span class="line">   private String color;</span><br><span class="line">   private int x;</span><br><span class="line">   private int y;</span><br><span class="line">   private int radius;</span><br><span class="line"> </span><br><span class="line">   public Circle(String color)&#123;</span><br><span class="line">      this.color = color;     </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setX(int x) &#123;</span><br><span class="line">      this.x = x;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setY(int y) &#123;</span><br><span class="line">      this.y = y;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setRadius(int radius) &#123;</span><br><span class="line">      this.radius = radius;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Circle: Draw() [Color : &quot; + color </span><br><span class="line">         +&quot;, x : &quot; + x +&quot;, y :&quot; + y +&quot;, radius :&quot; + radius);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 享元工厂</span><br><span class="line"></span><br><span class="line">public class ShapeFactory &#123;</span><br><span class="line">   private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">   public static Shape getCircle(String color) &#123;</span><br><span class="line">      Circle circle = (Circle)circleMap.get(color);</span><br><span class="line"> </span><br><span class="line">      if(circle == null) &#123;</span><br><span class="line">         circle = new Circle(color);</span><br><span class="line">         circleMap.put(color, circle);</span><br><span class="line">         System.out.println(&quot;Creating circle of color : &quot; + color);</span><br><span class="line">      &#125;</span><br><span class="line">      return circle;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FlyweightPatternDemo &#123;</span><br><span class="line">   private static final String colors[] = </span><br><span class="line">      &#123; &quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;White&quot;, &quot;Black&quot; &#125;;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">      for(int i=0; i &lt; 20; ++i) &#123;</span><br><span class="line">         Circle circle = </span><br><span class="line">            (Circle)ShapeFactory.getCircle(getRandomColor());</span><br><span class="line">         circle.setX(getRandomX());</span><br><span class="line">         circle.setY(getRandomY());</span><br><span class="line">         circle.setRadius(100);</span><br><span class="line">         circle.draw();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   private static String getRandomColor() &#123;</span><br><span class="line">      return colors[(int)(Math.random()*colors.length)];</span><br><span class="line">   &#125;</span><br><span class="line">   private static int getRandomX() &#123;</span><br><span class="line">      return (int)(Math.random()*100 );</span><br><span class="line">   &#125;</span><br><span class="line">   private static int getRandomY() &#123;</span><br><span class="line">      return (int)(Math.random()*100);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合模式（部分-整体）"><a href="#组合模式（部分-整体）" class="headerlink" title="组合模式（部分-整体）"></a>组合模式（部分-整体）</h1><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">   private String name;</span><br><span class="line">   private String dept;</span><br><span class="line">   private int salary;</span><br><span class="line">   private List&lt;Employee&gt; subordinates;</span><br><span class="line"> </span><br><span class="line">   //构造函数</span><br><span class="line">   public Employee(String name,String dept, int sal) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">      this.dept = dept;</span><br><span class="line">      this.salary = sal;</span><br><span class="line">      subordinates = new ArrayList&lt;Employee&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void add(Employee e) &#123;</span><br><span class="line">      subordinates.add(e);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void remove(Employee e) &#123;</span><br><span class="line">      subordinates.remove(e);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public List&lt;Employee&gt; getSubordinates()&#123;</span><br><span class="line">     return subordinates;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String toString()&#123;</span><br><span class="line">      return (&quot;Employee :[ Name : &quot;+ name </span><br><span class="line">      +&quot;, dept : &quot;+ dept + &quot;, salary :&quot;</span><br><span class="line">      + salary+&quot; ]&quot;);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CompositePatternDemo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Employee CEO = new Employee(&quot;John&quot;,&quot;CEO&quot;, 30000);</span><br><span class="line"> </span><br><span class="line">      Employee headSales = new Employee(&quot;Robert&quot;,&quot;Head Sales&quot;, 20000);</span><br><span class="line"> </span><br><span class="line">      Employee headMarketing = new Employee(&quot;Michel&quot;,&quot;Head Marketing&quot;, 20000);</span><br><span class="line"> </span><br><span class="line">      Employee clerk1 = new Employee(&quot;Laura&quot;,&quot;Marketing&quot;, 10000);</span><br><span class="line">      Employee clerk2 = new Employee(&quot;Bob&quot;,&quot;Marketing&quot;, 10000);</span><br><span class="line"> </span><br><span class="line">      Employee salesExecutive1 = new Employee(&quot;Richard&quot;,&quot;Sales&quot;, 10000);</span><br><span class="line">      Employee salesExecutive2 = new Employee(&quot;Rob&quot;,&quot;Sales&quot;, 10000);</span><br><span class="line"> </span><br><span class="line">      CEO.add(headSales);</span><br><span class="line">      CEO.add(headMarketing);</span><br><span class="line"> </span><br><span class="line">      headSales.add(salesExecutive1);</span><br><span class="line">      headSales.add(salesExecutive2);</span><br><span class="line"> </span><br><span class="line">      headMarketing.add(clerk1);</span><br><span class="line">      headMarketing.add(clerk2);</span><br><span class="line"> </span><br><span class="line">      //打印该组织的所有员工</span><br><span class="line">      System.out.println(CEO); </span><br><span class="line">      for (Employee headEmployee : CEO.getSubordinates()) &#123;</span><br><span class="line">         System.out.println(headEmployee);</span><br><span class="line">         for (Employee employee : headEmployee.getSubordinates()) &#123;</span><br><span class="line">            System.out.println(employee);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;        </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;适配器模式（兼容）&quot;&gt;&lt;a href=&quot;#适配器模式（兼容）&quot; class=&quot;headerlink&quot; title=&quot;适配器模式（兼容）&quot;&gt;&lt;/a&gt;适配器模式（兼容）&lt;/h1&gt;&lt;p&gt;适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://zws6672.top/tags/设计模式/"/>
    
  </entry>
  
  <entry>
    <title>JDK8 语言新特性</title>
    <link href="http://zws6672.top/2021/03/29/jdk8/"/>
    <id>http://zws6672.top/2021/03/29/jdk8/</id>
    <published>2021-03-29T04:41:58.000Z</published>
    <updated>2021-03-29T04:43:05.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口新增默认方法与静态方法"><a href="#接口新增默认方法与静态方法" class="headerlink" title="接口新增默认方法与静态方法"></a>接口新增默认方法与静态方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/24 19:01</span><br><span class="line"> * @Description 接口新增默认方法与静态方法</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public interface Interface1 &#123;</span><br><span class="line">    void method1();</span><br><span class="line">    default void test() &#123;</span><br><span class="line">        System.out.println(&quot;接口的默认方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static void test2() &#123;</span><br><span class="line">        System.out.println(&quot;接口的静态方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用-FunctionalInterface限制函数接口的转换"><a href="#使用-FunctionalInterface限制函数接口的转换" class="headerlink" title="使用@FunctionalInterface限制函数接口的转换"></a>使用@FunctionalInterface限制函数接口的转换</h1><ul><li>函数式接口仅仅只有一个方法(非默认或静态方法)，用于显示转换成ladbma表达式。</li><li>java.lang.Runnable接口、java.util.concurrent.Callable接口是两个最典型的函数式接口。</li><li>如果一个函数式接口添加一个普通方法，就变成了非函数式接口（一般定义的接口）。</li><li>Jdk8 规范里添加了注解@FunctionalInterface来限制函数式接口不能修改为普通的接口.</li></ul><blockquote><p>注：函数形接口 、供给形接口、消费型接口、判断型接口</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/24 19:03</span><br><span class="line"> * @Description 使用@FunctionalInterface限制接口只能有一个方法</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Functional1 &#123;</span><br><span class="line">    void test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lambda表达式-与-stream-流"><a href="#Lambda表达式-与-stream-流" class="headerlink" title="Lambda表达式 与 stream 流"></a>Lambda表达式 与 stream 流</h1><p>Lambda表达式（基于函数的匿名表达式）,相关语法如下：<br><code>( object str,....)[参数列表]   -&gt;[箭头符号]     代码块或表达式</code></p><p>Stream是元素的集合，可以支持顺序和并行的对原Stream进行汇聚的操作。创建stream：</p><ul><li>通过Stream接口的静态工厂方法</li><li>通过Collection接口的默认方法 stream()，把一个Collection对象转换成Stream</li></ul><p>stream相关的几个方法：</p><ul><li>转换<ul><li>distinct：去重</li><li>filter：对于Stream中包含的元素使用给定的过滤函数进行过滤操作</li><li>map：对于Stream中包含的元素使用给定的转换函数进行转换操作，支持类型转换（mapToInt，mapToLong和mapToDouble）</li><li>peek：生成一个包含原Stream的所有元素的新Stream，同时会提供一个消费函数（Consumer实例），新Stream每个元素被消费的时候都会执行给定的消费函数</li><li>limit: 对一个Stream进行截断操作，获取其前N个元素，如果原Stream中包含的元素个数小于N，那就获取其所有的元素</li><li>skip: 返回一个丢弃原Stream的前N个元素后剩下元素组成的新Stream，如果原Stream中包含的元素个数小于N，那么返回空Stream</li><li>sorted：排序</li><li>forEach：遍历</li></ul></li><li>汇聚（Reduce）Stream<ul><li>count：统计个数</li><li>concat：组合多个流</li><li>collect：流中多个元素合并为一个元素<br>相关实例如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">//        1. Lambda 表达式实现Runnable</span><br><span class="line">        new Thread(()-&gt;System.out.println(&quot;1. Lambda 表达式实现Runnable，相关的内部类都可以这么写&quot;)).start();</span><br><span class="line">//        2. Lambda 表达式迭代list</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;2. Lambda 表达式迭代list&quot;);</span><br><span class="line">        List list = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;f&quot;);</span><br><span class="line">        list.forEach(n-&gt;System.out.println(n));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//        3. Lambda 表达式map</span><br><span class="line">        System.out.println(&quot;3. Lambda 表达式map&quot;);</span><br><span class="line">        List&lt;Integer&gt; list2 = Arrays.asList(11,52,7,9,40);</span><br><span class="line">        list2.stream().map((num)-&gt; num*2).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">//        4. Lambda 表达式过滤数据</span><br><span class="line">        System.out.println(&quot;4. Lambda 表达式过滤数据 输出三个字节以下的数据&quot;);</span><br><span class="line">        List&lt;String&gt; list3 = Arrays.asList(&quot;ad&quot;,&quot;bsdfd&quot;,&quot;cdf&quot;,&quot;ddfd&quot;,&quot;fs&quot;);</span><br><span class="line">        list3.stream().filter(str-&gt;str.length()&lt;3).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">//        5. Lambda 表达式连接字符</span><br><span class="line">        System.out.println(&quot;5. Lambda 表达式连接字符&quot;);</span><br><span class="line">        List&lt;String&gt; list4 = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;);</span><br><span class="line">        String res = list4.stream().map((cr)-&gt;cr.toUpperCase()).collect(Collectors.joining(&quot;-&quot;));</span><br><span class="line">        System.out.println(res);</span><br><span class="line">//        6. Lambda 表达式计算集合元素</span><br><span class="line">        System.out.println(&quot;计算集合元素的最大值、最小值、总和以及平均值&quot;);</span><br><span class="line">        List&lt;Integer&gt; primes = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);</span><br><span class="line">        IntSummaryStatistics stats = primes.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">        System.out.println(&quot;Highest prime number in List : &quot; + stats.getMax());</span><br><span class="line">        System.out.println(&quot;Lowest prime number in List : &quot; + stats.getMin());</span><br><span class="line">        System.out.println(&quot;Sum of all prime numbers : &quot; + stats.getSum());</span><br><span class="line">        System.out.println(&quot;Average of all prime numbers : &quot; + stats.getAverage());</span><br><span class="line"></span><br><span class="line">//        7. Lambda 表达式去重</span><br><span class="line">        System.out.println(&quot;7. Lambda 表达式去重&quot;);</span><br><span class="line">        List&lt;Integer&gt; list5 = Arrays.asList(2, 2, 5, null, 11, 11, 17, 19, 17, 2);</span><br><span class="line">//        filter(x-&gt;x!=null 避免为null的情况</span><br><span class="line">//        distinct() 去重</span><br><span class="line">        list5.stream().filter(x-&gt;x!=null).distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">//        8. Lambda 表达式排序</span><br><span class="line">        System.out.println(&quot;8. Lambda 表达式排序&quot;);</span><br><span class="line">        List&lt;Integer&gt; list6 = Arrays.asList(29, 2, 5, null, 11, 11, 17, 19, 17, 2);</span><br><span class="line">        list6.stream().filter(x-&gt;x!=null).sorted((a,b)-&gt;a-b).distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="新增方法引用"><a href="#新增方法引用" class="headerlink" title="新增方法引用"></a>新增方法引用</h1><p>方法引用是只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(str -&gt; System.out.print(str));</span><br><span class="line">list.forEach(System.out::print);//等价</span><br></pre></td></tr></table></figure><ul><li>分类<ul><li>构造器引用<ul><li>格式：<code>Class::new</code>，调用默认构造器</li></ul></li><li>静态方法引用<ul><li>格式：<code>Class::static_method</code></li></ul></li><li>类(任意对象)的方法引用（在流中会调用每个类）<ul><li>格式：<code>Class::method</code>，方法不能带参数</li></ul></li><li>实例对象的方法引用<ul><li>格式：<code>instance::method</code></li></ul></li></ul></li></ul><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/24 20:26</span><br><span class="line"> * @Description 方法引用</span><br><span class="line"> */</span><br><span class="line">public class MethodUseTest &#123;</span><br><span class="line">    public MethodUseTest() &#123;</span><br><span class="line">        System.out.println(&quot;默认构造器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String test() &#123;</span><br><span class="line">        System.out.println(&quot;静态方法&quot;);</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    void instance() &#123;</span><br><span class="line">        System.out.println(&quot;实例方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        List&lt;MethodUseTest&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">//        1.构造器引用 需要使用 Supplier(创建对象的工厂)</span><br><span class="line">        Supplier&lt;MethodUseTest&gt; mut = MethodUseTest::new;</span><br><span class="line">        Supplier&lt;MethodUseTest&gt; mut2 = MethodUseTest::new;</span><br><span class="line">//        2.静态方法引用。如果函数式接口的实现恰好是通过调用一个静态方法来实现，那么就可以使用静态方法引用</span><br><span class="line">        Supplier&lt;String&gt; test = MethodUseTest::test;</span><br><span class="line"></span><br><span class="line">        list.add(mut.get());</span><br><span class="line">        list.add(mut2.get());</span><br><span class="line">//        3.普通方法引用，方法不能带参数。</span><br><span class="line">        list.forEach(MethodUseTest::instance);</span><br><span class="line">//        4.实例对象的方法引用 需要以流元素作为参数</span><br><span class="line">        MethodUseTest mut3 = new MethodUseTest();</span><br><span class="line">        list.forEach(mut3::instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void instance(MethodUseTest methodUseTest) &#123;</span><br><span class="line">        methodUseTest.instance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><ol><li><p>重复注解<br>Java 5引入了注解机制，这一特性就变得非常流行并且广为使用，但是相同的注解在同一地方只能使用一次。Java 8引入了重复注解机制，使相同的注解可以在同一地方声明多次，重复注解机制本身必须用@Repeatable注解。</p></li><li><p>扩展注解的支持<br>JDK8 扩展了注解的上下文。现在几乎可以为任何东西添加注解：局部变量、泛型类、父类与接口的实现，就连方法的异常也能添加注解。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;接口新增默认方法与静态方法&quot;&gt;&lt;a href=&quot;#接口新增默认方法与静态方法&quot; class=&quot;headerlink&quot; title=&quot;接口新增默认方法与静态方法&quot;&gt;&lt;/a&gt;接口新增默认方法与静态方法&lt;/h1&gt;&lt;figure class=&quot;highlight plai</summary>
      
    
    
    
    
    <category term="java" scheme="http://zws6672.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>创建型模式——实例</title>
    <link href="http://zws6672.top/2021/03/29/design-creator-eg/"/>
    <id>http://zws6672.top/2021/03/29/design-creator-eg/</id>
    <published>2021-03-29T04:37:09.000Z</published>
    <updated>2021-03-29T06:14:15.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ol><li>懒汉式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized static Singleton getInstance() &#123;</span><br><span class="line">//       懒汉式 需要时再初始化</span><br><span class="line">         if (instance == null) &#123;</span><br><span class="line">             instance = new Singleton();</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             System.out.println(&quot;实例对象已创建&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>饿汉式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized static Singleton getInstance() &#123;</span><br><span class="line">//        饿汉式 定义时初始化</span><br><span class="line">return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DCL（即Double Check Lock，双重检查锁定）</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton instance;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>静态内部类</li></ol><p>第一次加载Singleton类时不会初始化instance，只有在第一次调用getInstance()方法时，虚拟机会加载SingletonHolder类，初始化instance。保证线程安全，单例对象的唯一，也延迟了单例的初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static Singleton instance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>枚举单例</li></ol><p>默认枚举实例的创建是线程安全的，即使反序列化也不会生成新的实例，任何情况下都是一个单例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;do something&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>用原型实例可以指定创建对象的种类，并通过拷贝这些原型创建新的对象。</p><p><a href="/image/degin-pattern/proto_use.png">原型模式</a></p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/27 14:59</span><br><span class="line"> * @Description 原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷 贝这些原型，创建新的对象 。</span><br><span class="line"> *  原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象， 无需知道如何创建的细节 。通过将一个原型对象传给那个要发动创建的对象，这个要发动创建 的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()。</span><br><span class="line"> */</span><br><span class="line">public class Prototype implements Cloneable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Date date;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDate(Date date) &#123;</span><br><span class="line">        this.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main (String[] args) throws CloneNotSupportedException, InterruptedException &#123;</span><br><span class="line">        Prototype prototype = new Prototype(&quot;test&quot;, new Date());</span><br><span class="line">        Prototype clone = prototype.clone();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        prototype.setDate(new Date());</span><br><span class="line">        prototype.setName(&quot;result&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(prototype.name+&quot;:&quot;+prototype.date);</span><br><span class="line">        System.out.println(clone.name+&quot;:&quot;+clone.date);</span><br><span class="line">    &#125;</span><br><span class="line">    public Prototype() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Prototype(String name, Date date) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Prototype clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Prototype prototype = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            prototype = (Prototype) super.clone();</span><br><span class="line">//            如果属性包含，自定义类需要实现clone方法，才能实现深拷贝，否则会指向同一块内存空间</span><br><span class="line">//            prototype.test = (Test) test.clone();</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line">            return prototype;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型模式需要注意的几点：</p><ul><li>克隆对象不会调用构造方法</li><li>访问权限对原型模式无效</li><li>当我们的类初始化需要消耗很多的资源时，就可以使用原型模式，因为我们的克隆不会执行构造方法，避免了初始化占有的时间和空间</li><li>一个对象被其她对象访问，并且能够修改时，访问权限都无效了，什么都能修改</li></ul><h1 id="建造者模式（创建与使用分离）"><a href="#建造者模式（创建与使用分离）" class="headerlink" title="建造者模式（创建与使用分离）"></a>建造者模式（创建与使用分离）</h1><p>建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。用户只需要给出指定复杂对象的类型和内容 建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)。</p><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/27 15:22</span><br><span class="line"> * @Description 建造者模式</span><br><span class="line"> */</span><br><span class="line">public class Builder &#123;</span><br><span class="line">    public static void main (String[] args) throws Exception &#123;</span><br><span class="line">        User user = User.builder().userName(&quot;test&quot;).id(1).address(&quot;bj&quot;).password(&quot;111&quot;).build();</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Integer id;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private String address;</span><br><span class="line">//    private String status;</span><br><span class="line">//    private String role;</span><br><span class="line">//    private String realname;</span><br><span class="line">//    private Date register_time;</span><br><span class="line">//    private String register_ip;</span><br><span class="line">//    private Date login_time;</span><br><span class="line">//    private String login_ip;</span><br><span class="line"></span><br><span class="line">    private User(Integer id, String username, String password, String address) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    public static UserBuilder builder() &#123;</span><br><span class="line">        return new UserBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">    static class UserBuilder &#123;</span><br><span class="line">        private Integer id;</span><br><span class="line">        private String username;</span><br><span class="line">        private String password;</span><br><span class="line">        private String address;</span><br><span class="line"></span><br><span class="line">        private UserBuilder() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public UserBuilder id(Integer id) &#123;</span><br><span class="line">            this.id = id;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public UserBuilder userName(String username) &#123;</span><br><span class="line">            this.username = username;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public UserBuilder password(String password) &#123;</span><br><span class="line">            this.password = password;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public UserBuilder address(String address) &#123;</span><br><span class="line">            this.address = address;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        public User build() throws Exception &#123;</span><br><span class="line">            if (username==null||password==null) &#123;</span><br><span class="line">                throw new Exception(&quot;用户名或密码不可为空&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return new User(id, username, password, address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式可以分为</p><ul><li>类模式，即工厂方法模式；</li><li>对象模式，即抽象工厂模式。</li></ul><p>工厂方法模式实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/23 18:07</span><br><span class="line"> * @Description 工厂方法 一个抽象工厂 多个实际工厂，一个抽象产品 多个实际产品，一个实际工厂对应一个实际产品</span><br><span class="line"> */</span><br><span class="line">public class FactoryMethod &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        AbstractFactory factory = new ConcreteFactory1();</span><br><span class="line">        factory.newProduct().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//抽象产品 产品规范</span><br><span class="line">interface Product &#123;</span><br><span class="line">    void show();</span><br><span class="line">&#125;</span><br><span class="line">//具体产品 产品细节</span><br><span class="line">class ConcreteProduct1 implements Product &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;实际产品1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ConcreteProduct2 implements Product &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;实际产品2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象工厂 创建产品的接口</span><br><span class="line">abstract class AbstractFactory &#123;</span><br><span class="line">    abstract Product newProduct();</span><br><span class="line">&#125;</span><br><span class="line">//具体工厂 创建产品</span><br><span class="line">class ConcreteFactory1 extends AbstractFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Product newProduct() &#123;</span><br><span class="line">        System.out.println(&quot;实际工厂1--&gt;&quot;);</span><br><span class="line">        return new ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConcreteFactory2 extends AbstractFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    Product newProduct() &#123;</span><br><span class="line">        System.out.println(&quot;实际工厂2--&gt;&quot;);</span><br><span class="line">        return new ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂模式实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/23 18:19</span><br><span class="line"> * @Description 抽象工厂模式：在工厂方法中，只考虑同种等级的产品；但是，在实际应用中，多产品才是主流。而 抽象工厂模式则考虑多等级产品的生产。</span><br><span class="line"> */</span><br><span class="line">public class AbstractFactoryMethod &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        AbstractFactory2 factory = new MyFactory1();</span><br><span class="line">        factory.newProduct1().show();</span><br><span class="line">        factory.newProduct2().show();</span><br><span class="line">        AbstractFactory2 factory2 = new MyFactory2();</span><br><span class="line">        factory2.newProduct1().show();</span><br><span class="line">        factory2.newProduct2().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//抽象工厂 创建产品的接口</span><br><span class="line">abstract class AbstractFactory2 &#123;</span><br><span class="line">    abstract Product2 newProduct1();</span><br><span class="line">    abstract Product2 newProduct2();</span><br><span class="line">&#125;</span><br><span class="line">interface Product2 &#123;</span><br><span class="line">    void show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Product211 implements Product2 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;实际产品1-1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Product212 implements Product2 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;实际产品1-2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Product221 implements Product2 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;实际产品2-1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Product222 implements Product2 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;实际产品2-2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyFactory1 extends AbstractFactory2 &#123;</span><br><span class="line">    public MyFactory1() &#123;</span><br><span class="line">        System.out.println(&quot;实际工厂1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Product2 newProduct1() &#123;</span><br><span class="line">        return new Product211();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Product2 newProduct2() &#123;</span><br><span class="line">        return new Product212();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyFactory2 extends AbstractFactory2 &#123;</span><br><span class="line">    public MyFactory2() &#123;</span><br><span class="line">        System.out.println(&quot;实际工厂2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    Product2 newProduct1() &#123;</span><br><span class="line">        return new Product221();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Product2 newProduct2() &#123;</span><br><span class="line">        return new Product222();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;懒汉式&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://zws6672.top/tags/设计模式/"/>
    
  </entry>
  
  <entry>
    <title>Netty————零拷贝</title>
    <link href="http://zws6672.top/2021/03/29/netty-zero-copy/"/>
    <id>http://zws6672.top/2021/03/29/netty-zero-copy/</id>
    <published>2021-03-29T04:18:39.000Z</published>
    <updated>2021-03-29T04:35:57.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是零拷贝-zero-copy"><a href="#什么是零拷贝-zero-copy" class="headerlink" title="什么是零拷贝(zero-copy)"></a>什么是零拷贝(zero-copy)</h1><p>零拷贝指的是没有CPU拷贝，而不是没有拷贝时间。操作系统可以分为用户态和内核态，在内核态缓冲区之间，没有数据是重复的。零拷贝意味着更少的数据复制、更少的上下文切换、CPU缓存伪共享以及无CPU检验和计算。零拷贝是网络编程的核心，很多性能优化都离不开。</p><p>文件复制可以分为两个流程，一部分是文件的读，另外一部分是文件的写。在传统的IO文件操作时，假如我们要读取文件，有以下几个流程：</p><ul><li>调用操作系统提供的底层标准IO系统调用函数read()，进行一次上下文切换（用户态—&gt;内核态）；</li><li>OS的内核代码将相应的文件数据读取到内核的IO 缓冲区，是一次DMA Copy（内核从磁盘上面读取数据 是 不消耗CPU时间的，是通过磁盘控制器完成）</li><li>数据再由内核的IO 缓冲区拷贝到进程的私有空间中，是一次CPU Copy</li><li>read调用返回后，会再进行一次上下文切换（内核态—&gt;用户态）</li></ul><p>假如我们要写入文件，有以下几个流程：</p><ul><li>应用发起写操作，OS进行一次上下文切换（从用户空间切换为内核空间）</li><li>数据copy到内核缓冲区Socket Buffer，做了一次CPU Copy</li><li>内核空间再把数据copy到磁盘或其他存储（网卡，进行网络传输），进行了DMA Copy</li><li>写入结束后返回，又从内核空间切换到用户空间</li></ul><p>综上，传统的复制操作会发生四次上下文切换、两次DMA复制、两次CPU复制。为此，零拷贝提供了mmap+write方式、sendfile方式提高复制效率。</p><h1 id="拷贝优化的演化"><a href="#拷贝优化的演化" class="headerlink" title="拷贝优化的演化"></a>拷贝优化的演化</h1><ol><li><p>mmap+write方式<br>mmap+write方式是使用虚拟内存的特性，将内核空间和用户空间的虚拟地址映射到同一个物理地址，这样就不需要来回复制了。读取时把数据存放到内核缓冲区而不必应用程序缓冲区，写入数据的时候直接从内核缓冲区读取到内核缓冲区即可，这需要花费一次CPU Copy。这个方式将花费四次上下文切换、两次DMA复制、一次CPU复制。</p></li><li><p>sendfile方式<br>sendfile方式这种方式可以替换上面的mmap+write方式，它少了一个应用程序发起write操作，直接发起sendfile操作。这个方式将花费两次上下文切换、两次DMA复制、一次CPU复制。</p></li><li><p>gather操作（零拷贝基础）<br>而Linux2.4内核进行了优化，提供了gather操作。这个操作在内核空间Read Buffer和Socket Buffer不做数据复制，而是将Read Buffer的内存地址、偏移量记录到相应的Socket Buffer中，这样就不需要复制。这个方式将花费两次上下文切换、两次DMA复制。</p></li></ol><p>JAVA零拷贝 java nio实现零拷贝，JAVA提供了一下方法类：</p><ul><li>MappedByteBuffer mmap+write方式</li><li>DirectByteBuffer 堆外内存</li><li>FileChannel.transferTo</li></ul><p>Linux提供的零拷贝技术 Java并不是全支持，支持2种(内存映射mmap、sendfile)：</p><ul><li><p>NIO提供的内存映射 MappedByteBuffer，底层就是调用Linux mmap()实现的。</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MappedByteBuffer mappedByteBuffer = new RandomAccessFile(file, &quot;r&quot;) </span><br><span class="line">                                .getChannel() </span><br><span class="line">                               .map(FileChannel.MapMode.READ_ONLY, 0, len);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>NIO提供的sendfile</p><ul><li>FileChannel.transferTo()方法直接将当前通道内容传输到另一个通道，没有涉及到Buffer的任何操作，NIO中 的Buffer是JVM堆或者堆外内存，但不论如何他们都是操作系统内核空间的内存</li><li>transferTo()的实现方式就是通过系统调用sendfile() (当然这是Linux中的系统调用)</li></ul></li></ul><h1 id="Netty的零拷贝"><a href="#Netty的零拷贝" class="headerlink" title="Netty的零拷贝"></a>Netty的零拷贝</h1><p>Netty中的Zero-copy与上面我们所提到到OS层面上的Zero-copy不太一样, Netty的Zero-copy完全是在用户态(Java层面)的，它的Zero-copy的更多的是偏向于优化数据操作这样的概念。</p><ul><li><p>应用层数据优化的零拷贝</p><ul><li><p>Netty提供了CompositeByteBuf类，它可以将多个ByteBuf合并为一个逻辑上的ByteBuf，避免了各个ByteBuf之间的拷贝。</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ByteBuf合并操作</span><br><span class="line">resultBuf.writeBytes(header);</span><br><span class="line">resultBuf.writeBytes(body);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ByteBuf 支持slice 操作，因此可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf，避免了内存的拷贝。</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ByteBuf分散操作</span><br><span class="line">ByteBuf header = byteBuf.slice(0,5);</span><br><span class="line">ByteBuf body = byteBuf.slice(5,10);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过wrap操作，我们可以将byte[]数组、ByteBuf、 ByteBuffer 等包装成一个 Netty ByteBuf对象，进而避免了拷贝操作。</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// byte[]--&gt; ByteBuf</span><br><span class="line">byte[] bytes;</span><br><span class="line">ByteBuf byteBuf = Unpooled.buffer();</span><br><span class="line">byteBuf.writeBytes(bytes);</span><br><span class="line">Unpooled.wrappedBuffer(bytes);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>操作系统级别的零拷贝</p><ul><li>通过FileRegion包装的FileChannel.tranferTo实现文件传输，可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。（底层依赖 Java NIO FileChannel.transferTo）</li></ul></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote><p><a href="https://juejin.cn/post/6844903984965091336" target="_blank" rel="noopener">零拷贝(zero-copy)</a><br><a href="https://blog.csdn.net/akunshouyoudou/article/details/104637539" target="_blank" rel="noopener">Java中的零拷贝</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是零拷贝-zero-copy&quot;&gt;&lt;a href=&quot;#什么是零拷贝-zero-copy&quot; class=&quot;headerlink&quot; title=&quot;什么是零拷贝(zero-copy)&quot;&gt;&lt;/a&gt;什么是零拷贝(zero-copy)&lt;/h1&gt;&lt;p&gt;零拷贝指的是没有CPU拷</summary>
      
    
    
    
    
    <category term="Netty" scheme="http://zws6672.top/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty（二）入门</title>
    <link href="http://zws6672.top/2021/03/21/netty-2-what/"/>
    <id>http://zws6672.top/2021/03/21/netty-2-what/</id>
    <published>2021-03-21T05:02:35.000Z</published>
    <updated>2021-03-21T06:49:58.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p>Netty是由JBOSS提供的一个java开源框架，现为 Github上的独立项目。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。</p><p>也就是说，Netty 是一个基于NIO的客户、服务器端的编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户、服务端应用。Netty相当于简化和流线化了网络应用的编程开发过程，例如：基于TCP和UDP的socket服务开发。</p><p>Netty和Tomcat的区别：Netty和Tomcat最大的区别就在于通信协议，Tomcat是基于Http协议的，他的实质是一个基于http协议的web容器，但是Netty不一样，他能通过编程自定义各种协议，因为netty能够通过codec自己来编码/解码字节流，完成类似redis访问的功能，这就是netty和tomcat最大的不同。</p><p>Netty的优点</p><ul><li>并发高：底层使用了NIO的网络I/O模型，该模型是非阻塞的，阻塞业务处理但不阻塞数据接收</li><li>传输快：依赖于零拷贝特性。当需要接收数据的时候，他会在堆内存之外开辟一块内存，数据就直接从IO读到了那块内存中去，在netty里面通过ByteBuf可以直接对这些数据进行直接操作，从而加快了传输速度。</li><li>封装好</li></ul><h3 id="Netty的线程模型"><a href="#Netty的线程模型" class="headerlink" title="Netty的线程模型"></a>Netty的线程模型</h3><ol><li>目前存在的线程模型</li></ol><ul><li>传统阻塞IO模型：采用阻塞式IO，每个连接都需要独立的线程进行处理；该模型的缺陷在于高并发时占用了大量的系统资源；阻塞模型需要等待资源到位，造成资源浪费。</li></ul><ul><li>Reactor模式<ul><li>单Reactor单线程</li><li>单Reactor多线程</li><li>主从Reactor多线程</li></ul></li></ul><p><img src="/image/netty/reactor.png" alt="线程模型简图"></p><ol start="2"><li>单Reactor单线程 AND 单Reactor多线程</li></ol><p><img src="/image/netty/reactor-1.png" alt="单Reactor单线程与单Reactor多线程"></p><p>如上图所示，单Reactor单线程有一个分发器，一个处理器。而单Reactor多线程是它的改进版本，相关细节如下：</p><ul><li>Reactor对象通过select监听客户端请求事件，收到事件后通过 dispatch 进行分发<ul><li>如果是请求连接事件，由Acceptor通过 accept处理连接请求，它会创建一个Handler对象处理连接完成后的各种事件。</li><li>非请求连接事件则由Reactor对象分发到对应的handler处理。<ul><li>handler只负责响应事件，不负责实际的业务处理，通过read读取数据后，会分发给后面的worker线程池的某个线程处理业务<ul><li>worker线程池会分配独立线程完成真正的业务，并将结果返回给handler；handler收到响应后，通过send返回结果给client。</li></ul></li></ul></li></ul></li></ul><ol start="3"><li>主从Reactor多线程</li></ol><p>但是，单Reactor多线程模型仍然存在缺陷。由单个Reactor分发线程，还是存在性能瓶颈。主从Reactor多线程就是为了解决单个Reactor的性能瓶颈，相关细节如下：</p><ul><li>Reactor主线程 MainReactor 对象通过select监听连接事件，收到事件后，通过Acceptor处理连接事件；<ul><li>当 Acceptor 处理连接事件后，MainReactor 将连接分配给 SubReactor；<ul><li>SubReactor 将连接加入到连接队列进行监听，并创建Handler进行事件处理；</li></ul></li></ul></li><li>当新事件发生时，SubReactor 就会调用对应的 handler 处理；<ul><li>handler 通过read读取数据，分发给后面的 worker线程池 处理；<ul><li>worker线程池 分配独立的 worker线程 进行业务处理，并返回结果；</li></ul></li><li>handler 收到响应结果后，再通过 send 将结果返回给 client。</li></ul></li></ul><p><img src="/image/netty/reactor-2.png" alt="主从Reactor多线程"></p><p>主从Reactor多线程实现了请求连接和处理的分离，将连接事件由主线程响应；而请求的读写事件等由子线程进行响应。</p><ol start="4"><li>Reactor模式的构成基础</li></ol><p>而Netty线程模型主要基于主从Reactor多线程模型的改进版本，主从Reactor多线程模型有多个Reactor.</p><ul><li>构成基础<ul><li>基于I/O复用模型（Reactor），多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接；只要有一个及以上的请求接入，就把它们包装成任务分配给其它线程处理。</li><li>基于线程池复用资源（Handlers），通过线程池分配资源执行任务。</li></ul></li><li>设计思想<ul><li>Reactor模式，通过一个或多个输入同时传递给服务器的模式（基于事件驱动）。服务器程序处理传入的多个请求并将它们分配给相应的处理线程，因此它也称之为Dispatcher模式（分发者模式）。</li><li>Reactor模式使用IO复用监听事件，手动事件后分给某个线程，这就是网络服务器高并发处理的关键。</li></ul></li></ul><p>如下图所示，Netty 抽象出两组线程池。其中，BossGroup 专门负责接收客户端连接；而 WorkerGroup 专门负责网络的读写。</p><ul><li>BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup；NioEventLoopGroup 相当于一个事件循环组，该组含有多个事件循环，每个事件循环都是一个 NioEventLoop。<ul><li>NioEventLoop 表示一个不断循环的执行处理任务的线程，每个 NioEventLoop 都有一个 selector, 用于监听绑定在其上的socket网络通讯</li><li>NioEventLoopGroup 可以拥有多个线程（含有多个 NioEventLoop）</li></ul></li><li>BossGroup 循环的步骤<ul><li>轮询 accept事件</li><li>处理 accept事件，与client建立连接，生成 NioSocketChannel，并将其注册到某个 worker NIOEventLoop 上的 selector中</li><li>处理任务队列的任务，即 runAllTasks</li></ul></li><li>WorkerGroup 循环的步骤<ul><li>轮询 read，write事件</li><li>处理I/O事件，调用对应 NioSocketChannel 处理</li><li>处理任务队列的任务，即 runAllTasks</li></ul></li></ul><p><img src="/image/netty/reactor-3.png" alt="Netty模型"></p><h1 id="二、入门"><a href="#二、入门" class="headerlink" title="二、入门"></a>二、入门</h1><p>访问的官网<a href="http://netty.io/，" target="_blank" rel="noopener">http://netty.io/，</a> 从【Downloads】标签页选择下载<code>netty-4.1.60.Final.tar.bz2</code>。如果你习惯使用包管理器，例如maven等。你可以新建一个项目，然后倒入以下的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/io.netty/netty-all --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.1.59.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>通过ServerBootstrap 服务端辅助类来启动服务端代码：</p><ul><li>定义两个线程组，处理客户端的 Accept和读写事件</li><li>绑定NIO服务端通道 NioServerSocketChannel</li><li>为读写事件的线程通道绑定handle，处理具体的业务逻辑</li><li>绑定监听</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import io.netty.bootstrap.Bootstrap;</span><br><span class="line">import io.netty.bootstrap.ServerBootstrap;</span><br><span class="line">import io.netty.buffer.ByteBuf;</span><br><span class="line">import io.netty.buffer.Unpooled;</span><br><span class="line">import io.netty.channel.*;</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line">import io.netty.channel.socket.SocketChannel;</span><br><span class="line">import io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line">import io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line">public class NettyTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class NettySer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new NettySer().bind(9132);</span><br><span class="line">    &#125;</span><br><span class="line">    public void bind(int port) throws Exception &#123;</span><br><span class="line">//            处理处理客户端的 Accept 事件</span><br><span class="line">        EventLoopGroup boss = null;</span><br><span class="line">//            处理客户端读写事件</span><br><span class="line">        EventLoopGroup worker =  null;</span><br><span class="line">//            服务端辅助类</span><br><span class="line">        ServerBootstrap b =  null;</span><br><span class="line">        try &#123;</span><br><span class="line">// 如果不设置线程池的大小，那么默认大小为 CPU核数*2</span><br><span class="line">            boss = new NioEventLoopGroup();</span><br><span class="line">            worker = new NioEventLoopGroup();</span><br><span class="line">            b = new ServerBootstrap();</span><br><span class="line"></span><br><span class="line">//            group：定义两个线程组，bgroup处理客户端的 Accept事件、workerGroup处理读写事件</span><br><span class="line">//            channel：绑定NIO服务端通道 NioServerSocketChannel</span><br><span class="line">//            option：backlog参数指定了等待队列的大小</span><br><span class="line">//            childHandler：绑定handler，处理读写事件，ChannelInitializer是给通道进行初始化</span><br><span class="line">            b.group(boss, worker)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, 1024)</span><br><span class="line">                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(new NettySerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">//          绑定端口</span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">//          监听服务器关闭监听</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class NettySerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">// 处理连接事件</span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;客户端接入&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">// 处理断开事件</span><br><span class="line">    @Override</span><br><span class="line">    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;客户端断开&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">// 处理读取事件</span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf)msg;</span><br><span class="line">        byte[] req = new byte[buf.readableBytes()];</span><br><span class="line">        buf.readBytes(req);</span><br><span class="line">        String body = new String(req, &quot;UTF-8&quot;);</span><br><span class="line">        System.out.println(&quot;From client:&quot;+body);</span><br><span class="line"></span><br><span class="line">        ByteBuf res = Unpooled.copiedBuffer(&quot;to Client: ok&quot;.getBytes());</span><br><span class="line">        ctx.writeAndFlush(res);</span><br><span class="line">    &#125;</span><br><span class="line">// 处理读取完成事件</span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 处理异常事件</span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class NettyCli &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new NettyCli().connect(&quot;127.0.0.1&quot;, 9132);</span><br><span class="line">    &#125;</span><br><span class="line">    public void connect(String host, int port) &#123;</span><br><span class="line">        EventLoopGroup worker =  null;</span><br><span class="line">        Bootstrap bootstrap = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            worker = new NioEventLoopGroup();</span><br><span class="line">            bootstrap = new Bootstrap();</span><br><span class="line">            bootstrap.group(worker)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                        socketChannel.pipeline().addLast(new NettyCliHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture f = bootstrap.connect(host, port).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class NettyCliHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;to Server: connect&quot;.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf)msg;</span><br><span class="line">        byte[] req = new byte[buf.readableBytes()];</span><br><span class="line">        buf.readBytes(req);</span><br><span class="line">        String body = new String(req, &quot;UTF-8&quot;);</span><br><span class="line">        System.out.println(&quot;From Server:&quot;+body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打包和部署"><a href="#打包和部署" class="headerlink" title="打包和部署"></a>打包和部署</h3><p>基于Netty开发的都是非Web的Java应用，它的打包形态非常简单，就是一个普通的jar包，通常情况下，在正式的商业开发中，我们会使用三种打包方式。</p><p>(1) 开发软件提供的导出功能。它可以将指定的Java 或者源码包、代码输出成指定的jar包，它基于下工操作， 在项目模块较多时非常不方便，所以一般不使用这种方式。<br>(2) 使用ant脚本对工程进行打包。将Netty的应用程序打包成指定的<code>．jar</code>    包，一般会输出一个软件安装包： <code>xxxx_install.gz</code><br>(3) 使用Maven进行上程构建。它可以对校块间的依赖进行管理，支持版本的自动化测试、编译和构建，是目前主流的项目管理工具。</p><h1 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h1><p><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">Scalable IO in Java</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、基础&quot;&gt;&lt;a href=&quot;#一、基础&quot; class=&quot;headerlink&quot; title=&quot;一、基础&quot;&gt;&lt;/a&gt;一、基础&lt;/h1&gt;&lt;p&gt;Netty是由JBOSS提供的一个java开源框架，现为 Github上的独立项目。Netty提供异步的、事件驱动的网络应用</summary>
      
    
    
    
    
    <category term="Netty" scheme="http://zws6672.top/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty（三）TCP粘包／拆包</title>
    <link href="http://zws6672.top/2021/03/15/netty-3-decoder/"/>
    <id>http://zws6672.top/2021/03/15/netty-3-decoder/</id>
    <published>2021-03-15T05:09:30.000Z</published>
    <updated>2021-03-15T14:07:40.453Z</updated>
    
    <content type="html"><![CDATA[<p>TCP是个 “流 ” 协议，所谓流，就是没有界限的一串数据。在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送， 也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。</p><h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p>假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下 4 种情况：</p><ul><li>服务端分两次读取到了两个独立的数据包，分别是 D1和D2, 没有粘包和拆包</li><li>服务端一次接收到了两个数据包，D1和D2 粘合在一起，被称为TCP粘包</li><li>服务端分两次读取到了两个数据包，第一次读取到了完整的D1和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包</li><li>服务端分两次读取到了两个数据包，第一次读取到了部分的D1包，第二次读取到了D1包的剩余内容和D2包，这被称为TCP拆包</li></ul><p>如果此时服务端TCP接收滑窗非常小，而数据包 D1和D2 比较大，很有可能会发生第5种可能，即服务端分多次才能将DI和02包接收完全，期间发生多次拆包。</p><ol><li>TCP 粘包／拆包发生的原因：</li></ol><ul><li>应用程序write写入的字节大小大于套接口发送缓冲区大小</li><li>进行MSS 大小的TCP分段</li><li>以太网帧的payload大千MTU进行IP分片</li></ul><ol start="2"><li>MTU和MSS</li></ol><ul><li>MTU: Maxitum Transmission Unit 最大传输单元，一般是 1500 字节</li><li>MSS: Maxitum Segment Size 最大分段大小，用MTU代替（MTU - 数据包包头的大小20Bytes- TCP数据段的包头20Bytes = 1460Bytes）</li></ul><p>在连接建立的时候，即在发送SYN段的时候，同时会将MSS发送给对方（MSS选项只能出现在SYN段中！！！），告诉对端他期望接收的TCP报文段数据部分最大长度。网络传输数据时，数据是最终是要交付到链路层协议上的，也就是说最后要封装成“帧”。二型以太网（Ethernet Type 2）中规定，帧的大小不能超过 1518 个字节（14 字节的帧头 + 4 字节帧校验和 + 最多 1500 字节数据）。所以 IP 数据报的大小如果超过了 1500 字节，要想交付给链路层就必须进行“分片”, 这个值我们就把它称之为MTU。</p><ol start="3"><li>粘包问题的解决策略</li></ol><p>由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决， 根据业界的主流协议的解决方案， 可以归纳如下：</p><ul><li>消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格</li><li>在包尾增加回车换行符进行分割， 例如FTP协议</li><li>将消息分为消息头和消息体， 消息头中包含表示消息总长度（或者消息体长度）的字段， 通常设计思路为消息头的第一个字段使用int32来表示消息的总长度</li><li>更复杂的应用层协议</li></ul><ol start="4"><li>Netty的粘包解决策略</li></ol><p>TCP以流的方式进行数据传输， 上层的应用协议为了对消息进行区分， 往往采用如下4种方式：</p><ul><li>消息长度固定（FixedLengthFrameDecoder）</li><li>将回车换行符作为消息结束符（LineBasedFrameDecoder）</li><li>将特殊的分隔符作为泭息的结束标志（DelimiterBasedFrameDecoder）</li><li>通过在消息头中定义长度字段来标识消息的总长度（LengthFieldBasedFrameDecoder ）</li></ul><p>Netty对上面4种应用做了统一的抽象，提供了4种解码器来解决对应的问题，使用起来非常方便。有了这些解码器， 用户不需要自己对读取的报文进行人工解码，也不需要考虑TCP的粘包和拆包。</p><h1 id="二、四种解码器"><a href="#二、四种解码器" class="headerlink" title="二、四种解码器"></a>二、四种解码器</h1><p>为了解决TCP粘包／拆包导致的半包读写问题，Netty默认提供了多种编解码器用千处理半包，只要能熟练掌握这类库的使用， TCP粘包问题从此会变得非常容易，你甚至不需要关心它们，这也是其他NIO框架和JDK原生的NIO API所无法匹敌的。</p><p>LineBasedFrameDecoder  的工作原理是“它依次遍历ByteBuf中的可读字节，判断看是否有‘\n’或者‘\r\n’，如果有，就在此位置为结束位置，从可读索引到结束位置区间的字节就组成了一行 ”。LineBasedFrameDecoder实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">serverBootstrap.group(boss, worker)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, 1024)</span><br><span class="line">                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(new LineBasedFrameDecoder(1024));</span><br><span class="line">                            socketChannel.pipeline().addLast(new StringDecoder());</span><br><span class="line">                            socketChannel.pipeline().addLast(new NettySerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure><p>LineBasedFrameDecoder 的工作原理是它依次遍历ByteBuf 中的可读字节，判断看是否有“ \n,, 或者” \r\n”， 如果有， 就以此位置为结束位置，从可读索引到结束位置区间的字节就组成了一行。它是以换行符为结束标志的解码器， 支持携带结束符或者不携带结束符两种解码方式，同时支持配置单行的最大长度。如果连续读取到最大长度后仍然没有发现换行符，就会抛出异常，同时忽略掉之前读到的异常码流。</p><p>StringDecoder 的功能非常简单，就是将接收到的对象转换成字符串，然后继续调用后面的Handler。LineBasedFrameDecoder + StringDecoder 组合就是按行切换的文本解码器，它被设计用来支持TCP 的粘包和拆包。</p><p>还有另外两种解码器：DelirnitcrBasedFrameDecoder和 FixedLengthFrameDecoder,前者可以自动完成以分隔符做结束标志的消息的解码， 后者可以自动完成对定长消息的解码，它们都能解决TCP粘包／拆包导致的读半包问题。</p><p>DelimiterBasedFrameDecoder实例如下，可以自定义分隔符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.group(boss, worker)</span><br><span class="line">.channel(NioServerSocketChannel.class)</span><br><span class="line">.option(ChannelOption.SO_BACKLOG, 1024)</span><br><span class="line">.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">socketChannel.pipeline().addLast(new LineBasedFrameDecoder(1024));</span><br><span class="line">socketChannel.pipeline().addLast(new StringDecoder());</span><br><span class="line">socketChannel.pipeline().addLast(new NettySerHandler());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">class NettySerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;客户端接入&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;客户端断开&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;From client:&quot;+msg);</span><br><span class="line">        ByteBuf res = Unpooled.copiedBuffer(&quot;to Client: ok$_$&quot;.getBytes());</span><br><span class="line">        ctx.writeAndFlush(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FixedLengthFrameDecoder 固定长度解码器，它能够按照指定的长度对消息进行自动解码，开发者不需要考虑 TCP 的粘包与拆包问题，非常实用。无论一次接收到多少数据报，它都会按照构造器中设置的固定长度进行解码，如果是半包消息，FixedLengthFrameDecoder  会缓存半包消息并等待下个包到达之后进行拼包合并，直到读取一个完整的消息包。</p><p>如果消息长度不够，则使用空位填补空缺，这样读取到了之后，只需要 trim 去掉空格即可。如果消息不够长，那么就会存储起来。</p><p>FixedLengthFrameDecoder 实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.group(worker)</span><br><span class="line">.channel(NioSocketChannel.class)</span><br><span class="line">.option(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">socketChannel.pipeline().addLast(new FixedLengthFrameDecoder(10));</span><br><span class="line">socketChannel.pipeline().addLast(new StringDecoder());</span><br><span class="line">socketChannel.pipeline().addLast(new NettyCliHandler());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TCP是个 “流 ” 协议，所谓流，就是没有界限的一串数据。在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送， 也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。&lt;/p&gt;
&lt;h1 id=&quot;一、基础&quot;&gt;&lt;a href=&quot;#一、基础&quot; </summary>
      
    
    
    
    
    <category term="Netty" scheme="http://zws6672.top/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty（一）网络I/O模型的Java实现</title>
    <link href="http://zws6672.top/2021/03/15/netty-1-unix/"/>
    <id>http://zws6672.top/2021/03/15/netty-1-unix/</id>
    <published>2021-03-15T05:01:03.000Z</published>
    <updated>2021-03-19T05:16:52.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p>Java 1.4之前的早期版本，Java对I/O的支持并不完善，开发人员在开发高性能I/O程序的时候，会面临一些巨大的挑战和困难，主要问题如下：</p><ul><li>没有数据缓冲区，I/O性能存在问题；</li><li>没有C或者C+＋中的Channel概念，只有输入和输出流；</li><li>同步阻塞式I/0通信(BIO)，通常会导致通信线程被长时间阻塞；</li><li>支持的字符集有限，硬件可移植性不好。</li></ul><p>Linux的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个 file descriptor (fd, 文件描述符）。而对一个 socket 的读写也会有相应的描述符，称为 socketfd (socket 描述符），描述符就是一个数字，它指向内核中的一个结构体（文件路径， 数据区等一些屈性）。</p><ol><li>UNIX的网络I/O模型</li></ol><p>UNIX提供了5种网络I/O模型:</p><ul><li><p>阻塞I/O模型：客户端向服务器端发出请求后，客户端会一直处于等待状态（不会再做其他事情），直到服务器端返回结果或者网络出现问题 ，服务器端同样如此。进程只处理一个请求，并且全程是阻塞的。</p></li><li><p>非阻塞I/O模型：recvfrom 从应用层到内核的时候， 如果该缓冲区没有数据的话，<br>就直接返回一个EWOULDBLOCK错误。一般都会对非阻塞I/O模型进行轮询，查看缓冲区是否有数据。进程只处理一个请求，通过轮询重复调用尝试获取结果。</p></li><li><p>I/O复用模型：Linux提供select/poll. 进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select操作上，这样select/poll 可以帮我们侦测多个fd是否处于就绪状态。select/poll是顺序扫描fd是否就绪，而且支持的fd数目有限，因此它的使用受到了一些制约。Linux还提供了 个epoll系统调用，epoll使用基于事件驱动方式代替顺序扫描，因此性能更高。当有fd就绪时，立即回调函数rollback。用户调用select时，进程被阻塞，这时候会轮询多个流，当有一个或多个准备好后返回；select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p></li><li><p>信号驱动I/O模型（嵌入式使用较多）：首先开启套接口信号驱动I/O功能，并通过系统调用sigaction 执行一个信号处理函数（此系统调用立即返回， 进程继续工作，它是非阻塞的）。当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom 来读取数据，并通知主循环函数处理数据。无论如何处理 SIGIO 信号，这种模型的优势在于等待数据报到达(第一阶段)期间，进程可以继续执行，不被阻塞。免去了select 的阻塞与轮询，当有活跃套接字时，由注册的 handler 处理。</p></li><li><p>异步I/O：告知内核启动某个操作，并让内核在整个操作完成后（包括将数据从 内核复制到用户自己的缓冲区）通知我们。 这种模型与信号驱动模型的主要区别是： 信号驱动I/O由内核通知我们何时可以开始一个I/O操作； 异步I/O模型由内核通知我们I/O操作何时已经完成。</p></li></ul><ol start="2"><li>I/O多路复用技术</li></ol><p>在I/O编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者I/O多路复用技术进们处理。I/O多路复用技术通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。目前支待I/O多路复用的系统调用有select、 pselect、 poll、 epoll，select轮询存在缺陷，所以Linux内核用了epoll替代了select。</p><p>epoll的特点如下：</p><ul><li>支持一个进程打开的 socket 描述符 (FD) 不受限制（仅受限于操作系统的最大文件句柄数，）。select最大的缺陷就是单个进程所打开的 FD 是有一定限制的， 它由 FD_SETSIZE 设置，默认值是1024。epoll 并没有这个限制，它所支持的 FD 上限是操作系统的最大文件句柄数，具体的值可以通过 cat /proc/sys/fs/file- max 查看。</li><li>I/O效率不会随若 FD数目的增加而线性下降。epoll 是根据每个 fd 上面的 callback 函数实现的，只有 “活跃 ” 的 socket 才会去主动调用 callback 函数。</li><li>使用 mmap 加速内核与用户空间的消息传递。</li><li>epoll的API更加简单。</li></ul><ol start="3"><li>Java 的I/O</li></ol><p>在JDK1.4推出Java NIO之前，基于Java的所有Socket通信都采用了同步阻塞模式(BIO)，这种请求————应答的通信梑型简化了上层的应用开发 ，但是在性能和可靠性方面 却存在若巨大的瓶颈。JDKl.4版本提供了新的NIO类库，也可以支持非阻塞I/O了。</p><p>JDK1.4 时 ， NIO 以 JSR-51 的身份正式随 JDK 发布。 它新增了个 java.nio 包， 提供了很多 进行异步I/O开发的 API 和类库， 主要的类和接口如下：</p><ul><li>进行异步I/O操作的缓冲区 ByteBuffer 等； 进行异步I/O操作的管道 Pipe;</li><li>进行各种I/O操作（异步或者同步）的 Channel, 包括 ServerSocketChannel 和SocketChannel; </li><li>多种字符集的编码能力和解码能力；</li><li>实现非阳塞I/O操作的多路复用器 selector;</li><li>基于流行的 Perl 实现的正则表达式类库；</li><li>文件通道 FileChannel。</li></ul><ol start="4"><li>AIO</li></ol><p>NIO 2.0引入了新的异步通道的概念，并提供了异步文件通道和异步套接宇通道的实现。异步通道提供以下两种方式获取获取操作结果：</p><ul><li>通过java.uti.concurrent.Future类来表示异步操作的结果 </li><li>使用回调函数</li></ul><p>NIO 2.0的异步套接字通道是真正的异步非阻塞I/O,对应的UNIX网络编程中的事件 驱动I/O (AIO)。 它不需要通过多路复用器(Selector)对注册的通道进行轮询操作即可实现异步读写，从而简化了NIO的编程模型。</p><h1 id="二、同步阻塞式I-O（BIO）"><a href="#二、同步阻塞式I-O（BIO）" class="headerlink" title="二、同步阻塞式I/O（BIO）"></a>二、同步阻塞式I/O（BIO）</h1><p>网络编程的基本模型是 Clieot/Server 模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息（绑定的IP地址和监听端口）， 客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接;如果连接建立成功，双方就可以通过网络套接字 (Socket) 进行通信。</p><p>BIO服务端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">public class BIOServerTest &#123;</span><br><span class="line">    public static void main (String[] args) throws IOException &#123;</span><br><span class="line">        int port = 8080;</span><br><span class="line"></span><br><span class="line">        if(args!=null &amp;&amp; args.length&gt;0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                port = Integer.parseInt(args[0]);</span><br><span class="line">            &#125;  catch (NumberFormatException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ServerSocket server = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //从连接队列中取出一个连接，如果没有则等待</span><br><span class="line">            server = new ServerSocket(port);</span><br><span class="line">            Socket socket = null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                socket = server.accept();</span><br><span class="line">                new Thread(new BIOServerHandler(socket)).start();</span><br><span class="line">            &#125;  catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;  finally &#123;</span><br><span class="line">                if (server != null) &#123;</span><br><span class="line">                    server.close();</span><br><span class="line">                    server = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line">            if (server!=null) &#123;</span><br><span class="line">                server.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BIOServerHandler implements Runnable&#123;</span><br><span class="line">    private Socket socket;</span><br><span class="line"></span><br><span class="line">    public BIOServerHandler(Socket socket) &#123;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        PrintWriter out = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = new PrintWriter(socket.getOutputStream(), true);</span><br><span class="line">            String body = null;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">//                获取客户端报文</span><br><span class="line">                body = in.readLine();</span><br><span class="line">                if (body == null) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">//                触发回馈</span><br><span class="line">                if (&quot;QUERY TIME ORDER&quot;.equals(body)) &#123;</span><br><span class="line">                    SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">                    out.println(format.format(new Date()));</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;Client body：&quot;+body);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line">            if(out != null) &#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(in != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                in = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(socket != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BIO客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class BIOClientTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        int port = 8080;</span><br><span class="line">        // 端口参数检测</span><br><span class="line">        if(args!=null &amp;&amp; args.length&gt;0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                port = Integer.parseInt(args[0]);</span><br><span class="line">            &#125;  catch (NumberFormatException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Socket socket = null;</span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        PrintWriter out = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            socket = new Socket(&quot;127.0.0.1&quot;, port);</span><br><span class="line">            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = new PrintWriter(socket.getOutputStream(), true);</span><br><span class="line">//            查询指令</span><br><span class="line">            out.println(&quot;QUERY TIME ORDER&quot;);</span><br><span class="line">//            获取回馈</span><br><span class="line">            String resp = in.readLine();</span><br><span class="line">            System.out.println(&quot;The resp：&quot;+ resp);</span><br><span class="line"></span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line">            if(out != null) &#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(in != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                in = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(socket != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步式IO的相关代码如上所示。但是存在一个问题，就是当存在一个服务端连接只能处理一个客户端连接，效率过低。而高性能的服务器，需要同时处理成千上万的客户端连接，这种模型是无法满足并发要求的。当然我们也可以基于线程池和同步阻塞式I/O构建伪异步IO,将Socket封装成任务异步调用，客户端代码不变，底层仍然是同步阻塞的。</p><h1 id="三、非阻塞式IO（NIO）编程"><a href="#三、非阻塞式IO（NIO）编程" class="headerlink" title="三、非阻塞式IO（NIO）编程"></a>三、非阻塞式IO（NIO）编程</h1><p>NIO（JDK1.4）模型是一种同步非阻塞IO，主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector（多路复用器）。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(多路复用器)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol start="0"><li>NIO和BIO的比较</li></ol><p>BIO，即阻塞IO；而NIO是非阻塞IO。<br>BIO是以流的方式处理数据；而NIO是以块的方式处理数据。<br>BIO是基于字节流和字符流操作；而NIO基于 Channel和Buffer 进行操作，通过通道读取数据到缓冲区，或者通过缓冲区写入到通道中。Selector（选择器）用于监听多个通道的事件，因此可以通过单线程监听多个连接。</p><ol><li>缓冲区Buffer</li></ol><p>Buffer是一个对象，它包含一些要写入或者要读出的数据。在 NIO 类库中加入 Buffer对象，体现了新库与原IO的一个重要区别。在“面向流的”IO 中，可以将数据直接写入或者将数据直接读到 Stream 对象中。</p><p>它是NIO重要的组成部分，表明了NIO是面向缓冲区的而不是流。在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，写入到缓冲区中。任何时候访问 NIO 中的数据，都是通过缓冲区进行操作。</p><p>缓冲区是一个可读取的内存，实质上是一个数组。通常它是一个字节数组 (ByteBuffer)， 也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组。缓冲区提供了对数据的结构化访问以及维护读写位置 (limit) 等信息 。</p><ul><li>Buffer<ul><li>ByteBuffer: 字节缓冲区<ul><li>MappedByteBuffer：支持文件在内存中修改，使用的是堆外内存</li></ul></li><li>CharBuffer: 字符缓冲区</li><li>ShortBuffer：短整型缓冲区</li><li>IntBuffer：整形缓冲区</li><li>LongBuffer: 长整形缓冲区</li><li>FloatBuffer：浮点型缓冲区</li><li>DoubleBuffer: 双精度浮点型缓冲区</li></ul></li></ul><p>Buffer读写数据的步骤如下：</p><ul><li>把数据写入buffer；</li><li>调用flip，把buffer从写模式调整为读模式；在读模式下，可以读取所有已经写入的数据。</li><li>从Buffer中读取数据；</li><li>调用buffer.clear()或者buffer.compact()；clear会清空整个buffer，compact则只清空已读取的数据。</li></ul><p>Buffer缓冲区实质上就是一块内存，可以进行读取和写入。Buffer有四个属性是必备的，分别是：</p><ul><li>capacity容量：是缓冲区可容纳的最大数据量，缓冲区创建时设置且不可更改。</li><li>limit限制：表示缓冲区的当前终点，不能对超过的位置进行读写操作</li><li>position位置：下一个要读或者要写的索引，每次读写缓冲区都会改值</li><li>mask：标记，用于position的临时保存。调用mask()设置mask=position，再调用reset()可以让position恢复它原来的位置</li></ul><blockquote><p>注：NIO还支持通过多个Buffer数组完成读写操作，即Buffer的分散和聚集。分散，是数据写入多个buffer；聚集是从多个buffer读取数据<br>Buffer的常见方法：</p></blockquote><table><thead><tr><th align="left">方法</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">abstract Object array()</td><td align="left">返回支持此缓冲区的数组 （可选操作）</td></tr><tr><td align="left">abstract int arrayOffset()</td><td align="left">返回该缓冲区的缓冲区的第一个元素的在数组中的偏移量 （可选操作）</td></tr><tr><td align="left">int capacity()</td><td align="left">返回此缓冲区的容量</td></tr><tr><td align="left">Buffer clear()</td><td align="left">清除此缓存区。将position = 0;limit = capacity;mark = -1;</td></tr><tr><td align="left">Buffer flip()</td><td align="left">flip()方法可以吧Buffer从写模式切换到读模式。调用flip方法会把position归零，并设置limit为之前的position的值。 也就是说，现在position代表的是读取位置，limit标示的是已写入的数据位置。</td></tr><tr><td align="left">abstract boolean hasArray()</td><td align="left">告诉这个缓冲区是否由可访问的数组支持</td></tr><tr><td align="left">boolean hasRemaining()</td><td align="left">return position &lt; limit，返回是否还有未读内容</td></tr><tr><td align="left">abstract boolean isDirect()</td><td align="left">判断个缓冲区是否为 direct</td></tr><tr><td align="left">abstract boolean isReadOnly()</td><td align="left">判断告知这个缓冲区是否是只读的</td></tr><tr><td align="left">int limit()</td><td align="left">返回此缓冲区的限制</td></tr><tr><td align="left">Buffer position(int newPosition)</td><td align="left">设置这个缓冲区的位置</td></tr><tr><td align="left">int remaining()</td><td align="left">return limit - position; 返回limit和position之间相对位置差</td></tr><tr><td align="left">Buffer rewind()</td><td align="left">把position设为0，mark设为-1，不改变limit的值</td></tr><tr><td align="left">Buffer mark()</td><td align="left">将此缓冲区的标记设置在其位置</td></tr></tbody></table><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main (String[] args) &#123;</span><br><span class="line">        IntBuffer intBuffer = IntBuffer.allocate(24);</span><br><span class="line">        for (int i=0; i&lt;24; i++) &#123;</span><br><span class="line">            intBuffer.put((int) (Math.random()*100));</span><br><span class="line">        &#125;</span><br><span class="line">        intBuffer.flip(); // 读写切换</span><br><span class="line"></span><br><span class="line">        while (intBuffer.hasRemaining()) &#123; // 测试是否有数据</span><br><span class="line">            // Buffer 内部维持一个索引</span><br><span class="line">            System.out.println(intBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">intBuffer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>通道Channel</li></ol><p>Channel是一个通道，网络数据通过Channel同时读取和写入。通道与流的不同之处在千通道是双向的，流只是在一个方向上移动（一个流必须是InputStream 或者 OutputStream 的子类），而通道可以用于读、写或者二者同时进行。因为 Channel 是全双工的，所以它可以比流更好地映射底层操作系统的 API。</p><ul><li>特点<ul><li>同时读写</li><li>异步读写</li><li>可以从缓冲区读写数据</li></ul></li><li>常用Channel（抽象类）<ul><li>FileChannel： 文件的数据读写                </li><li>SocketChannel： TCP的数据读写，一般是客户端实现</li><li>ServerSocketChannel: 允许我们监听TCP链接请求，每个请求会创建会一个SocketChannel，一般是服务器实现</li><li>DatagramChannel： UDP的数据读写</li></ul></li><li>相关方法<ul><li>int read(ByteBuffer dst) 从通道读取数据</li><li>int write(ByteBuffer src) 写入数据到通道</li><li>long transferFrom(ReadableByteChannel src,long position, long count) 从目标通道复制数据到当前通道</li><li>long transferTo(long position, long count,WritableByteChannel target) 从当前通道复制数据到目标通道</li></ul></li></ul><p>接口源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Channel extends Closeable &#123;</span><br><span class="line">    public boolean isOpen();</span><br><span class="line">    public void close() throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>transferFrom实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main (String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    FileInputStream fis = new FileInputStream(&quot;E:\\wsz6672\\ws6672.github\\source\\image\\19819\\a2.png&quot;);</span><br><span class="line">    FileOutputStream fos = new FileOutputStream(new File(&quot;E:\\wsz6672\\ws6672.github\\source\\image\\19819\\b1-copy.png&quot;));</span><br><span class="line"></span><br><span class="line">    FileChannel fromC = fis.getChannel();</span><br><span class="line">    FileChannel toC = fos.getChannel();</span><br><span class="line">    toC.transferFrom(fromC, 0,fromC.size());</span><br><span class="line"></span><br><span class="line">    fromC.close();</span><br><span class="line">    toC.close();</span><br><span class="line">    fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通道Channel的实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class ChannelTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FileChannel fileChannel = null;</span><br><span class="line">        RandomAccessFile raf = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            raf = new RandomAccessFile(&quot;F://test.txt&quot;,&quot;rw&quot;);</span><br><span class="line">            fileChannel = raf.getChannel();</span><br><span class="line">            int buf_size = 512;</span><br><span class="line">            if(buf_size&gt;fileChannel.size()) &#123;</span><br><span class="line">                buf_size = (int)fileChannel.size();</span><br><span class="line">            &#125;</span><br><span class="line">            ByteBuffer readbuf = ByteBuffer.allocate(buf_size);</span><br><span class="line">//            ByteBuffer writebuf = ByteBuffer.allocate(buf_size);</span><br><span class="line"></span><br><span class="line">            while (fileChannel.read(readbuf) &gt;0) &#123;</span><br><span class="line">                readbuf.flip();</span><br><span class="line">// 就是判断position和limit之间是否有元素</span><br><span class="line">                System.out.print(Charset.forName(&quot;UTF-8&quot;).decode(readbuf).toString());</span><br><span class="line">                readbuf.clear();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (fileChannel != null) &#123;</span><br><span class="line">                    fileChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if (fileChannel != null) &#123;</span><br><span class="line">                    fileChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if (raf != null) &#123;</span><br><span class="line">                    raf.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>多路复用器Selector</li></ol><p>多路复用器提供选择已经就绪的任务的能力，Selector会不断地轮询注册在其上的 Channel, 如果某个 Channel 上面发生读或者写事件， 这个 Channel 就处于就绪状态，会被 Selector 轮询出来，然后通过 SelectionKey 可以获取就绪 Channel 的集合，进行后续的 I/O 操作。一个多路复用器 Selector 可以同时轮询多个 Channel, 由千 JDK 使用了 epoll(）代替传统的 select 实现 ， 所以它并没有最大连接句柄 1024/2048 的限制。这也就意味着只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端.</p><p>Selector能够检测多个注册的通道是否有事件发生，多个Channel以事件的方式注册到同一个 Selector。只有在连接通道有读写事件发生时才进行相应的处理，减少了多线程切换的开销，避免了阻塞导致的性能下降。一个I/O线程可以并发处理N个客户端连接和读写操作，从根本上解决了同步阻塞模型一连接一线程模型的低效问题，架构的性能、弹性伸缩能力和可靠性得到了极大的提升。</p><ul><li>源码<ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Selector implements Closeable &#123;</span><br><span class="line"></span><br><span class="line">// 初始化类实例</span><br><span class="line">protected Selector() &#123; &#125;</span><br><span class="line"></span><br><span class="line">//打开一个多路复用器</span><br><span class="line">public static Selector open() throws IOException &#123;</span><br><span class="line">return SelectorProvider.provider().openSelector();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试多路复用器是否打开</span><br><span class="line">public abstract boolean isOpen();</span><br><span class="line">//返回通道创建者</span><br><span class="line">public abstract SelectorProvider provider();</span><br><span class="line">//当前连接的keys</span><br><span class="line">public abstract Set&lt;SelectionKey&gt; keys();</span><br><span class="line">//访问“已选择键集（selected key set）”中的就绪通道</span><br><span class="line">public abstract Set&lt;SelectionKey&gt; selectedKeys();</span><br><span class="line"></span><br><span class="line">//不会阻塞，不管什么通道就绪都立刻返回</span><br><span class="line">public abstract int selectNow() throws IOException;</span><br><span class="line"></span><br><span class="line">//和select()一样，除了设置最长阻塞时间timeout毫秒</span><br><span class="line">public abstract int select(long timeout) throws IOException;</span><br><span class="line">//阻塞,直到至少有一个通道就绪</span><br><span class="line">public abstract int select() throws IOException;</span><br><span class="line">public abstract void close() throws IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="4"><li>三大核心的关系</li></ol><ul><li>Selector 对应一个线程，一个线程对应多个Channel；每个Channel对应一个Buffer。</li><li>Selector切换到哪一个通道由监听到的事件决定，它会根据不同的事件在不同的通道上切换。</li><li>Buffer是一个内存块，底层是一个数组；可读可写，但是需要通过flip 方法切换。</li><li>channel是双向的</li></ul><h3 id="java实现NIO"><a href="#java实现NIO" class="headerlink" title="java实现NIO"></a>java实现NIO</h3><ol><li>reactor（反应器）模式</li></ol><p>使用单线程模拟多线程，提高资源利用率和程序的效率，增加系统吞吐量。单线程下要多个操作执行完成后才处理其它请求，伪多线程是在单线程处理某些需要长时间等待的操作时，先处理其它请求。</p><ol start="2"><li>服务端和客户端序列图 </li></ol><p><img src="/image/netty/nio-server-time.png" alt="NIO 服务端序列图"></p><p><img src="/image/netty/nio-client-time.png" alt="NIO 客户端序列图"></p><ol start="3"><li>SocketChannel的方法</li></ol><p>register() 方法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final SelectionKey register(Selector sel, int ops)</span><br><span class="line">        throws ClosedChannelException</span><br></pre></td></tr></table></figure><p>第一个参数是 多路复用器，第二个参数是监听的事件，相关事件如下：</p><ul><li>SelectionKey.OP_ACCEPT 接收就绪（服务器准备好接收连接）,16</li><li>SelectionKey.OP_CONNECT 连接就绪（通道连接到服务器）,8</li><li>SelectionKey.OP_WRITE 写就绪,4</li><li>SelectionKey.OP_READ 读就绪,1</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static final int OP_ACCEPT = 1 &lt;&lt; 4;</span><br><span class="line">public static final int OP_CONNECT = 1 &lt;&lt; 3;</span><br><span class="line">public static final int OP_WRITE = 1 &lt;&lt; 2;</span><br><span class="line">public static final int OP_READ = 1 &lt;&lt; 0;</span><br></pre></td></tr></table></figure></li></ul><p>我们也可以同时监听多个事件：<code>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE</code>。</p><ol start="4"><li>SelectionKey</li></ol><p>SelectionKey表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key.attachment(); //返回SelectionKey的attachment，attachment可以在注册channel的时候指定。</span><br><span class="line">key.channel(); // 返回该SelectionKey对应的channel。</span><br><span class="line">key.selector(); // 返回该SelectionKey对应的Selector。</span><br><span class="line">key.interestOps(); //返回代表需要Selector监控的IO操作的bit mask</span><br><span class="line">key.readyOps(); // 返回一个bit mask，代表在相应channel上可以进行的IO操作。</span><br></pre></td></tr></table></figure><ol start="5"><li>NIO 服务端和客户端示例</li></ol><p>服务端如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.ServerSocketChannel;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/8 13:55</span><br><span class="line"> * @Description TODO</span><br><span class="line"> */</span><br><span class="line">public class NIOTest implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private int port;</span><br><span class="line">    //用于轮询的多路复用器</span><br><span class="line">    private Selector selector;</span><br><span class="line">    // 服务器通道</span><br><span class="line">    private ServerSocketChannel acceptor;</span><br><span class="line"></span><br><span class="line">    private ServerSocket serverSocket;</span><br><span class="line"></span><br><span class="line">    public NIOTest() &#123;</span><br><span class="line">        this(9999);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NIOTest(int port) &#123;</span><br><span class="line">        this.port = port;</span><br><span class="line">        try &#123;</span><br><span class="line">//          1. 监听客户端连接</span><br><span class="line">            acceptor = ServerSocketChannel.open();</span><br><span class="line">//          2. 绑定端口、用通道对象生成服务器对象、为服务端Socket绑定监听端口</span><br><span class="line">            acceptor.configureBlocking(false);</span><br><span class="line">            serverSocket = acceptor.socket();</span><br><span class="line">            serverSocket.bind(new InetSocketAddress(&quot;localhost&quot;, port));</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            acceptor.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            System.out.println(&quot;Server Start&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (selector!=null &amp;&amp; selector.isOpen()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                selector.select(1000);</span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">                SelectionKey key = null;</span><br><span class="line">                while (it.hasNext()) &#123;</span><br><span class="line">                    key = it.next();</span><br><span class="line">                    it.remove();</span><br><span class="line">                    handleAccept(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void handleAccept(SelectionKey key) &#123;</span><br><span class="line"></span><br><span class="line">        if (key.isValid()) &#123;</span><br><span class="line">            if (key.isAcceptable()) &#123;</span><br><span class="line">//                在多路复用器注册客户端连接</span><br><span class="line">                SocketChannel sc = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    sc = ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line">                    if (sc != null) &#123;</span><br><span class="line">                        sc.configureBlocking(false);</span><br><span class="line">                        sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;  catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (key.isReadable()) &#123;</span><br><span class="line">//               处理客户端连接请求</span><br><span class="line">                handleRead(key);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;客户端请求完成&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void handleRead(SelectionKey key) &#123;</span><br><span class="line">        SocketChannel sc = null;</span><br><span class="line">        ByteBuffer buffer = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            sc = (SocketChannel)key.channel();</span><br><span class="line">            //创建缓存区</span><br><span class="line">            buffer = ByteBuffer.allocate(1024);</span><br><span class="line">            int byteSize = sc.read(buffer);</span><br><span class="line">            if (byteSize==-1) &#123;</span><br><span class="line">                sc.shutdownInput();</span><br><span class="line">                sc.shutdownOutput();</span><br><span class="line">                sc.close();</span><br><span class="line">                System.out.println(&quot;连接断开&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                byte[] data = new byte[buffer.remaining()];</span><br><span class="line">                buffer.get(data);</span><br><span class="line">                buffer.clear();</span><br><span class="line">                String content = new String(data);</span><br><span class="line">                System.out.println(&quot;Server receiver message: &quot;+content);</span><br><span class="line">                respon(sc, &quot;from Server&apos;s respon&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void respon(SocketChannel sc, String message) &#123;</span><br><span class="line">        ByteBuffer buffer = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (message != null &amp;&amp; message.length() != 0) &#123;</span><br><span class="line">                byte[] data = message.getBytes();</span><br><span class="line">                buffer = ByteBuffer.allocate(1024);</span><br><span class="line">                buffer.put(data);</span><br><span class="line">                buffer.flip();</span><br><span class="line">                sc.write(buffer);</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        NIOTest nioTest = new NIOTest(9999);</span><br><span class="line">        new Thread(nioTest).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zws</span><br><span class="line"> * @date 2021/3/9 22:15</span><br><span class="line"> * @Description TODO</span><br><span class="line"> */</span><br><span class="line">public class NIOClient implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private String  host;</span><br><span class="line">    private int port;</span><br><span class="line">    private Selector selector;</span><br><span class="line">    private SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    public NIOClient() &#123;</span><br><span class="line">        this(&quot;localhost&quot;, 9999);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NIOClient(String  host, int port) &#123;</span><br><span class="line">        this.host = host;</span><br><span class="line">        this.port = port;</span><br><span class="line">        try &#123;</span><br><span class="line">            socketChannel = SocketChannel.open();</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            socketChannel.configureBlocking(false);</span><br><span class="line">            socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;,port));</span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (selector != null &amp;&amp; selector.isOpen()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                selector.select(1000);</span><br><span class="line">                //获得所有已就绪的通道</span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">                SelectionKey key = null;</span><br><span class="line">                while(it.hasNext()) &#123;</span><br><span class="line">                    key = it.next();</span><br><span class="line">                    it.remove();</span><br><span class="line">                    handleInput(key);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;  catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void send (SocketChannel sc,String content) &#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);</span><br><span class="line">        if (content!=null &amp;&amp; content.length() != 0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                byte[] data = content.getBytes();</span><br><span class="line">                byteBuffer.put(data);</span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                sc.write(byteBuffer);</span><br><span class="line">            &#125;  catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void handleInput(SelectionKey key) &#123;</span><br><span class="line">        SocketChannel sc = null;</span><br><span class="line">        if (key.isValid()) &#123;</span><br><span class="line">            if (key.isConnectable()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    sc = (SocketChannel) key.channel();</span><br><span class="line">                    if (sc.finishConnect()) &#123;</span><br><span class="line">                        sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                        send(sc, &quot;client send message&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;  catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (key.isReadable()) &#123;</span><br><span class="line">                handleRead(key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void handleRead(SelectionKey key) &#123;</span><br><span class="line">        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">        try &#123;</span><br><span class="line">            int byte_size = sc.read(buffer);</span><br><span class="line">            if (byte_size&gt;0) &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                byte[] data = new byte[buffer.remaining()];</span><br><span class="line">                buffer.get(data);</span><br><span class="line">                buffer.clear();</span><br><span class="line">                String content = new String(data);</span><br><span class="line">                System.out.println(content);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //表示读取数据失败,需要释放资源</span><br><span class="line">                key.cancel();</span><br><span class="line">                sc.close();</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        NIOClient nioClient = new NIOClient();</span><br><span class="line">        new Thread(nioClient).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上例子可知，NIO编程的难度确实比同步阻塞BIO的大很多，在上面的实例中还没考虑半包读、半包写、编码解码等问题。虽然NIO编写复杂，但是它还是在网络编程中应用广泛，优点如下：</p><ul><li>客户端发起的连接操作是异步的，无须阻塞</li><li>SocketChannel的读写操作都是异步的， 如果没有可读写的数据它不会同步 等待，直接返回 ， 这样I/O通信线程就可以处理其他的链路， 不需要同步等待这个链路可用。</li><li>线程模型的优化，通过epoll避免了连接限制。</li></ul><hr><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>虽然有五种网络通信的IO方式，但是Java只实现了四种（没有信号驱动I/O模型）。</p><p>相关概念如下：</p><ul><li>异步非阻塞 I/O：很多人喜欢将JDK 1.4提供的NlO框架称为异步非阻塞 I/O， 但是，如果严格按照UNIX网络编程 模型和JDK的实现进行区分， 实际上它只能被称为非阻塞VO, 不能叫异步非阻塞 I/O。由JDKl.7提供的NIO2.0新增了异步的套接字通道， 它是真正的异步 I/O, 在异步 I/O 操作的时候可以传递信号变晁， 当操作完成之后会回调相关的方法，异步I/O也被称为AIO</li><li>多路复用器 Selector：多路复用的核心就是通过 Selector 来轮询注册在其上的 Channel，当发现某个或者多个 Channel 处于就绪状态后 ，从阻塞状态返回就绪的 Channel 的选择键集合，进行 I/O 操作 。 </li><li>伪异步I/O：在通信线程和业务线程之间做个缓冲区， 这个缓冲区用千隔离I/O线程和业务线程间的直接访问， 这样业务线程就不会被 I/O线程阻塞。线程接收连接，将连接封装为Task后放到线程池中然后返回去处理其它的请求。</li></ul><p>基于NIO的网络框架NIO是一种网络并发解决方案，使用广泛。但是，Netty不是全能的，具体选择什么样的I/O 模型或者NIO框架， 完全基于业务的实际应用场景和性能诉求，如果客户端并发连接数不多，周边对接的网元不多，服务器的负载也不重， 那就完全没必要选择NlO做服务端；如果是相反情况，那就要考虑选择合适的 NIO框架进行开发。</p><p>不选择 Java 原生 NIO 编程的原因：</p><ul><li>NIO 的类库和 API 繁杂，使用麻烦， 你需要熟练掌握 Selector 、 ServerSocketChannel、 SocketChannel、 ByteBuffer</li><li>需要熟悉 Java 多线程编程等额外技能</li><li>可靠性差</li><li>JDK NIO 的 BUG, 例如臭名昭著的 epoll bug, 它会导致 Selector 空轮询， 最终导 致 CPU 100%</li></ul><p>如果需要开发一个网络并发组件，那么Netty值得一试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、基础&quot;&gt;&lt;a href=&quot;#一、基础&quot; class=&quot;headerlink&quot; title=&quot;一、基础&quot;&gt;&lt;/a&gt;一、基础&lt;/h1&gt;&lt;p&gt;Java 1.4之前的早期版本，Java对I/O的支持并不完善，开发人员在开发高性能I/O程序的时候，会面临一些巨大的挑战和</summary>
      
    
    
    
    
    <category term="Netty" scheme="http://zws6672.top/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>VUE（四）组件的使用</title>
    <link href="http://zws6672.top/2021/01/22/vue-3/"/>
    <id>http://zws6672.top/2021/01/22/vue-3/</id>
    <published>2021-01-22T15:47:37.000Z</published>
    <updated>2021-01-23T08:10:45.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、组件注册"><a href="#一、组件注册" class="headerlink" title="一、组件注册"></a>一、组件注册</h1><p>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。组件依照使用范围可以分为全局组件和局部组件；全局组件可以在所有的vue实例VUE实例中使用，而局部组件只能在注册了该组件的VUE实例中使用。</p><p>注意：</p><ul><li>全局组件必须写在Vue实例创建之前，才在该根元素下面生效</li><li>局部组件注册方式，直接在Vue实例里面注册</li></ul><ol><li>组件定义</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 组件命名规范：字母全小写且必须包含一个连字符（短横线分隔命名）；首字母大写定义组件（驼峰命名法）。</span><br><span class="line">全局组件注册方式：Vue.component(组件名,&#123;方法&#125;)</span><br><span class="line"></span><br><span class="line">局部组件注册方式：在VUE实例的components中定义，即可</span><br></pre></td></tr></table></figure><p>html 中attribute是大小写不敏感的，驼峰命名法的prop名需要使用与其等价的短横线分隔命名，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;blog-post&apos;, &#123;</span><br><span class="line">  // 在 JavaScript 中是 camelCase 的</span><br><span class="line">  props: [&apos;postTitle&apos;],</span><br><span class="line">  template: &apos;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;</span><br><span class="line">&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>全局注册的组件</li></ol><p>全局注册的组件也就是说它们在注册之后可以用在任何新创建的 <code>Vue 根实例 (new Vue)</code> 的模板中。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// JS代码, component需定义在根实例前</span><br><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">template: &quot;&lt;span style=&apos;color:red;&apos;&gt;通过component定义的全局组件&lt;/span&gt;&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue&#123;(</span><br><span class="line">el:&apos;#app&apos;</span><br><span class="line">)&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--html代码--&gt;</span><br><span class="line">&lt;div id= &apos;app&apos;&gt;</span><br><span class="line">&lt;my-component&gt;</span><br><span class="line"></span><br><span class="line">&lt;/my-component&gt;</span><br><span class="line">&lt;div id= &apos;app&apos;&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>局部注册的组件</li></ol><p>局部注册的组件只有在配置了<code>components</code>属性后才能被使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--html代码--&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;child-component&gt;&lt;child-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// JS代码</span><br><span class="line">// 局部注册的组件在其子组件中无法使用。</span><br><span class="line">new Vue&#123;(</span><br><span class="line">el:&apos;#app&apos;,</span><br><span class="line">components: &#123;</span><br><span class="line">&quot;child-component&quot;:&#123;</span><br><span class="line">template:&quot;&lt;p&gt;根实例中components属性定义的局部组件&lt;/p&gt;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><p>如果其他组件想使用局部组件，也需要类似的定义。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var com-b = Vue.component(&apos;my-component&apos;,&#123;</span><br><span class="line">components: &#123;</span><br><span class="line">//组件别称：实际调用的组件</span><br><span class="line">&apos;component-a&apos;:com-a</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 这样定义后，b组件就可以使用A组件了。</span><br></pre></td></tr></table></figure><ol start="4"><li>组件中的数据和方法</li></ol><ul><li>方法<ul><li>父组件调用子组件：ref（在子组件中加上ref即可通过this.$refs.ref.method调用）</li><li>子组件调用父组件：emit（this.$emit(调用的方法名，传递的参数)）</li></ul></li><li>数据<ul><li>父组件传给子组件：props</li><li>子组件传给父组件：emit</li></ul></li><li>共享采用：vuex</li><li>导入使用：import</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vm.$refs：一个对象，持有已注册过ref的所有子组件</span><br><span class="line">ref：被用来给元素或子组件注册引用信息，引用信息将会注册在父组件的 $ref 对象上</span><br><span class="line"></span><br><span class="line">let vm = new Vue&#123;(</span><br><span class="line">el:&apos;#app&apos;,</span><br><span class="line">components: &#123;</span><br><span class="line">&quot;child-component&quot;:&#123;</span><br><span class="line">template:&quot;&lt;p&gt;根实例中components属性定义的局部组件&lt;/p&gt;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">)&#125;</span><br><span class="line"></span><br><span class="line">&lt;span ref=&quot;my-span&quot;&gt;空白行&lt;/span&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、组件注册&quot;&gt;&lt;a href=&quot;#一、组件注册&quot; class=&quot;headerlink&quot; title=&quot;一、组件注册&quot;&gt;&lt;/a&gt;一、组件注册&lt;/h1&gt;&lt;p&gt;组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的</summary>
      
    
    
    
    
    <category term="vue" scheme="http://zws6672.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>VUE（三）指令</title>
    <link href="http://zws6672.top/2021/01/22/vue-order/"/>
    <id>http://zws6672.top/2021/01/22/vue-order/</id>
    <published>2021-01-22T15:03:48.000Z</published>
    <updated>2021-01-22T15:29:08.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、插值"><a href="#一、插值" class="headerlink" title="一、插值"></a>一、插值</h1><p><em>文本</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 双大括号会将数据解释为普通文本，而非 HTML 代码</span><br><span class="line">&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p><em>原始 HTML插入</em><br>通过<code>v-html</code>将文本解析成html代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p><em>属性的绑定</em><br>将属性<code>id</code>与<code>dynamicId</code>绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><em>JS的支持</em></p><p>模板中，绑定都能使用且能使用单个表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line">&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;</span><br><span class="line">&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 这是语句，不是表达式 --&gt;</span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="二、常用指令"><a href="#二、常用指令" class="headerlink" title="二、常用指令"></a>二、常用指令</h1><ol><li>基础</li></ol><p>常用指令，【v-】前缀代表vue特有指令</p><ul><li><p>v-bind用于绑定数据和元素属性</p><ul><li><code>v-bind:title 表示绑定标签的title属性</code></li><li>完整：<code>&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;</code></li><li>缩写：<code>&lt;a :[key]=&quot;url&quot;&gt; ... &lt;/a&gt;</code></li></ul></li><li><p>v-on 事件监听器指令,用于用户交互</p><ul><li>完整：<code>&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</code></li><li>缩写：<code>&lt;a @[event]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;</code></li></ul></li><li><p>条件指令</p><ul><li>v-if</li><li>v-else</li><li>v-else-if</li><li>设置key<ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 保证带key的标签唯一，切换后会被替换</span><br><span class="line">&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>列表指令</p><ul><li>v-for 循环执行</li></ul></li><li><p>v-model 设置数据双向绑定</p></li><li><p>v-text 用于渲染普通文本，相当于ele.innerText</p></li><li><p>v-html 用于渲染html代码，将html代码用于替换</p></li><li><p>v-show 类似于CSS中的<code>display:none</code></p></li></ul><ol start="2"><li>指令使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app-5&quot;&gt;</span><br><span class="line">      &lt;!-- &lt;button v-on:click=&quot;reverseMessage&quot; v-bind:tittle=&quot;提示信息&quot;&gt;反转消息&lt;/button&gt; --&gt;</span><br><span class="line">      &lt;ol v-show=&quot;flag&quot;&gt;</span><br><span class="line">        &lt;li v-for=&quot;todo in todos&quot;&gt;</span><br><span class="line">          &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      &lt;/ol&gt;</span><br><span class="line">      &lt;button v-on:click=&quot;exchange&quot;&gt;切换&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;#app-5&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &apos;Hello Vue.js!&apos;,</span><br><span class="line">      flag:true,</span><br><span class="line">      todos: [</span><br><span class="line">        &#123; text: &apos;学习 JavaScript&apos; &#125;,</span><br><span class="line">        &#123; text: &apos;学习 Vue&apos; &#125;,</span><br><span class="line">        &#123; text: &apos;牛项目&apos; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">  exchange: function () &#123;</span><br><span class="line">  this.flag = !this.flag;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">h1, h2 &#123;</span><br><span class="line">  font-weight: normal;</span><br><span class="line">&#125;</span><br><span class="line">ul &#123;</span><br><span class="line">  list-style-type: none;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">li &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  margin: 0 10px;</span><br><span class="line">&#125;</span><br><span class="line">a &#123;</span><br><span class="line">  color: #42b983;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>vue指令v-for报错：Elements in iteration expect to have ‘v-bind:key’ directives.eslint-plugin-vue</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v-for指令后加上:key=&quot;item&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>修饰符<br>修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><p>指令缩写</p></li></ol><p><em>v-bind</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="line">&lt;a :[key]=&quot;url&quot;&gt; ... &lt;/a&gt;</span><br></pre></td></tr></table></figure><p><em>v-on</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="line">&lt;a @[event]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://cn.vuejs.org/v2/guide/syntax.html#%E6%8C%87%E4%BB%A4" target="_blank" rel="noopener">指令</a></p></blockquote><h1 id="三、Class-与-Style-绑定"><a href="#三、Class-与-Style-绑定" class="headerlink" title="三、Class 与 Style 绑定"></a>三、Class 与 Style 绑定</h1><p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是属性，所以我们可以用 v-bind 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。</p><ol><li><p>对象语法<br>通过绑定class的值动态设置样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组语法<br><code>&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</code></p></li></ol><ol start="3"><li>绑定内联样式-对象语法</li></ol><p>通过绑定style的值动态设置样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: &apos;red&apos;,</span><br><span class="line">  fontSize: 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>绑定内联样式-数组语法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、插值&quot;&gt;&lt;a href=&quot;#一、插值&quot; class=&quot;headerlink&quot; title=&quot;一、插值&quot;&gt;&lt;/a&gt;一、插值&lt;/h1&gt;&lt;p&gt;&lt;em&gt;文本&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    
    <category term="vue" scheme="http://zws6672.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>VUE（二）vue实例</title>
    <link href="http://zws6672.top/2021/01/22/vue-rm-1/"/>
    <id>http://zws6672.top/2021/01/22/vue-rm-1/</id>
    <published>2021-01-22T07:21:03.000Z</published>
    <updated>2021-01-22T15:19:41.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><ol><li>MVVM</li></ol><p>VUE设计参考MVVM，虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示 Vue 实例。那什么是 MVVM 模型？</p><p>它的设计参考后端的MVC模式，MVVM是Model-View-ViewModel的缩写。由于前端开发混合了HTML、CSS和JavaScript，而且页面众多，所以，代码的组织和维护难度其实更加复杂，这就是MVVM出现的原因。</p><ul><li>Model用JS对象表示，存放数据；</li><li>View表示网页，负责显示；</li><li>ViewModel表示绑定，负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。</li></ul><p>使用MVVM框架来实现数据修改，假定视图和模型是绑定的；JS中会将数据存储起来，由于存在绑定关系，所以修改数据就是修改页面。所以，我们只需要关注数据存储即可。</p><ol start="2"><li>起步</li></ol><p>我们可以通过NPM的vue-cli使用vue，也可以通过网页引入vue.js进行练习。存在开发环境与生产环境两个版本，使用步骤如下：</p><ul><li>引入vue.js</li><li>创建Vue实例对象，设置el属性和data属性</li><li>通过模板语法渲染数据</li></ul><p>每个 Vue.js 应用都是通过构造函数 Vue 创建一个 Vue 的根实例来启动的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  // 选项</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>一个 Vue 应用由一个通过 new Vue 创建的根 Vue 实例，以及可选的嵌套的、可复用的组件树组成。<br>一个 todo 应用的组件树如下：</p><ul><li>根实例<ul><li>TodoList<ul><li>TodoItem<ul><li>TodoButtonDelete</li><li>TodoButtonEdit</li></ul></li><li>TodoListFooter<ul><li>TodosButtonClear</li><li>TodoListStatistics</li></ul></li></ul></li></ul></li></ul><p>当一个 Vue 实例被创建时，它将 data 对象中的所有的 属性 加入到 Vue 的响应式系统中。当这些 属性 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p><h1 id="二、-el属性和data属性"><a href="#二、-el属性和data属性" class="headerlink" title="二、 el属性和data属性"></a>二、 el属性和data属性</h1><p>有两个基本的属性需要先了解一下，分别是 el属性和data属性。</p><p>其中，el属性表示Vue实例挂载的元素节点，值可以是 CSS 选择符，或实际 HTML 元素，或返回 HTML 元素的函数；</p><ul><li>Vue会管理el属性命中元素及其后代元素。</li><li>el属性中的参数可以用CSS的选择器，如ID选择器、类选择器等，但是建议使用ID选择器。</li><li>el元素不可以挂载到body标签上，建议挂载到div标签上。</li></ul><p>而data属性存储的是前端的数据。通过模板语法渲染数据，如果后端的数据变化了，前台的页面也会有对应的修改。</p><ul><li>data中定义数据</li><li>data中可以存在复杂类型的数据</li><li>渲染复杂类型数据时，遵守js语法即可</li></ul><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;My first Vue app&lt;/title&gt;</span><br><span class="line">  &lt;!-- 1. 引入vue.js --&gt;</span><br><span class="line">  &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span><br><span class="line">&lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; --&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;!-- 3. 模板语法渲染数据 --&gt;</span><br><span class="line">&#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;p&gt;&#123;&#123; list[0].name&#125;&#125;    &#123;&#123; list[0].phone&#125;&#125;&lt;p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">//2. 创建Vue实例对象，设置el属性和data属性  </span><br><span class="line">var app = new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">message: &apos;Hello Vue!&apos;,</span><br><span class="line">list: [</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;jk&apos;,</span><br><span class="line">phone: 110</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>由上可以知晓，el属性将实例挂载在css中ID为app的元素上；还设置了data，通过模板语法调用后台定义的数据。</p><h1 id="三、-计算属性和侦听属性"><a href="#三、-计算属性和侦听属性" class="headerlink" title="三、 计算属性和侦听属性"></a>三、 计算属性和侦听属性</h1><p>计算属性和侦听属性即 computed与watch，它们都依赖值的变化被调用。</p><ol><li>computed 计算属性</li></ol><p>Vue中的computed属性称为计算属性：</p><ul><li>计算属性允许我们对指定的视图，复杂的值计算。这些值将绑定到依赖项值，只在需要时更新。当computed依赖的属性值发生变化时，计算属性会重新计算；反之，则使用缓存中的属性值。</li><li>简化tempalte里面计算和处理props或$emit的传值</li></ul><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;My first Vue app&lt;/title&gt;</span><br><span class="line">  &lt;!-- 1. 引入vue.js --&gt;</span><br><span class="line">  &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;p&gt;科目  分数&lt;/p&gt;</span><br><span class="line">&lt;p v-for=&quot;item in results&quot;&gt;&#123;&#123;item.name&#125;&#125;  &#123;&#123;item.score&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;总分：&#123;&#123;this.computedAvg &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">//2. 创建Vue实例对象，设置el属性和data属性  </span><br><span class="line">var app = new Vue(&#123;</span><br><span class="line">el: &apos;#app&apos;,</span><br><span class="line">data: &#123;</span><br><span class="line">count:1,</span><br><span class="line">results: [</span><br><span class="line">&#123;name: &apos;english&apos;, score: 70&#125;,</span><br><span class="line">&#123;name: &apos;math&apos;, score: 80&#125;,</span><br><span class="line">&#123;name: &apos;chinese&apos;, score: 90&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">computedAvg: function() &#123;</span><br><span class="line">let sum=0</span><br><span class="line">let rst = this.results;</span><br><span class="line">for (let i=0; i &lt; rst.length; i++) &#123;</span><br><span class="line">sum+=rst[i].score</span><br><span class="line">&#125;</span><br><span class="line">return sum/rst.length</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>如果results中的数据发生变动，计算属性中定义的computedAvg 的返回值也会被修改。</p><p>计算属性的 setter：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">// getter 获取值时触发，计算属性中默认使用get</span><br><span class="line">// setter 设置值时触发</span><br><span class="line">fullName: &#123;</span><br><span class="line">get: function () &#123;</span><br><span class="line">  return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">&#125;,</span><br><span class="line">set: function (newValue) &#123;</span><br><span class="line">  var names = newValue.split(&apos; &apos;)</span><br><span class="line">  this.firstName = names[0]</span><br><span class="line">  this.lastName = names[names.length - 1]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>vm.fullName = &#39;John Doe&#39;</code>的方式调用<code>setter</code>设置值。</p><ol start="2"><li>watch 侦听属性</li></ol><p>watch用于监测一个值的变化，并调用因为变化涉及的方法，可以通过它动态改变状态。但是，在watch中不要使用箭头函数，因为箭头函数中的this是指向当前作用域。</p><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;My first Vue app&lt;/title&gt;</span><br><span class="line">  &lt;!-- 1. 引入vue.js --&gt;</span><br><span class="line">  &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;p&gt;&lt;input type=&quot;number&quot; v-model = &quot;yc&quot;/&gt; 英寸==&gt; 厘米&lt;/P&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123; yc &#125;&#125; 英寸 = &#123;&#123;  this.exchangeYC &#125;&#125; 厘米 &lt;/P&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">//2. 创建Vue实例对象，设置el属性和data属性  </span><br><span class="line">var app = new Vue(&#123;</span><br><span class="line">el: &apos;#app&apos;,</span><br><span class="line">data: &#123;</span><br><span class="line">yc: 0</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">exchangeYC: function() &#123;</span><br><span class="line">return this.yc * 2.54</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">yc: &#123;</span><br><span class="line">// yc值修改后触发</span><br><span class="line">handler(nv, ov) &#123;</span><br><span class="line">// 后台输出值</span><br><span class="line">console.log(ov + &quot;==&gt;&quot; + nv);</span><br><span class="line">&#125;,</span><br><span class="line">immediate: false, //网页加载完后不会立即调用一次</span><br><span class="line">deep: true //会进行深度监听，如果绑定的是变量，内部属性的变动也会触发</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>Computed与Watch的异同：</p><ul><li>Computed<ul><li>需要主动调用</li><li>支持缓存、不支持异步、依赖数据变化才会重新计算</li><li>适合多对一或者一对一</li></ul></li><li>Watch <ul><li>不支持缓存、支持异步、依赖数据变化才会重新计算</li><li>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值</li><li>适合一对多</li></ul></li></ul><h1 id="四、函数"><a href="#四、函数" class="headerlink" title="四、函数"></a>四、函数</h1><ol><li>定义</li></ol><p>VUE支持函数的定义。函数必须在 Vue.js 中的 methods 属性下添加，类似于计算属性（computed），在 Vue.js 中，methods 被命名为方法，是调用对象上下文中的函数，还可以操作对象中包含的数据。</p><p>相关语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 函数定义</span><br><span class="line">add:function(num)&#123;&#125;</span><br><span class="line"></span><br><span class="line">// 传递参数</span><br><span class="line">&lt;button @click=&quot;add(10)&quot;&gt;add&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;My first Vue app&lt;/title&gt;</span><br><span class="line">  &lt;!-- 1. 引入vue.js --&gt;</span><br><span class="line">  &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;p&gt;计数：&#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;button @click=&quot;add(10)&quot;&gt;add&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    //2. 创建Vue实例对象，设置el属性和data属性  </span><br><span class="line">var app = new Vue(&#123;</span><br><span class="line">el: &apos;#app&apos;,</span><br><span class="line">data: &#123;</span><br><span class="line">count:1</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">add: function(num) &#123;</span><br><span class="line">if(num!=&apos;&apos;) &#123;</span><br><span class="line">this.count+=num</span><br><span class="line">&#125; else &#123;</span><br><span class="line">this.count++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>$event 参数</li></ol><p>传递的$event参数都是关于点击鼠标的一些事件和属性</p><ol start="3"><li><code>.native修饰器</code></li></ol><p>在实际开发中经常需要把某个按钮封装成组件，然后反复使用，如何让组件调用构造器里的方法，而不是组件里的方法。就需要用到我们的.native修饰器了。</p><p>add按钮封装成组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//声明btn对象：</span><br><span class="line">var btn=&#123;</span><br><span class="line">template:`&lt;button&gt;组件Add&lt;/button&gt;`    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在构造器里声明：</span><br><span class="line">components:&#123;</span><br><span class="line">&quot;btn&quot;:btn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用.native修饰器来调用构造器里的add方法</span><br><span class="line">&lt;p&gt;&lt;btn @click.native=&quot;add(3)&quot;&gt;&lt;/btn&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、基础&quot;&gt;&lt;a href=&quot;#一、基础&quot; class=&quot;headerlink&quot; title=&quot;一、基础&quot;&gt;&lt;/a&gt;一、基础&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;MVVM&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;VUE设计参考MVVM，虽然没有完全遵循 MVVM 模型，但是 Vue 的</summary>
      
    
    
    
    
    <category term="vue" scheme="http://zws6672.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发（六）线程工具</title>
    <link href="http://zws6672.top/2021/01/18/java-bf-other/"/>
    <id>http://zws6672.top/2021/01/18/java-bf-other/</id>
    <published>2021-01-18T07:29:56.000Z</published>
    <updated>2021-01-18T07:32:14.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、ForkJoinPool（分治线程池）"><a href="#一、ForkJoinPool（分治线程池）" class="headerlink" title="一、ForkJoinPool（分治线程池）"></a>一、ForkJoinPool（分治线程池）</h1><ol><li>概述<blockquote><p>ForkJoinPool的优势在于，可以充分利用多cpu，多核cpu的优势，把一个任务拆分成多个“小任务”，把多个“小任务”放到多个处理器核心上并行执行；当多个“小任务”执行完成之后，再将这些执行结果合并起来即可。</p></blockquote></li></ol><p>ForkJoinPool提供了一个并发处理“分而治之”的框架，让我们能以类似于递归的编程方式获得并发执行的能力。所谓“分而治之“是理清思路和解决问题的一个重要的方法。大到系统架构对功能模块的拆分，小到归并排序的实现，无一不在散发着分而治之的思想。在实现分而治之的算法的时候，我们通常使用递归的方法。递归相当于把大的任务拆成多个小的任务，然后大任务等待多个小的子任务执行完成后，合并子任务的结果。</p><ol start="2"><li>类图</li></ol><p><img src="/image/java/cn/ForkJoinPool.png" alt="ForkJoinPool"></p><p>ForkJoinPool是ExecutorService的实现类，因此是一种特殊的线程池。创建了ForkJoinPool实例之后，就可以调用ForkJoinPool的submit(ForkJoinTask<t> task) 或invoke(ForkJoinTask<t> task)方法来执行指定任务了。</t></t></p><p>其中ForkJoinTask代表一个可以并行、合并的任务。ForkJoinTask是一个抽象类，它还有两个抽象子类：</p><ul><li>RecusiveTask 代表有返回值的任务</li><li>RecusiveAction 代表没有返回值的任务。</li></ul><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class ExecutorsTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        ExecutorsTest.forkJoinPool();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void forkJoinPool()&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool=null;</span><br><span class="line">        try &#123;</span><br><span class="line">            forkJoinPool = new ForkJoinPool();</span><br><span class="line">            Future&lt;Integer&gt; future = forkJoinPool.submit(new MyTask(1,1000));</span><br><span class="line">            System.out.println(&quot;result:&quot;+future.get());</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line">            if(forkJoinPool!=null) &#123;</span><br><span class="line">                forkJoinPool.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyTask extends RecursiveTask&lt;Integer&gt; &#123;</span><br><span class="line">    private final static int NUMS = 100;</span><br><span class="line">    private int st;</span><br><span class="line">    private int end;</span><br><span class="line">    public MyTask(int st,int end)&#123;</span><br><span class="line">        this.st=st;</span><br><span class="line">        this.end=end;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected Integer compute() &#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        if (end-st&lt;=NUMS) &#123;</span><br><span class="line">            for(int i=st; i&lt;=end;i++) &#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+&quot;:&quot;+sum);</span><br><span class="line">            return sum;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int md=(end+st)/2;</span><br><span class="line">            MyTask lf = new MyTask(st, md);</span><br><span class="line">            MyTask rt = new MyTask(md+1, end);</span><br><span class="line">            lf.fork();</span><br><span class="line">            rt.fork();</span><br><span class="line">            return lf.join()+rt.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkJoinPool 主要用来使用分治法(Divide-and-Conquer Algorithm)来解决问题。典型的应用比如快速排序算法。ThreadPoolExecutor虽然也可以执行多个任务，但是它无法在任务中添加子任务，等待子任务完成后再完成该任务。而使用ForkJoinPool时，就能够让其中的线程创建新的任务，并挂起当前的任务，此时线程就能够从队列中选择子任务执行。</p><p>ForkJoinPool分治的关键是fork()和join()方法，fork()用于拆分任务，而join()方法用于合并任务。在ForkJoinPool使用的线程中，会使用一个内部队列来对需要执行的任务以及子任务进行操作来保证它们的执行顺序。但是，ForkJoinPool在分治时会创建大量子任务，消耗过多的系统资源。</p><h1 id="二、线程计数器"><a href="#二、线程计数器" class="headerlink" title="二、线程计数器"></a>二、线程计数器</h1><p>线程中存在计数器，用于设置任务的执行顺序。当子任务执行完成后，线程才能执行。countDownLatch与CyclicBarrier是在java1.5被引入，作为线程计数器。</p><ol><li>CountDownLatch</li></ol><p>CountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。CountDownLatch是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</p><p>CountDownLatch相关源码如下。使用过程如下：</p><ul><li>创建CountDownLatch对象，需要指定线程的数量<ul><li><code>CountDownLatch countDownLatch = new CountDownLatch(3);</code></li></ul></li><li>每当一个线程完成自己的任务后，计数器的值就会减 1 。<ul><li><code>countDownLatch.countDown();</code></li></ul></li><li>当计数器的值变为0时，就表示所有的线程均已经完成了任务，然后就可以恢复等待的线程继续执行了。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//线程计数器</span><br><span class="line">public class CountDownLatch &#123;</span><br><span class="line">。。。</span><br><span class="line">    public CountDownLatch(int count) &#123;</span><br><span class="line">        if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br><span class="line">        this.sync = new Sync(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final Sync sync;</span><br><span class="line"></span><br><span class="line">//使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断</span><br><span class="line">    public void await() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean await(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //线程递减</span><br><span class="line">    public void countDown() &#123;</span><br><span class="line">        sync.releaseShared(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获取线程数</span><br><span class="line">    public long getCount() &#123;</span><br><span class="line">        return sync.getCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch 的内部类Sync继承了AQS，通过CAS实现同步锁，通过同步锁实现CountDownLatch的实现类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//AQS</span><br><span class="line">    private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        private static final long serialVersionUID = 4982264981922014374L;</span><br><span class="line"></span><br><span class="line">        Sync(int count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int getCount() &#123;</span><br><span class="line">            return getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">            return (getState() == 0) ? 1 : -1;</span><br><span class="line">        &#125;</span><br><span class="line">// CAS</span><br><span class="line">        protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">            // Decrement count; signal when transition to zero</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int c = getState();</span><br><span class="line">                if (c == 0)</span><br><span class="line">                    return false;</span><br><span class="line">                int nextc = c-1;</span><br><span class="line">                if (compareAndSetState(c, nextc))</span><br><span class="line">                    return nextc == 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>相关实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class ExecutorsTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        ExecutorsTest.countDownLatch();</span><br><span class="line">    &#125;</span><br><span class="line">/* </span><br><span class="line">输出如下：</span><br><span class="line">等待线程完成</span><br><span class="line">Thread[pool-1-thread-2,5,main]</span><br><span class="line">Thread[pool-1-thread-1,5,main]</span><br><span class="line">主线程完成:Thread[main,5,main]</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">    public static void countDownLatch() &#123;</span><br><span class="line">        CountDownLatch latch = new CountDownLatch(2);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(2);</span><br><span class="line">        executorService.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                    System.out.println(Thread.currentThread());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    System.out.println(Thread.currentThread());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;等待线程完成&quot;);</span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(&quot;主线程完成:&quot;+Thread.currentThread());</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>CyclicBarrier</li></ol><p>CyclicBarrier意为可循环利用的屏障，作用是让线程等待，所有子线程都完成后才会继续下一步行动。CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。</p><p>相关方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 构造方法</span><br><span class="line">// parties  是线程个数</span><br><span class="line">// barrierAction 最后一个到达线程要执行的任务</span><br><span class="line">public CyclicBarrier(int parties)</span><br><span class="line">public CyclicBarrier(int parties, Runnable barrierAction)</span><br><span class="line"></span><br><span class="line">//  await() 表示已到达栅栏</span><br><span class="line">//BrokenBarrierException  表示栅格被破坏，即其它线程await被中断或延时</span><br><span class="line">public int await() throws InterruptedException, BrokenBarrierException</span><br><span class="line">public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException</span><br></pre></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class ExecutorsTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        ExecutorsTest.cyclicBarrier();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void cyclicBarrier()&#123;</span><br><span class="line">        CyclicBarrier barrier = new CyclicBarrier(2, new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;线程全部到位&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        CBThread cbThread = new CBThread(barrier);</span><br><span class="line">        cbThread.start();</span><br><span class="line">        CBThread cbThread1 = new CBThread(barrier);</span><br><span class="line">        cbThread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CBThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    CyclicBarrier barrier;</span><br><span class="line">    public CBThread(CyclicBarrier barrier) &#123;</span><br><span class="line">        this.barrier = barrier;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(20);</span><br><span class="line">            System.out.println(getName()+&quot;抵达栅格1&quot;);</span><br><span class="line">            barrier.await();//等待其它线程抵达</span><br><span class="line">            System.out.println(getName()+&quot;冲破栅格1&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(getName()+&quot;抵达栅格2&quot;);</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">            barrier.await();</span><br><span class="line">            System.out.println(getName()+&quot;冲破栅格2&quot;);</span><br><span class="line">        &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch和CyclicBarrier区别：</p><ul><li>countDownLatch是一个计数器，线程完成一个记录一个，计数器递减，只能只用一次</li><li>CyclicBarrier的计数器更像一个阀门，需要所有线程都到达，然后继续执行，计数器递增，提供reset功能，可以多次使用</li></ul><h1 id="三、Exchanger（线程通讯）"><a href="#三、Exchanger（线程通讯）" class="headerlink" title="三、Exchanger（线程通讯）"></a>三、Exchanger（线程通讯）</h1><p>Exchanger 是 JDK 1.5 开始提供的一个用于两个工作线程之间交换数据的封装工具类，简单说就是一个线程在完成一定的事务后想与另一个线程交换数据，则第一个先拿出数据的线程会一直等待第二个线程，直到第二个线程拿着数据到来时才能彼此交换对应数据。</p><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class ExecutorsTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        ExecutorsTest.exchanger();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void exchanger() &#123;</span><br><span class="line">/*</span><br><span class="line">输出：</span><br><span class="line">        Thread-1 交换前：38</span><br><span class="line">        Thread-0 交换前：55</span><br><span class="line">        Thread-1 交换后：55</span><br><span class="line">        Thread-0 交换后：38</span><br><span class="line">*/</span><br><span class="line">        Exchanger exchanger = new Exchanger();</span><br><span class="line">        ExchangerTest ex = new ExchangerTest(exchanger);</span><br><span class="line">        ExchangerTest ex1 = new ExchangerTest(exchanger);</span><br><span class="line">        ex.start();</span><br><span class="line">        ex1.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ExchangerTest extends Thread &#123;</span><br><span class="line">    private Exchanger exchanger;</span><br><span class="line">    public ExchangerTest(Exchanger exchanger) &#123;</span><br><span class="line">        this.exchanger = exchanger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int data = (int) (Math.random()*1000);</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(getName()+&quot; 交换前：&quot;+data);</span><br><span class="line">            data = (int) exchanger.exchange(data);</span><br><span class="line">            System.out.println(getName()+&quot; 交换后：&quot;+data);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、Semaphore（信号量）"><a href="#四、Semaphore（信号量）" class="headerlink" title="四、Semaphore（信号量）"></a>四、Semaphore（信号量）</h1><p>Semaphore称之为信号量，可以控制访问资源的线程数。Semaphore是一个线程同步的辅助类，可以维护当前访问自身的线程个数，并提供了同步机制。使用Semaphore可以控制同时访问资源的线程个数，例如，实现一个文件允许的并发访问数。</p><p>Semaphore的主要方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">acquire()：获取一个令牌，在获取到令牌、或者被其他线程调用中断之前线程一直处于阻塞状态。</span><br><span class="line">acquire(int permits)：获取一个令牌，在获取到令牌、或者被其他线程调用中断、或超时之前线程一直处于阻塞状态。</span><br><span class="line">acquireUninterruptibly()：获取一个令牌，在获取到令牌之前线程一直处于阻塞状态（忽略中断）。</span><br><span class="line">    </span><br><span class="line">tryAcquire()：尝试获得令牌，返回获取令牌成功或失败，不阻塞线程</span><br><span class="line">tryAcquire(long timeout, TimeUnit unit)：尝试获得令牌，在超时时间内循环尝试获取，直到尝试获取成功或超时返回，不阻塞线程。</span><br><span class="line">​</span><br><span class="line">release()：释放一个令牌，唤醒一个获取令牌不成功的阻塞线程。</span><br><span class="line">​</span><br><span class="line">hasQueuedThreads()：等待队列里是否还存在等待线程。</span><br><span class="line">getQueueLength()：获取等待队列里阻塞的线程数。</span><br><span class="line">​</span><br><span class="line">drainPermits()：清空令牌把可用令牌数置为0，返回清空令牌的数量。</span><br><span class="line">​</span><br><span class="line">availablePermits()：返回可用的令牌数量。</span><br></pre></td></tr></table></figure><p>使用场景：</p><ul><li>数据库连接池限制</li><li>选课限流</li></ul><p>使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class ExecutorsTest &#123;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        ExecutorsTest.semaphore();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void semaphore() &#123;</span><br><span class="line">        Semaphore semaphore = new Semaphore(4);</span><br><span class="line">        for (int i=0; i&lt;30; i++) &#123;</span><br><span class="line">            Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line"></span><br><span class="line">                    try &#123;</span><br><span class="line">// 剩余令牌为0</span><br><span class="line">                        if (semaphore.availablePermits()==0) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread() + &quot;进入失败，网站访问量过多&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">// 两秒内尝试获取令牌</span><br><span class="line">                        semaphore.tryAcquire(2,TimeUnit.SECONDS);</span><br><span class="line">                        System.out.println(Thread.currentThread()+&quot; 进入选课&quot;);</span><br><span class="line">                        Thread.sleep(new Random().nextInt(5000));</span><br><span class="line">                        System.out.println(Thread.currentThread()+&quot; 离开选课&quot;);</span><br><span class="line">// 释放令牌</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、参考文档"><a href="#五、参考文档" class="headerlink" title="五、参考文档"></a>五、参考文档</h1><blockquote><p><a href="https://blog.csdn.net/tyrroo/article/details/81390202" target="_blank" rel="noopener">Fork/Join框架基本使用</a><br><a href="https://blog.csdn.net/qq_39241239/article/details/87030142" target="_blank" rel="noopener">深入理解CyclicBarrier原理</a><br><a href="https://blog.csdn.net/longgeqiaojie304/article/details/91127730" target="_blank" rel="noopener">Semaphore</a><br><a href="https://blog.csdn.net/a303549861/article/details/90666982" target="_blank" rel="noopener">CountDownLatch</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、ForkJoinPool（分治线程池）&quot;&gt;&lt;a href=&quot;#一、ForkJoinPool（分治线程池）&quot; class=&quot;headerlink&quot; title=&quot;一、ForkJoinPool（分治线程池）&quot;&gt;&lt;/a&gt;一、ForkJoinPool（分治线程池）&lt;/</summary>
      
    
    
    
    
    <category term="并发" scheme="http://zws6672.top/tags/并发/"/>
    
  </entry>
  
</feed>

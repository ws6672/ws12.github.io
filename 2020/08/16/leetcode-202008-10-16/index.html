<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一些关于技术的碎语"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>leetcode-202008-10-16 | 微言术语</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">leetcode-202008-10-16</h1><a id="logo" href="/.">微言术语</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">leetcode-202008-10-16</h1><div class="post-meta"><a href="/2020/08/16/leetcode-202008-10-16/#comments" class="comment-count"></a><p><span class="date">Aug 16, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h3 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a><a href="https://leetcode-cn.com/problems/count-and-say/submissions/" target="_blank" rel="noopener">38. 外观数列</a></h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。<br>注意：整数序列中的每一项将表示为一个字符串。</p>
</blockquote>
<p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br><span class="line">第一项是数字 1</span><br><span class="line"></span><br><span class="line">描述前一项，这个数是 1 即 “一个 1 ”，记作 11</span><br><span class="line"></span><br><span class="line">描述前一项，这个数是 11 即 “两个 1 ” ，记作 21</span><br><span class="line"></span><br><span class="line">描述前一项，这个数是 21 即 “一个 2 一个 1 ” ，记作 1211</span><br><span class="line"></span><br><span class="line">描述前一项，这个数是 1211 即 “一个 1 一个 2 两个 1 ” ，记作 111221</span><br></pre></td></tr></table></figure>

<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: &quot;1&quot;</span><br><span class="line">解释：这是一个基本样例。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;1211&quot;</span><br><span class="line">解释：当 n = 3 时，序列是 &quot;21&quot;，其中我们有 &quot;2&quot; 和 &quot;1&quot; 两组，&quot;2&quot; 可以读作 &quot;12&quot;，也就是出现频次 = 1 而 值 = 2；类似 &quot;1&quot; 可以读作 &quot;11&quot;。所以答案是 &quot;12&quot; 和 &quot;11&quot; 组合在一起，也就是 &quot;1211&quot;。</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong><br>递归, 使用<code>StringBuilder</code>可以提高效率</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String countAndSay(int n) &#123;</span><br><span class="line">        if(n==1) &#123;</span><br><span class="line">            return &quot;1&quot;;</span><br><span class="line">        &#125; else if(n==2) &#123;</span><br><span class="line">            return &quot;11&quot;;</span><br><span class="line">        &#125; else if(n==3) &#123;</span><br><span class="line">            return &quot;21&quot;;</span><br><span class="line">        &#125; else if(n==4) &#123;</span><br><span class="line">            return &quot;1211&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String temp = countAndSay(n-1);</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            int i=1,s=0;</span><br><span class="line">            do &#123;</span><br><span class="line">                if(temp.charAt(i) != temp.charAt(i-1)) &#123;</span><br><span class="line">                    sb.append(i-s).append(temp.charAt(s));</span><br><span class="line">                    s=i;</span><br><span class="line">                &#125;</span><br><span class="line">                if(i == temp.length()-1) &#123;</span><br><span class="line">                    sb.append(i-s+1).append(temp.charAt(s));</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; while(i&lt;temp.length());</span><br><span class="line">            return sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93.复原IP地址</a></h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。<br>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。<br>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:192.168@1.1" target="_blank" rel="noopener">192.168@1.1</a>“ 是 无效的 IP 地址。 </p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;25525511135&quot;</span><br><span class="line">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;0000&quot;</span><br><span class="line">输出：[&quot;0.0.0.0&quot;]</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;1111&quot;</span><br><span class="line">输出：[&quot;1.1.1.1&quot;]</span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;010010&quot;</span><br><span class="line">输出：[&quot;0.10.0.10&quot;,&quot;0.100.1.0&quot;]</span><br></pre></td></tr></table></figure>

<p>示例 5：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;101023&quot;</span><br><span class="line">输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>暴力循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">            List&lt;String&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">            StringBuilder ip = new StringBuilder();</span><br><span class="line"></span><br><span class="line">            for (int a = 1; a &lt; 4; a++) &#123;</span><br><span class="line">                for (int b = 1; b &lt; 4; b++) &#123;</span><br><span class="line">                    for (int c = 1; c &lt; 4; c++) &#123;</span><br><span class="line">                        for (int d = 1; d &lt; 4; d++) &#123;</span><br><span class="line">                            /*</span><br><span class="line">                            * 1、保障下面subString不会越界</span><br><span class="line">                            * 2、保障截取的字符串与输入字符串长度相同</span><br><span class="line">                            * //1、2比较好理解，3比较有意思</span><br><span class="line">                            * 3、不能保障截取的字符串转成int后与输入字符串长度相同</span><br><span class="line">                            * 如：字符串010010，a=1，b=1，c=1，d=3，对应字符串0，1，0，010</span><br><span class="line">                            * 转成int后seg1=0，seg2=1，seg3=0，seg4=10</span><br><span class="line">                            * //所以需要下面这处判断if (ip.length() == s.length() + 3)</span><br><span class="line">                            */</span><br><span class="line">                            if (a + b + c + d == s.length()) &#123;</span><br><span class="line">                                int seg1 = Integer.parseInt(s.substring(0, a));</span><br><span class="line">                                int seg2 = Integer.parseInt(s.substring(a, a + b));</span><br><span class="line">                                int seg3 = Integer.parseInt(s.substring(a + b, a + b + c));</span><br><span class="line">                                int seg4 = Integer.parseInt(s.substring(a + b + c, a + b + c + d));</span><br><span class="line">                                // 四个段数值满足0~255</span><br><span class="line">                                if (seg1 &lt;= 255 &amp;&amp; seg2 &lt;= 255 &amp;&amp; seg3 &lt;= 255 &amp;&amp; seg4 &lt;= 255) &#123;</span><br><span class="line">                                    ip.append(seg1).append(&quot;.&quot;).append(seg2).append(&quot;.&quot;).</span><br><span class="line">                                            append(seg3).append(&quot;.&quot;).append(seg4);</span><br><span class="line">                                    // 保障截取的字符串转成int后与输入字符串长度相同</span><br><span class="line">                                    if (ip.length() == s.length() + 3) &#123;</span><br><span class="line">                                        result.add(ip.toString());</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    ip.delete(0, ip.length());</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案</p>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,2,1,-4], target = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：<br>3 &lt;= nums.length &lt;= 10^3<br>-10^3 &lt;= nums[i] &lt;= 10^3<br>-10^4 &lt;= target &lt;= 10^</p>
</blockquote>
<p><strong><em>解法</em></strong></p>
<p>我的解法是通过双指针快速判断：与目标数距离最小的三数之和，只是在前边<code>三数之和</code>的问题上多了一个距离判断而已。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int threeSumClosest(int[] nums, int target) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        boolean first_flag = true;</span><br><span class="line">        int range=0,result=0;</span><br><span class="line"></span><br><span class="line">        for (int lf=0; lf&lt;nums.length-2; lf++) &#123;</span><br><span class="line">            if(lf&gt;0&amp;&amp;nums[lf]==nums[lf-1]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            int md = lf+1, rt = nums.length-1;</span><br><span class="line"></span><br><span class="line">            while(md&lt;rt) &#123;</span><br><span class="line">                int sum = nums[lf]+nums[md]+nums[rt];</span><br><span class="line"></span><br><span class="line">                int temp = Math.abs(target-sum);</span><br><span class="line">                if (temp == 0) &#123;</span><br><span class="line">                    return sum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if(first_flag) &#123;</span><br><span class="line">                    first_flag = !first_flag;</span><br><span class="line">                    range = temp;</span><br><span class="line">                    result = sum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (temp &lt;range) &#123;</span><br><span class="line">                    range = temp;</span><br><span class="line">                    result = sum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if(sum-target&lt;0) &#123;</span><br><span class="line">                    while(md &lt; rt &amp;&amp; nums[md] == nums[++md]);</span><br><span class="line">                &#125; else if(sum-target&gt;0) &#123;</span><br><span class="line">                    while(md &lt; rt &amp;&amp; nums[rt] == nums[--rt]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：<br>0 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 400</p>
</blockquote>
<p><strong><em>解法</em></strong></p>
<blockquote>
<p>标签：动态规划<br>动态规划方程：dp[n] = MAX( dp[n-1], dp[n-2] + num )<br>由于不可以在相邻的房屋闯入，所以在当前位置 n 房屋可盗窃的最大值，要么就是 n-1 房屋可盗窃的最大值，要么就是 n-2 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值<br>举例来说：1 号房间可盗窃最大值为 33 即为 dp[1]=3，2 号房间可盗窃最大值为 44 即为 dp[2]=4，3 号房间自身的值为 22 即为 num=2，那么 dp[3] = MAX( dp[2], dp[1] + num ) = MAX(4, 3+2) = 5，3 号房间可盗窃最大值为 55<br>时间复杂度：O(n)O(n)，nn 为数组长度</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int rob(int[] nums) &#123;</span><br><span class="line">        int[] dp = new int[nums.length + 2];</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i + 2] = Math.max(dp[i] + nums[i], dp[i + 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[nums.length + 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><blockquote>
<p>动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果 [1]  。 [2] </p>
</blockquote>
<p>动态规划是把一个大问题拆解成一堆小问题，但高效的关键是”小问题“ 可以被重复调用。</p>
<h3 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：答案中不可以包含重复的四元组。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong><em>解法</em></strong><br>和三数之和类似，使用排序+双指针，在外面多嵌套了一层循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        int length = nums.length;</span><br><span class="line">        if(nums.length&lt;4) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        if(target&lt;nums[0]+nums[1]+nums[2]+nums[3]||target&gt;nums[length-1]+nums[length-2]+nums[length-3]+nums[length-4]) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;nums.length-3; i++) &#123;</span><br><span class="line">            if(i&gt;0&amp;&amp;nums[i] == nums[i-1]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(target&lt;nums[i]+nums[i+1]+nums[i+2]+nums[i+3]||target&gt;nums[i]+nums[length-1]+nums[length-2]+nums[length-3]) &#123;</span><br><span class="line">               continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for(int j=i+1; j&lt;nums.length-2; j++) &#123;</span><br><span class="line"></span><br><span class="line">                if (j&gt;i+1&amp;&amp;nums[j] == nums[j-1]) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                int md = j+1,rf=nums.length-1;</span><br><span class="line"></span><br><span class="line">                while(md&lt;rf) &#123;</span><br><span class="line">                    int temp =  target - (nums[i]+nums[j]+nums[md]+nums[rf]);</span><br><span class="line">                    if(temp&lt;0) &#123;</span><br><span class="line">                        while(md&lt;rf &amp;&amp; nums[rf]==nums[--rf]);</span><br><span class="line">                    &#125; else if(temp&gt;0) &#123;</span><br><span class="line">                        while(md&lt;rf &amp;&amp; nums[md]==nums[++md]);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        result.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums[i], nums[j], nums[md], nums[rf])));</span><br><span class="line">                        while(md &lt; rf &amp;&amp; nums[md] == nums[++md]);</span><br><span class="line">                        while(md &lt; rf &amp;&amp; nums[rf] == nums[--rf]);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二进制求和"><a href="#二进制求和" class="headerlink" title="二进制求和"></a>二进制求和</h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你两个二进制字符串，返回它们的和（用二进制表示）。</span><br><span class="line"></span><br><span class="line">输入为 非空 字符串且只包含数字 1 和 0。</span><br></pre></td></tr></table></figure>



<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">输出: &quot;100&quot;</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">输出: &quot;10101&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：<br>每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。<br>1 &lt;= a.length, b.length &lt;= 10^4<br>字符串如果不是 “0” ，就都不含前导零。</p>
</blockquote>
<p><strong><em>解法</em></strong><br>字符串从末尾遍历，两字符串不等补0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String addBinary(String a, String b) &#123;</span><br><span class="line">        // 进位</span><br><span class="line">        int ca=0;</span><br><span class="line">        StringBuffer res = new StringBuffer();</span><br><span class="line">        </span><br><span class="line">        for(int i=a.length()-1, j=b.length()-1; i&gt;=0||j&gt;=0; i--,j--) &#123;</span><br><span class="line">            int sum=ca;</span><br><span class="line">            sum+= i&gt;=0?a.charAt(i)-&apos;0&apos;:0;</span><br><span class="line">            sum+= j&gt;=0?b.charAt(j)-&apos;0&apos;:0;</span><br><span class="line">            res.append(sum%2);</span><br><span class="line">            ca = sum/2;</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(ca==1?ca:&quot;&quot;);</span><br><span class="line">        return res.reverse().toString();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">盛最多水的容器</a></h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
</blockquote>
<p><img src="/image/leetcode/container-with-most-water.png" alt="container-with-most-water"></p>
<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>使用双指针算法（lf、rt是左右指针的下标）</p>
<ul>
<li>初始化后，左右指针中小的值向内侧靠拢（新的值需要大于旧值）</li>
<li>指针定位后，重新计算面积，比较前两次的值</li>
<li>重复以上操作（lf&lt;rt）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxArea(int[] height) &#123;</span><br><span class="line">        int lf=0, rt=height.length-1;</span><br><span class="line">		// 参数处理</span><br><span class="line">        if(height==null || height.length &lt;2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int result = (height[lf]&gt;height[rt]?height[rt]:height[lf])*(rt-lf);</span><br><span class="line"></span><br><span class="line">        while(lf&lt;rt) &#123;</span><br><span class="line">            int templ = lf, tempr = rt;</span><br><span class="line">            if(height[lf]&lt;height[rt]) &#123;</span><br><span class="line">                while(lf&lt;rt&amp;&amp;height[++lf]&lt;=height[templ]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                while(lf&lt;rt&amp;&amp;height[--rt]&lt;=height[tempr]);</span><br><span class="line">            &#125;</span><br><span class="line">            int temp = (height[lf]&gt;height[rt]?height[rt]:height[lf])*(rt-lf);</span><br><span class="line">            result = result&lt;temp?temp:result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">删除排序数组中的重复项</a></h3><blockquote>
<p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
</blockquote>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p>示例 2:.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>双指针</p>
<ul>
<li>初始化</li>
<li>值重复。指针（j）不变</li>
<li>值不重复。如果(i!=j),nums[j]=nums[i];j++</li>
</ul>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        if(nums.length&lt;2) &#123;</span><br><span class="line">            return nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        int i=1,j=1;</span><br><span class="line">        for(;i&lt;nums.length;i++) &#123;</span><br><span class="line">            if(nums[i]!=nums[i-1] ) &#123;</span><br><span class="line">                if(j!=i) &#123;</span><br><span class="line">                    nums[j]=nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">爬楼梯</a></h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>

<p><strong><em>解法</em></strong></p>
<p>爬楼梯，将一个大的问题拆分成一个个小问题处理。例如，爬到五阶楼梯分解如下：</p>
<p>由于每次可能爬 1 或 2 个台阶，所以第五阶的上一阶必定是第三或第四；而第三的上一阶必定是第二或第一，以此类推。</p>
<p>5 = 4 3<br>  = 2*()+2</p>
<ul>
<li>五<ul>
<li>三<ul>
<li>二<ul>
<li>一</li>
<li>零</li>
</ul>
</li>
<li>一</li>
</ul>
</li>
<li>四<ul>
<li>三<ul>
<li>二<ul>
<li>一</li>
<li>零</li>
</ul>
</li>
</ul>
</li>
<li>二<ul>
<li>一</li>
<li>零</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>该规律符合斐波那契数列：f(x)=f(x−1)+f(x−2)<br>代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 递归，超出时间限制</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int climbStairs(int n) &#123;</span><br><span class="line">        if(n==0) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else if(n==1) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return climbStairs(n-1)+climbStairs(n-2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 动态规划，分解递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int climbStairs(int n) &#123;</span><br><span class="line">       if(n==0||n==1) &#123;</span><br><span class="line">           return 1;</span><br><span class="line">       &#125;</span><br><span class="line">       int[]result = new int[n+1];</span><br><span class="line">       result[0]=1;</span><br><span class="line">       result[1]=1;</span><br><span class="line">       for(int i=2; i&lt;result.length; i++) &#123;</span><br><span class="line">           result[i]=result[i-1]+result[i-2];</span><br><span class="line">       &#125;</span><br><span class="line">       return result[result.length-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number" target="_blank" rel="noopener">电话号码的字母组合</a></h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
</blockquote>
<p><img src="/image/leetcode/letter-combinations-of-a-phone-number.png" alt="letter-combinations-of-a-phone-number"></p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>采用递归，运行效率低.</p>
<p><img src="/image/leetcode/letter-combinations-of-a-phone-number-2.png" alt="letter-combinations-of-a-phone-number"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    int[]rt;</span><br><span class="line">    char[]chars;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">        List&lt;String&gt; lstr = new ArrayList&lt;String&gt;();</span><br><span class="line">        if(digits==null || digits.equals(&quot;&quot;)) &#123;</span><br><span class="line">            return lstr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //初始化边界</span><br><span class="line">        rt = new int[]&#123;-1,-1,2,5,8,11,14,18,21,25&#125;;</span><br><span class="line"></span><br><span class="line">        //设置字母</span><br><span class="line">        chars= new char[26];</span><br><span class="line">        char temp = &apos;a&apos;;</span><br><span class="line">        for(int i=0;i&lt;chars.length;i++) &#123;</span><br><span class="line">            chars[i] +=temp;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        for(int i=0; i&lt;digits.length(); i++) &#123;</span><br><span class="line">            ids.add(digits.charAt(i)-&apos;0&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = get(ids);</span><br><span class="line">//        System.out.println(list);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; get(List&lt;Integer&gt; ids) &#123;</span><br><span class="line">        if(ids.size()&gt;0) &#123;</span><br><span class="line">            int temp = ids.remove(0);</span><br><span class="line">            List&lt;String&gt; list = get(ids);</span><br><span class="line">            List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">            for(int i=rt[temp]; i&gt;rt[temp-1]; i--) &#123;</span><br><span class="line">                if (list.size()&gt;0) &#123;</span><br><span class="line">                    for(String str: list) &#123;</span><br><span class="line">                        result.add(chars[i]+str);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    result.add(chars[i]+&quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new ArrayList&lt;String&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计算质数"><a href="#计算质数" class="headerlink" title="计算质数"></a><a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener">计算质数</a></h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>统计所有小于非负整数 n 的质数的数量。</p>
</blockquote>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 4</span><br><span class="line">解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>厄拉多塞筛法</p>
<ul>
<li>核心思想是：质数的倍数一定不是质数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">        public int countPrimes(int n) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        boolean[] b = new boolean[n];   // 初始化默认值都为 false，为质数标记</span><br><span class="line">        if(2 &lt; n) result++; // 如果大于 2 则一定拥有 2 这个质数</span><br><span class="line">        </span><br><span class="line">        for(int i = 3; i &lt; n; i += 2)&#123;  // 从 3 开始遍历，且只遍历奇数</span><br><span class="line">            if(!b[i])&#123;  // 是质数</span><br><span class="line">                for(int j = 3; i * j &lt; n; j += 2)&#123;</span><br><span class="line">                    b[i * j] = true;    // 将当前质数的奇数倍都设置成非质数标记 true</span><br><span class="line">                &#125;</span><br><span class="line">                result++;   // 质数个数 +1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>f给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
</blockquote>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p>示例 4:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p>示例 5:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong><br>遍历，比较</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        if(s == null|| s.equals(&quot;&quot;)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if(s.length()%2 ==1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        map.put(&apos;)&apos;, 0);</span><br><span class="line">        map.put(&apos;&#125;&apos;, 1);</span><br><span class="line">        map.put(&apos;]&apos;, 2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Integer[]res = new Integer[s.length()/2];</span><br><span class="line"></span><br><span class="line">        int leng = 0;</span><br><span class="line">        for (char cr: s.toCharArray()) &#123;</span><br><span class="line">            if (cr==&apos;(&apos;||cr==&apos;&#123;&apos;||cr==&apos;[&apos;) &#123;</span><br><span class="line">                if (cr==&apos;(&apos; &amp;&amp; leng&lt;res.length) &#123;</span><br><span class="line">                    res[leng++]=0;</span><br><span class="line">                &#125; else if (cr==&apos;&#123;&apos; &amp;&amp; leng&lt;res.length) &#123;</span><br><span class="line">                    res[leng++]=1;</span><br><span class="line">                &#125; else if (cr==&apos;[&apos; &amp;&amp; leng&lt;res.length) &#123;</span><br><span class="line">                    res[leng++]=2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (leng==0) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125; else if(!res[--leng].equals(map.get(cr))) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return leng&gt;0?false:true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[</span><br><span class="line">       &quot;( (()))&quot;,</span><br><span class="line">       &quot;( ()())&quot;,</span><br><span class="line">       &quot;( ())()&quot;,</span><br><span class="line">       &quot;( )(())&quot;,</span><br><span class="line">       &quot;( )()()&quot;</span><br><span class="line">     ]</span><br></pre></td></tr></table></figure>

<p><strong><em>错误题解</em></strong><br>输出组合有一定顺序，无法通过测试<br><img src="/image/leetcode/generate-parentheses.png" alt="generate-parentheses"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   public boolean test(String str) &#123;</span><br><span class="line">        char temp = &apos;)&apos;;</span><br><span class="line">        for(char cr: str.toCharArray()) &#123;</span><br><span class="line">            if(cr == temp) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               temp = cr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        List&lt;String&gt; ret = new ArrayList&lt;String&gt;();</span><br><span class="line">        if(n==1) &#123;</span><br><span class="line">            ret.add(&quot;()&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            List&lt;String&gt; list = generateParenthesis(n-1);</span><br><span class="line">            for (String str: list) &#123;</span><br><span class="line">                ret.add(&apos;(&apos;+str+&apos;)&apos;);</span><br><span class="line">                </span><br><span class="line">                ret.add(str+&quot;()&quot;);</span><br><span class="line">                if (!test(str)) &#123;</span><br><span class="line">                    ret.add(&quot;()&quot;+str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>其它题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        List&lt;String&gt; resultList = new ArrayList&lt;&gt;();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return resultList;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(n, n, &quot;&quot;, resultList);</span><br><span class="line">        return resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param currLeft   剩下多少个“(”</span><br><span class="line">     * @param currRight  剩下多少个“)”</span><br><span class="line">     * @param currStr    当前记录字符串</span><br><span class="line">     * @param resultList 结果合集</span><br><span class="line">     **/</span><br><span class="line">    private void dfs(int currLeft, int currRight, String currStr, List&lt;String&gt; resultList) &#123;</span><br><span class="line"></span><br><span class="line">        if (currLeft == 0) &#123;</span><br><span class="line">            if (currRight == 0) &#123;</span><br><span class="line">                resultList.add(currStr);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dfs(currLeft, currRight - 1, currStr + &quot;)&quot;, resultList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dfs(currLeft - 1, currRight, currStr + &quot;(&quot;, resultList);</span><br><span class="line">            if (currRight &gt; currLeft) &#123;</span><br><span class="line">                dfs(currLeft, currRight - 1, currStr + &quot;)&quot;, resultList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><blockquote><p>原文作者: 古城烟雨</p><p>原文链接: <a href="http://zws6672.top/2020/08/16/leetcode-202008-10-16/">http://zws6672.top/2020/08/16/leetcode-202008-10-16/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/leetcode/">leetcode</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/08/17/springboot-2/" class="pre">springboot（二）配置与启动</a><a href="/2020/08/14/elasticsearch-7/" class="next">ES（七）处理人类语言——文本特征抽取</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#38-外观数列"><span class="toc-text">38. 外观数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#93-复原IP地址"><span class="toc-text">93.复原IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最接近的三数之和"><span class="toc-text">最接近的三数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打家劫舍"><span class="toc-text">打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#动态规划"><span class="toc-text">动态规划</span></a></li></ol></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#四数之和"><span class="toc-text">四数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二进制求和"><span class="toc-text">二进制求和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#盛最多水的容器"><span class="toc-text">盛最多水的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除排序数组中的重复项"><span class="toc-text">删除排序数组中的重复项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#爬楼梯"><span class="toc-text">爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#电话号码的字母组合"><span class="toc-text">电话号码的字母组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计算质数"><span class="toc-text">计算质数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-有效的括号"><span class="toc-text">20. 有效的括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-括号生成"><span class="toc-text">22. 括号生成</span></a></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/fmi-daccosim/">基于FMI标准的仿真软件————Daccosim</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/vue_add_method/">vue_add_method</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/test/">test</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/springboot-1/">springboot（一）入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/26/jdk-bytecodeEngine/">虚拟机字节码执行引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/15/jdk-cload/">虚拟机类加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/14/jdk-classesFileStruct/">深入理解Java虚拟机——类文件结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/04/springboot-aop/">SpringBoot 使用 AOP（面向切面编程）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/30/mysql-lock/">mysql 引擎的行锁与表锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/29/design-structure-eg/">结构型模式——实例</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/devops/" style="font-size: 15px;">devops</a> <a href="/tags/neo4j/" style="font-size: 15px;">neo4j</a> <a href="/tags/CI/" style="font-size: 15px;">CI</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/oracle/" style="font-size: 15px;">oracle</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/系统/" style="font-size: 15px;">系统</a> <a href="/tags/博客搭建/" style="font-size: 15px;">博客搭建</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/ms/" style="font-size: 15px;">ms</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/运维/" style="font-size: 15px;">运维</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/javaweb/" style="font-size: 15px;">javaweb</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/微服务/" style="font-size: 15px;">微服务</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/elasticsearch/" style="font-size: 15px;">elasticsearch</a> <a href="/tags/fmi/" style="font-size: 15px;">fmi</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/nk/" style="font-size: 15px;">nk</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://juejin.im/" title="掘金" target="_blank">掘金</a><ul></ul><a href="https://www.cnblogs.com/" title="博客园" target="_blank">博客园</a><ul></ul><a href="https://www.infoq.cn/" title="info" target="_blank">info</a><ul></ul><a href="https://www.ibm.com/" title="ibm" target="_blank">ibm</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">古城烟雨.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>
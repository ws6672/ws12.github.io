<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一些关于技术的碎语"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>leetcode-201019-201030 | 微言术语</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">leetcode-201019-201030</h1><a id="logo" href="/.">微言术语</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">leetcode-201019-201030</h1><div class="post-meta"><a href="/2020/11/02/leetcode-201019-201030/#comments" class="comment-count"></a><p><span class="date">Nov 02, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h3 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a href="https://leetcode-cn.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">227. 基本计算器 II</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">实现一个基本的计算器来计算一个简单的字符串表达式的值。</span><br><span class="line"></span><br><span class="line">字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;3+2*2&quot;</span><br><span class="line">输出: 7</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot; 3/2 &quot;</span><br><span class="line">输出: 1</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot; 3+5 / 2 &quot;</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int calculate(String s) &#123;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        return core(s.toCharArray());</span><br><span class="line">    &#125;</span><br><span class="line">    //全局索引</span><br><span class="line">    private int i = 0;</span><br><span class="line">    private int core(char[] chs)&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        int num = 0;</span><br><span class="line">        //核心</span><br><span class="line">        char operation = &apos;+&apos;;</span><br><span class="line">        for (; i &lt; chs.length; i++) &#123;</span><br><span class="line">            if(chs[i]==&apos; &apos;)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (Character.isDigit(chs[i])) &#123;</span><br><span class="line">                num = num * 10 + (chs[i] - &apos;0&apos;);</span><br><span class="line">            &#125; else if (chs[i] == &apos;(&apos;) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                num = core(chs);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else if (chs[i] == &apos;)&apos;) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //i ==chs.length-1 是为了处理最后一个数字</span><br><span class="line">            if (!Character.isDigit(chs[i]) || i &gt;= chs.length - 1) &#123;</span><br><span class="line">                //遇到加减直接压栈</span><br><span class="line">                if (operation == &apos;+&apos;) &#123;</span><br><span class="line">                    stack.push(num);</span><br><span class="line">                &#125; else if (operation == &apos;-&apos;) &#123;</span><br><span class="line">                    stack.push(-num);</span><br><span class="line">                    //遇到乘除得先计算</span><br><span class="line">                &#125; else if (operation == &apos;*&apos;) &#123;</span><br><span class="line">                    int a = stack.pop();</span><br><span class="line">                    stack.push(a * num);</span><br><span class="line">                &#125; else if (operation == &apos;/&apos;) &#123;</span><br><span class="line">                    int a = stack.pop();</span><br><span class="line">                    stack.push(a / num);</span><br><span class="line">                &#125;</span><br><span class="line">                //update</span><br><span class="line">                if(i&gt;=chs.length-1)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                operation = chs[i];</span><br><span class="line">                num = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        //将栈中的结果相加</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            sum += stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. 完全二叉树的节点个数</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">给出一个完全二叉树，求出该树的节点个数。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \  /</span><br><span class="line">4  5 6</span><br><span class="line"></span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int countNodes(TreeNode root) &#123;</span><br><span class="line">        if(root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else if(root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1+countNodes(root.left)+countNodes(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，返回它的 前序 遍历。</span><br><span class="line"></span><br><span class="line"> 示例:</span><br><span class="line"></span><br><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br><span class="line">进阶: 递归算法很简单，你可以通过迭代算法完成吗？</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        if(root==null) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;TreeNode&gt; stack = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        TreeNode temp;</span><br><span class="line">        do &#123;</span><br><span class="line">            temp = stack.remove(stack.size()-1);</span><br><span class="line">            res.add(temp.val);</span><br><span class="line">            if(temp.right!=null)</span><br><span class="line">                stack.add(temp.right);</span><br><span class="line">            if(temp.left!=null)</span><br><span class="line">                stack.add(temp.left);</span><br><span class="line">        &#125; while (stack.size()!=0);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，返回它的 后序 遍历。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br><span class="line">进阶: 递归算法很简单，你可以通过迭代算法完成吗？</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        if(root==null) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;TreeNode&gt; stack = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        Set&lt;TreeNode&gt; pre = new HashSet&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode temp=null;</span><br><span class="line">        do &#123;</span><br><span class="line">            temp = stack.get(stack.size()-1);</span><br><span class="line">            if(pre.remove(temp)) &#123;</span><br><span class="line">                res.add(temp.val);</span><br><span class="line">                stack.remove(stack.size()-1);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(temp.right!=null)</span><br><span class="line">                stack.add(temp.right);</span><br><span class="line">            if(temp.left!=null)</span><br><span class="line">                stack.add(temp.left);</span><br><span class="line">            </span><br><span class="line">            if(temp.right==null&amp;&amp;temp.left==null) &#123;</span><br><span class="line">                res.add(temp.val);</span><br><span class="line">                stack.remove(stack.size()-1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                pre.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (stack.size()!=0);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><a href="https://leetcode-cn.com/problems/single-number-iii/" target="_blank" rel="noopener">260. 只出现一次的数字 III</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</span><br><span class="line"></span><br><span class="line">示例 :</span><br><span class="line"></span><br><span class="line">输入: [1,2,1,3,2,5]</span><br><span class="line">输出: [3,5]</span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。</span><br><span class="line">你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>解法一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] singleNumber(int[] nums) &#123;</span><br><span class="line">        int[]res=new int[2];</span><br><span class="line">        if(nums==null||nums.length==0)</span><br><span class="line">            return res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        int temp = nums[0],count=0,i=0;</span><br><span class="line"></span><br><span class="line">        do &#123;</span><br><span class="line">            if(i&lt;nums.length-1 &amp;&amp; nums[i]==nums[i+1]) &#123;</span><br><span class="line">                i+=2;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res[count++]=nums[i];</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while(i&lt;nums.length);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] singleNumber(int[] nums) &#123;</span><br><span class="line">        int[] ans = new int[2];</span><br><span class="line">        if(nums==null||nums.length==0)</span><br><span class="line">            return ans;</span><br><span class="line"></span><br><span class="line">        int xor = 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            xor ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        int mask = xor &amp; (-xor);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            if ( (num &amp; mask) == 0) &#123;</span><br><span class="line">                ans[0] ^= num;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans[1] ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264. 丑数 II"></a><a href="https://leetcode-cn.com/problems/ugly-number-ii/" target="_blank" rel="noopener">264. 丑数 II</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">编写一个程序，找出第 n 个丑数。</span><br><span class="line"></span><br><span class="line">丑数就是质因数只包含 2, 3, 5 的正整数。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: n = 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br><span class="line">说明:  </span><br><span class="line"></span><br><span class="line">1 是丑数。</span><br><span class="line">n 不超过1690。</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int nthUglyNumber(int n) &#123;</span><br><span class="line">        int[] nums = new int[n];</span><br><span class="line">        nums[0] = 1;</span><br><span class="line"></span><br><span class="line">        int i2 = 0, i3 = 0, i5 = 0;</span><br><span class="line">        int temp = 1;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            temp = Math.min(Math.min(nums[i2] * 2, nums[i3] * 3), nums[i5] * 5);</span><br><span class="line">            nums[i] = temp;</span><br><span class="line"></span><br><span class="line">            if (temp == nums[i2] * 2) &#123;</span><br><span class="line">                i2++;</span><br><span class="line">            &#125; </span><br><span class="line">            if (temp == nums[i3] * 3) &#123;</span><br><span class="line">                i3++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp == nums[i5] * 5) &#123;</span><br><span class="line">                i5++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nums[n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="274-H-指数"><a href="#274-H-指数" class="headerlink" title="274. H 指数"></a><a href="https://leetcode-cn.com/problems/h-index/" target="_blank" rel="noopener">274. H 指数</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。</span><br><span class="line"></span><br><span class="line">h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数 不超过 h 次。）</span><br><span class="line"></span><br><span class="line">例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：citations = [3,0,6,1,5]</span><br><span class="line">输出：3 </span><br><span class="line">解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。</span><br><span class="line">     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int hIndex(int[] citations) &#123;</span><br><span class="line">        if(citations==null||citations.length==0)</span><br><span class="line">            return 0;</span><br><span class="line">        int[]count = new int[citations.length];</span><br><span class="line">		</span><br><span class="line">		// 计算引用次数出现的次数</span><br><span class="line">        for(int citation:citations) &#123;</span><br><span class="line">            if(citation&gt;=1) &#123;</span><br><span class="line">                if(citation&gt;citations.length)</span><br><span class="line">                    citation=citations.length;</span><br><span class="line">                count[citation-1]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		// 查询最大H指数</span><br><span class="line">        for(int i=citations.length-1; i&gt;=0; i--) &#123;</span><br><span class="line">			// 至少 被引用次数</span><br><span class="line">            if(count[i]&gt;=i+1) &#123;</span><br><span class="line">                return i+1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if(i!=0) &#123;</span><br><span class="line">                    count[i-1]+=count[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="275-H-指数-II"><a href="#275-H-指数-II" class="headerlink" title="275. H 指数 II"></a><a href="https://leetcode-cn.com/problems/h-index-ii/" target="_blank" rel="noopener">275. H 指数 II</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照 升序排列 。编写一个方法，计算出研究者的 h 指数。</span><br><span class="line"></span><br><span class="line">h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）&quot;</span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: citations = [0,1,3,5,6]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。</span><br><span class="line">     由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int hIndex(int[] citations) &#123;</span><br><span class="line">        if(citations==null||citations.length==0)</span><br><span class="line">            return 0;</span><br><span class="line">        int[]count = new int[citations.length];</span><br><span class="line">		</span><br><span class="line">		// 计算引用次数出现的次数</span><br><span class="line">        for(int citation:citations) &#123;</span><br><span class="line">            if(citation&gt;=1) &#123;</span><br><span class="line">                if(citation&gt;citations.length)</span><br><span class="line">                    citation=citations.length;</span><br><span class="line">                count[citation-1]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		// 查询最大H指数</span><br><span class="line">        for(int i=citations.length-1; i&gt;=0; i--) &#123;</span><br><span class="line">			// 至少 被引用次数</span><br><span class="line">            if(count[i]&gt;=i+1) &#123;</span><br><span class="line">                return i+1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if(i!=0) &#123;</span><br><span class="line">                    count[i-1]+=count[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. 长度最小的子数组</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">	输入：s = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">	输出：2</span><br><span class="line">	解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minSubArrayLen(int s, int[] nums) &#123;</span><br><span class="line">        if(nums==null||nums.length==0)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        int min_count=0;</span><br><span class="line"></span><br><span class="line">        for(int lf=0; lf&lt;nums.length; lf++) &#123;</span><br><span class="line">            int sum=nums[lf];</span><br><span class="line">            int rt=lf;</span><br><span class="line"></span><br><span class="line">            do&#123;</span><br><span class="line">                if(sum&lt;s) &#123;</span><br><span class="line">                    rt++;</span><br><span class="line">                    if(rt&lt;nums.length) &#123;</span><br><span class="line">                        sum+=nums[rt];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    min_count = (min_count==0||min_count&gt;rt-lf+1)?rt-lf+1:min_count;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; while(rt&lt;nums.length);</span><br><span class="line"></span><br><span class="line">            if(min_count==1) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return min_count;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</span><br><span class="line"></span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下 ，能够偷窃到的最高金额。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums = [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>解析：<br>由于是环形结构，但存储结构是数组，可以简化为两个单排排列：<br>不偷第一个房子，nums[1]——nums[n-1]<br>不偷最后一个房子，nums[0]——nums[n-2]</p>
<ol>
<li><p>状态定义<br>动态列表dp，dp[i]表示前 i 个房子在满足条件下的能偷窃到的最高金额。</p>
</li>
<li><p>转移方程</p>
</li>
</ol>
<p>最大金额如下：</p>
<ul>
<li>不偷n+1个房子：dp[n+1]=dp[n]</li>
<li>偷n+1个房子：dp[n+1]=dp[n-1]+nums[n+1];<ul>
<li>不代表着dp[n-1]一定会被偷，也可以偷dp[n-2]，所以可得：dp[n]=dp[n-1]=dp[n-2]</li>
<li>dp[n+1]=dp[n-2]+nums[n+1]=d[n]+nums[n+1]</li>
</ul>
</li>
</ul>
<ol start="3">
<li>最终的转移方程</li>
</ol>
<p>dp[n+1] = max(dp[n],dp[n-1]+num)dp[n+1]=max(dp[n],dp[n−1]+num)</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int rob(int[] nums) &#123;</span><br><span class="line">		// 特殊情况判定</span><br><span class="line">        if(nums==null||nums.length==0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(nums.length==1)</span><br><span class="line">            return nums[0];</span><br><span class="line">		// 环形结构，分为两个单列</span><br><span class="line">        return Math.max(getRob(nums, 0, nums.length-2),getRob(nums, 1, nums.length-1));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    private int getRob(int[]nums, int lf,int rt) &#123;</span><br><span class="line">        int per=0,perPer=0,cur=0;</span><br><span class="line">        for(int i=lf;i&lt;=rt;i++) &#123;</span><br><span class="line">			//偷n-1或偷n-2与第n个判定</span><br><span class="line">				// 偷n-2存在第一种特殊情况，不偷n-2，偷n-3个包含在偷n-2个的最大值中</span><br><span class="line">            cur = Math.max(per,perPer+nums[i]);</span><br><span class="line">            perPer=per;</span><br><span class="line">            per=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1, 3, 4]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> /   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>解析：用层次遍历的思路，遍历二叉树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        getList(list, root, 0);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void getList(List&lt;Integer&gt; list, TreeNode root,int dp) &#123;</span><br><span class="line">        if(root!=null) &#123;</span><br><span class="line">            if(list.size()&lt;dp+1)</span><br><span class="line">                list.add(root.val);</span><br><span class="line">            getList(list, root.right, dp+1);</span><br><span class="line">            getList(list, root.left, dp+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="284-顶端迭代器"><a href="#284-顶端迭代器" class="headerlink" title="284. 顶端迭代器"></a><a href="https://leetcode-cn.com/problems/peeking-iterator/" target="_blank" rel="noopener">284. 顶端迭代器</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定一个迭代器类的接口，接口包含两个方法： next() 和 hasNext()。设计并实现一个支持 peek() 操作的顶端迭代器 -- 其本质就是把原本应由 next() 方法返回的元素 peek() 出来。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">假设迭代器被初始化为列表 [1,2,3]。</span><br><span class="line"></span><br><span class="line">调用 next() 返回 1，得到列表中的第一个元素。</span><br><span class="line">现在调用 peek() 返回 2，下一个元素。在此之后调用 next() 仍然返回 2。</span><br><span class="line">最后一次调用 next() 返回 3，末尾元素。在此之后调用 hasNext() 应该返回 false。</span><br><span class="line">进阶：你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// Java Iterator interface reference:</span><br><span class="line">// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html</span><br><span class="line"></span><br><span class="line">class PeekingIterator implements Iterator&lt;Integer&gt; &#123;</span><br><span class="line">    private Integer pk=null;</span><br><span class="line">    private Iterator&lt;Integer&gt; iterator;</span><br><span class="line"></span><br><span class="line">	public PeekingIterator(Iterator&lt;Integer&gt; iterator) &#123;</span><br><span class="line">	    // initialize any member here.</span><br><span class="line">        this.iterator = iterator;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    // Returns the next element in the iteration without advancing the iterator.</span><br><span class="line">	public Integer peek() &#123;</span><br><span class="line">        if(pk==null) &#123;</span><br><span class="line">            pk = iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        return pk;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// hasNext() and next() should behave the same as in the Iterator interface.</span><br><span class="line">	// Override them if needed.</span><br><span class="line">	@Override</span><br><span class="line">	public Integer next() &#123;</span><br><span class="line">        int res = peek();</span><br><span class="line">        pk=null;</span><br><span class="line">        return res;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public boolean hasNext() &#123;</span><br><span class="line">	    return iterator.hasNext()||pk!=null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="289. 生命游戏"></a><a href="https://leetcode-cn.com/problems/game-of-life/" target="_blank" rel="noopener">289. 生命游戏</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</span><br><span class="line"></span><br><span class="line">给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</span><br><span class="line"></span><br><span class="line">如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</span><br><span class="line">如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</span><br><span class="line">如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</span><br><span class="line">如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</span><br><span class="line">根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入： </span><br><span class="line">[</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,1],</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,1,1],</span><br><span class="line">  [0,1,0]</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。</span><br><span class="line">本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>解析：我们可以基于状态机进行求解，</p>
<p>1.设置状态机如下</p>
<ul>
<li>00 死-》死  0    0</li>
<li>01 死-》活  1    -1</li>
<li>10 活-》死  2    2</li>
<li>11 活-》活  3    1</li>
</ul>
<p>2.状态变更规则</p>
<ul>
<li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li>
<li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li>
<li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li>
<li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li>
</ul>
<p>3.第一遍是基于规则设置状态，第二遍是基于状态值设置是否存活。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void gameOfLife(int[][] board) &#123;</span><br><span class="line">        if(board==null||board.length==0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int row = board.length;</span><br><span class="line">        int col = board[0].length;</span><br><span class="line">        for(int i=0; i&lt;row;i++) &#123;</span><br><span class="line">            for(int j=0; j&lt;col;j++) &#123;</span><br><span class="line">                int count = countLife(board, i,j);</span><br><span class="line">                if (board[i][j]==1) &#123;</span><br><span class="line">                     if(count&gt;=2&amp;&amp;count&lt;=3) &#123;</span><br><span class="line">                        board[i][j]=1;</span><br><span class="line">                     &#125; else &#123;</span><br><span class="line">                        board[i][j]=2;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(count==3) &#123;</span><br><span class="line">                        board[i][j]=-1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        board[i][j]=0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0; i&lt;row;i++) &#123;</span><br><span class="line">            for(int j=0; j&lt;col;j++) &#123;</span><br><span class="line">                if (board[i][j]==2) &#123;</span><br><span class="line">                    board[i][j]=0;</span><br><span class="line">                &#125;else if(board[i][j]==-1) &#123;</span><br><span class="line">                    board[i][j]=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int countLife(int[][] board, int x, int y) &#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=x-1; i&lt;=x+1;i++) &#123;</span><br><span class="line">            if(i&lt;0||i&gt;board.length-1)</span><br><span class="line">                continue;</span><br><span class="line">            for(int j=y-1; j&lt;=y+1;j++) &#123;</span><br><span class="line">                if(j&lt;0||j&gt;board[0].length-1||i==x&amp;&amp;j==y)</span><br><span class="line">                    continue;</span><br><span class="line">                if(board[i][j]&gt;=1) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                    if(sum&gt;3) &#123;</span><br><span class="line">                        return sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">151. 翻转字符串里的单词</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串，逐个翻转字符串中的每个单词。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">无空格字符构成一个 单词 。</span><br><span class="line">输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line">如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：&quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：&quot;  hello world!  &quot;</span><br><span class="line">输出：&quot;world! hello&quot;</span><br><span class="line">解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：&quot;a good   example&quot;</span><br><span class="line">输出：&quot;example good a&quot;</span><br><span class="line">解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;  Bob    Loves  Alice   &quot;</span><br><span class="line">输出：&quot;Alice Loves Bob&quot;</span><br><span class="line">示例 5：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;Alice does not even like bob&quot;</span><br><span class="line">输出：&quot;bob like even not does Alice&quot;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= s.length &lt;= 104</span><br><span class="line">s 包含英文大小写字母、数字和空格 &apos; &apos;</span><br><span class="line">s 中 至少存在一个 单词</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>class Solution {<br>    public String reverseWords(String s) {<br>        String[] strs = s.trim().split(“ “);<br>        StringBuilder sb = new StringBuilder();<br>        sb.append(strs[strs.length-1]);<br>        for(int i=strs.length-2; i&gt;=0;i–) {<br>            if(!strs[i].equals(“”)) {<br>                sb.append(“ “).append(strs[i]);<br>            }<br>        }<br>        return sb.toString();<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">### [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***题目***</span><br></pre></td></tr></table></figure>

<p>对链表进行插入排序。<br>插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。<br>每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。</p>
<p>插入排序算法：</p>
<pre><code>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
重复直到所有输入数据插入完为止。</code></pre><p>示例 1：</p>
<pre><code>输入: 4-&gt;2-&gt;1-&gt;3
输出: 1-&gt;2-&gt;3-&gt;4</code></pre><p>示例 2：</p>
<pre><code>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0
输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">***题解***</span><br></pre></td></tr></table></figure>

<p>class Solution {<br>    public ListNode insertionSortList(ListNode head) {<br>        List<integer> list=new ArrayList&lt;&gt;();<br>        ListNode p=head;<br>        while (p!=null){<br>            list.add(p.val);<br>            p=p.next;<br>        }<br>        Collections.sort(list);<br>        p=head;<br>        int i=0;<br>        while (p!=null){<br>            p.val=list.get(i++);<br>            p=p.next;<br>        }<br>        return head;<br>    }<br>}</integer></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### [849. 到最近的人的最大距离](https://leetcode-cn.com/problems/maximize-distance-to-closest-person/)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***题目***</span><br></pre></td></tr></table></figure>

<p>在一排座位（ seats）中，1 代表有人坐在座位上，0 代表座位上是空的。<br>至少有一个空座位，且至少有一人坐在座位上。<br>亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。<br>返回他到离他最近的人的最大距离。</p>
<p>示例 1：</p>
<pre><code>输入：[1,0,0,0,1,0,1]
输出：2
解释：
如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。
如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。
因此，他到离他最近的人的最大距离是 2 。 </code></pre><p>示例 2：</p>
<pre><code>输入：[1,0,0,0]
输出：3
解释：
如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。
这是可能的最大距离，所以答案是 3 。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">***题解***</span><br><span class="line"></span><br><span class="line">解析：时间复杂度O(n),存在三种情况，如下：</span><br><span class="line">+	左侧没有人：0,0,1</span><br><span class="line">+	右侧没有人：1,0,0</span><br><span class="line">+	两侧都有人：1,0,1</span><br></pre></td></tr></table></figure>

<p>class Solution {<br>    public int maxDistToClosest(int[] seats) {<br>        if(seats==null||seats.length==0)<br>            return 0;<br>        boolean flag= seats[0]==0?true:false;<br>        int count=0,max=0;<br>        for(int seat:seats) {<br>            if(seat==0) {<br>                count++;<br>            } else if(seat==1 &amp;&amp; count!=0) {<br>                //左侧没有人<br>                if(flag) {<br>                    max=max&gt;count?max:count;<br>                    count=0;<br>                    flag=false;<br>                }else {<br>                    //两侧都有人<br>                    max=max&gt;(count+1)/2?max:(count+1)/2;<br>                    count=0;<br>                }<br>            }<br>        }<br>        //右侧没有人<br>        if(count!=0) {<br>            max=max&gt;count?max:count;<br>        }<br>        return max;<br>    }<br>}</p>
<pre><code></code></pre></div><div class="post-copyright"><blockquote><p>原文作者: 古城烟雨</p><p>原文链接: <a href="http://zws6672.top/2020/11/02/leetcode-201019-201030/">http://zws6672.top/2020/11/02/leetcode-201019-201030/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/leetcode/">leetcode</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/11/04/java-concurrent/" class="pre">Java多线程（一）ThreadLocal</a><a href="/2020/11/02/nk-201019-201030/" class="next">nk-201019-201030</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#227-基本计算器-II"><span class="toc-text">227. 基本计算器 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#222-完全二叉树的节点个数"><span class="toc-text">222. 完全二叉树的节点个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#144-二叉树的前序遍历"><span class="toc-text">144. 二叉树的前序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#145-二叉树的后序遍历"><span class="toc-text">145. 二叉树的后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#260-只出现一次的数字-III"><span class="toc-text">260. 只出现一次的数字 III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#264-丑数-II"><span class="toc-text">264. 丑数 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#274-H-指数"><span class="toc-text">274. H 指数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#275-H-指数-II"><span class="toc-text">275. H 指数 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#209-长度最小的子数组"><span class="toc-text">209. 长度最小的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#213-打家劫舍-II"><span class="toc-text">213. 打家劫舍 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#199-二叉树的右视图"><span class="toc-text">199. 二叉树的右视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#284-顶端迭代器"><span class="toc-text">284. 顶端迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#289-生命游戏"><span class="toc-text">289. 生命游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#151-翻转字符串里的单词"><span class="toc-text">151. 翻转字符串里的单词</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/mysql-opt/">MySQL 优化(一)设计与功能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/tool-uml/">UML中关系</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/fmi-ssp-dcp/">了解fmi、ssp与dcp</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/hexo-sync/">多PC同步hexo</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/fmi-daccosim/">基于FMI标准的仿真软件————Daccosim</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/springboot-1/">springboot（一）入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/13/jdk-backend-compile/">后端编译与优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/13/jdk-front-compile/">前端编译与优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/26/jdk-bytecodeEngine/">虚拟机字节码执行引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/15/jdk-cload/">虚拟机类加载机制</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/devops/" style="font-size: 15px;">devops</a> <a href="/tags/CI/" style="font-size: 15px;">CI</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/neo4j/" style="font-size: 15px;">neo4j</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/oracle/" style="font-size: 15px;">oracle</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/系统/" style="font-size: 15px;">系统</a> <a href="/tags/博客搭建/" style="font-size: 15px;">博客搭建</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/ms/" style="font-size: 15px;">ms</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/运维/" style="font-size: 15px;">运维</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/javaweb/" style="font-size: 15px;">javaweb</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/elasticsearch/" style="font-size: 15px;">elasticsearch</a> <a href="/tags/fmi/" style="font-size: 15px;">fmi</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/微服务/" style="font-size: 15px;">微服务</a> <a href="/tags/soft-skills/" style="font-size: 15px;">soft-skills</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/nk/" style="font-size: 15px;">nk</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://juejin.im/" title="掘金" target="_blank">掘金</a><ul></ul><a href="https://www.cnblogs.com/" title="博客园" target="_blank">博客园</a><ul></ul><a href="https://www.infoq.cn/" title="info" target="_blank">info</a><ul></ul><a href="https://www.ibm.com/" title="ibm" target="_blank">ibm</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">古城烟雨.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>
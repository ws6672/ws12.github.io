<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一些关于技术的碎语"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>数据结构（七）图 | 微言术语</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">数据结构（七）图</h1><a id="logo" href="/.">微言术语</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">数据结构（七）图</h1><div class="post-meta"><a href="/2020/04/27/datastruct-6/#comments" class="comment-count"></a><p><span class="date">Apr 27, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p><img src="/image/sjjg/graph.png" alt="图"></p>
<h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p><strong><em>边</em></strong></p>
<p><img src="/image/sjjg/yxb.png" alt="有向边"></p>
<ul>
<li>顶点：图中的数据元素</li>
<li>边：任意两个顶点之间都可能有关系，顶点之间的逻辑关系可以称之为边<ul>
<li>无向边：两顶点之间的边没有方向</li>
<li>有向边：两顶点之间的边有方向，也可称之为弧</li>
</ul>
</li>
</ul>
<p><strong><em>图</em></strong></p>
<p><img src="/image/sjjg/tzl.png" alt="图种类"></p>
<ul>
<li>简单图：不存在有向边且同一边没有重复出现</li>
<li>无向完全图：无向图中，任意两个顶点之间都存在边</li>
<li>有向完全图：有向图中，任意两个顶点之间都存在方向相反的两条弧，则称之为有向完全图</li>
<li>稀疏图：有很少条边或弧的图称之为稀疏图，反之称之为稠密图</li>
<li>网：带权的图<ul>
<li>权：与图的边或者弧有关的数据称之为权</li>
</ul>
</li>
<li>子图：A的顶点与边结构都包含在B中，则称A为B的子图</li>
</ul>
<p><strong><em>顶点与边的关系</em></strong></p>
<p><img src="/image/sjjg/dbbgx.png" alt="顶点与边的关系"></p>
<p><strong><em>连通图</em></strong></p>
<p><img src="/image/sjjg/ltt.png" alt="连通图"></p>
<h3 id="二、抽象数据类型"><a href="#二、抽象数据类型" class="headerlink" title="二、抽象数据类型"></a>二、抽象数据类型</h3><p><img src="/image/sjjg/tcxsjjg.png" alt="图抽象数据类型"></p>
<h3 id="三、存储结构"><a href="#三、存储结构" class="headerlink" title="三、存储结构"></a>三、存储结构</h3><p><strong><em>邻接矩阵</em></strong><br>图包含了顶点和边，我们可以通过一维数组存储顶点，二维数组存储边。理论上，我们可以通过邻接矩阵来存储图。</p>
<p>如下图所示，无边图的邻接矩阵是一个对称矩阵，即每个节点都没有到自身的边。<br><img src="/image/sjjg/ljjz.png" alt="邻接矩阵"></p>
<p><img src="/image/sjjg/ljjz-yx.png" alt="邻接矩阵有向"></p>
<p>JAVA代码示例: </p>
<ul>
<li>网</li>
<li>结构：逻辑结构是有向带权图，物理结构是邻接矩阵</li>
<li>特点：边操作易，顶点操作难</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">public class AMGraph&lt;T&gt; &#123;</span><br><span class="line">//    顶点</span><br><span class="line">    private Object[] nodes;</span><br><span class="line">//    边</span><br><span class="line">    private int[][] edges;</span><br><span class="line">//    访问数组</span><br><span class="line">    private boolean[] visited;</span><br><span class="line">    private final int INIT_SIZE = 10;</span><br><span class="line"></span><br><span class="line">    private AMGraph() &#123;</span><br><span class="line">        nodes = new Object[INIT_SIZE];</span><br><span class="line">        edges = new int[INIT_SIZE][INIT_SIZE];</span><br><span class="line">        visited = new boolean[INIT_SIZE];</span><br><span class="line">    &#125;</span><br><span class="line">    private AMGraph (int size) &#123;</span><br><span class="line">        nodes = new Object[size];</span><br><span class="line">        edges = new int[size][size];</span><br><span class="line">        visited = new boolean[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @Description 创建图</span><br><span class="line">    * @param nodes 顶点数组</span><br><span class="line">    * @return 图——邻接矩阵</span><br><span class="line">    */</span><br><span class="line">    public static AMGraph create(String[] nodes) &#123;</span><br><span class="line">        AMGraph amGraph;</span><br><span class="line">        if (10 != nodes.length) &#123;</span><br><span class="line">            amGraph = new AMGraph(nodes.length);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            amGraph = new AMGraph();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i=0; i&lt;nodes.length;i++) &#123;</span><br><span class="line">            amGraph.nodes[i] = nodes[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return amGraph;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @Description 添加边</span><br><span class="line">    * @param head 弧头</span><br><span class="line">    * @param tail 弧尾</span><br><span class="line">    * @param wegt 权重</span><br><span class="line">    */</span><br><span class="line">    public void addEdge (int head, int tail, int wegt) throws Exception &#123;</span><br><span class="line">        if (head &gt;= nodes.length &amp;&amp; tail &gt;= nodes.length) &#123;</span><br><span class="line">            throw new Exception(&quot;结点不存在&quot;);</span><br><span class="line">        &#125; else if (head&lt;0 &amp;&amp; tail&lt;0) &#123;</span><br><span class="line">            throw new Exception(&quot;结点不存在&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            edges[head][tail] = wegt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addEdge (T t, T t1, int wegt) throws Exception &#123;</span><br><span class="line">        addEdge(getIndex(t), getIndex(t1), wegt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @Description 获取顶点索引</span><br><span class="line">    * @param t 元素</span><br><span class="line">    * @return 数组下标索引</span><br><span class="line">    */</span><br><span class="line">    public int getIndex (T t) &#123;</span><br><span class="line">         for (int i=0; i&lt; nodes.length; i++) &#123;</span><br><span class="line">            if (t.equals(nodes[i])) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    遍历边，用于遍历所有有向边</span><br><span class="line">    public void edges() &#123;</span><br><span class="line">        for (int i = 0; i&lt;visited.length; i++) &#123;</span><br><span class="line">            visited[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i&lt;visited.length; i++) &#123;</span><br><span class="line">            edges(i, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private void edges(int index, int j) &#123;</span><br><span class="line">//        遍历所有结点判定</span><br><span class="line">        if (j&lt;visited.length ) &#123;</span><br><span class="line">//            if (!visited[j]) &#123;</span><br><span class="line">                if (edges[index][j] != 0) &#123;</span><br><span class="line">                    System.out.println(nodes[index]+&quot;——&quot;+edges[index][j]+&quot;——&gt;&quot;+nodes[j]);</span><br><span class="line">                &#125;</span><br><span class="line">//            &#125;</span><br><span class="line">            if (j&lt;visited.length-1) &#123;</span><br><span class="line">                edges(index, ++j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[index++] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AMGraph&lt;String&gt; amGraph = AMGraph.create(new String[]&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;&#125;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">             amGraph.addEdge(&quot;A&quot;, &quot;B&quot;,9);</span><br><span class="line">             amGraph.addEdge(&quot;A&quot;, &quot;F&quot;,5);</span><br><span class="line">             amGraph.addEdge(&quot;B&quot;, &quot;G&quot;,4);</span><br><span class="line">             amGraph.addEdge(&quot;B&quot;, &quot;C&quot;,7);</span><br><span class="line">             amGraph.addEdge(&quot;B&quot;, &quot;I&quot;,6);</span><br><span class="line">             amGraph.addEdge(&quot;F&quot;, &quot;G&quot;,2);</span><br><span class="line">             amGraph.addEdge(&quot;F&quot;, &quot;E&quot;,55);</span><br><span class="line">             amGraph.addEdge(&quot;C&quot;, &quot;I&quot;,43);</span><br><span class="line">             amGraph.addEdge(&quot;C&quot;, &quot;D&quot;,1);</span><br><span class="line">             amGraph.addEdge(&quot;I&quot;, &quot;D&quot;,6);</span><br><span class="line">             amGraph.addEdge(&quot;G&quot;, &quot;D&quot;,9);</span><br><span class="line">             amGraph.addEdge(&quot;G&quot;, &quot;H&quot;,3);</span><br><span class="line">             amGraph.addEdge(&quot;H&quot;, &quot;D&quot;,2);</span><br><span class="line">             amGraph.addEdge(&quot;H&quot;, &quot;E&quot;,22);</span><br><span class="line">             amGraph.addEdge(&quot;D&quot;, &quot;E&quot;,12);</span><br><span class="line"></span><br><span class="line">             amGraph.edges();</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：如果是网(边带权重)，那么将数组中表示右边的值1改为边的权重即可。</p>
</blockquote>
<p><strong><em>邻接表</em></strong></p>
<p>对于边数相对顶点数较少的图来说，使用二维数组存储是很浪费的，大量的数组位都是0，不会用于存储有效信息。</p>
<p>所以，我们可以依旧用数组存储顶点，用链表存储边或者弧。这种数组和链表结合的存储方式称之为邻接表。</p>
<p>如下所示，当使用邻接表表示有边图的时候，表示出度；使用逆邻接表，表示入度。<br><img src="/image/sjjg/ljb.png" alt="邻接表"></p>
<p><strong><em>十字链表</em></strong></p>
<p>结合邻接表和逆邻接表就是十字链表，同时表示一个顶点的出度与入度，适合存放有向表。</p>
<p><img src="/image/sjjg/szlb.png" alt="十字链表"></p>
<p><strong><em>邻接多重表</em></strong></p>
<p><img src="/image/sjjg/ljdcb.png" alt="邻接多重表"></p>
<p><strong><em>边集数组</em></strong></p>
<p><img src="/image/sjjg/bjsz.png" alt="边集数组"></p>
<h3 id="四、遍历"><a href="#四、遍历" class="headerlink" title="四、遍历"></a>四、遍历</h3><p>图的遍历是从一个顶点出发访遍图中其余顶点，且每个顶点有且只有一次访问，这个过程称之为<code>图的遍历</code>.</p>
<ul>
<li>深度优先遍历（DFS）:从顶点V出发，访问有路径相通的未邻接顶点</li>
<li>广度优先遍历（BFS）:从顶点V出发，先访问它的所有相邻顶点，再通过相邻顶点访问其它顶点</li>
</ul>
<p>如下所示，<br><img src="/image/sjjg/jzt.png" alt="矩阵-图"></p>
<p><strong><em>JAVA-深度遍历</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class AMGraph&lt;T&gt; &#123;</span><br><span class="line">	</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">    public void dfs() &#123;</span><br><span class="line">//        初始化访问</span><br><span class="line">        for (int i = 0; i&lt;visited.length; i++) &#123;</span><br><span class="line">            visited[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i&lt;visited.length; i++) &#123;</span><br><span class="line">            dfs(i, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	// 深度优先算法，持续向下一层遍历，直到无法向下或剩余点都是已遍历的</span><br><span class="line">    private void dfs(int h, int t) &#123;</span><br><span class="line">        visited[h] = true;</span><br><span class="line">        for (; t&lt;visited.length; t++) &#123;</span><br><span class="line">//            顶点未遍历且存在边</span><br><span class="line">            if (!visited[t] &amp;&amp; edges[h][t] != 0) &#123;</span><br><span class="line">                //                深度遍历</span><br><span class="line">                System.out.println(nodes[h]+&quot;——&quot;+edges[h][t]+&quot;——&gt;&quot;+nodes[t]);</span><br><span class="line">                dfs(t, 0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AMGraph&lt;String&gt; amGraph = AMGraph.create(new String[]&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;&#125;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">             amGraph.addEdge(&quot;A&quot;, &quot;B&quot;,9);</span><br><span class="line">             amGraph.addEdge(&quot;A&quot;, &quot;F&quot;,5);</span><br><span class="line">             amGraph.addEdge(&quot;B&quot;, &quot;G&quot;,4);</span><br><span class="line">             amGraph.addEdge(&quot;B&quot;, &quot;C&quot;,7);</span><br><span class="line">             amGraph.addEdge(&quot;B&quot;, &quot;I&quot;,6);</span><br><span class="line">             amGraph.addEdge(&quot;F&quot;, &quot;G&quot;,2);</span><br><span class="line">             amGraph.addEdge(&quot;F&quot;, &quot;E&quot;,55);</span><br><span class="line">             amGraph.addEdge(&quot;C&quot;, &quot;I&quot;,43);</span><br><span class="line">             amGraph.addEdge(&quot;C&quot;, &quot;D&quot;,1);</span><br><span class="line">             amGraph.addEdge(&quot;I&quot;, &quot;D&quot;,6);</span><br><span class="line">             amGraph.addEdge(&quot;G&quot;, &quot;D&quot;,9);</span><br><span class="line">             amGraph.addEdge(&quot;G&quot;, &quot;H&quot;,3);</span><br><span class="line">             amGraph.addEdge(&quot;H&quot;, &quot;D&quot;,2);</span><br><span class="line">             amGraph.addEdge(&quot;H&quot;, &quot;E&quot;,22);</span><br><span class="line">             amGraph.addEdge(&quot;D&quot;, &quot;E&quot;,12);</span><br><span class="line"></span><br><span class="line">             amGraph.dfs();</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A——9——&gt;B</span><br><span class="line">B——7——&gt;C</span><br><span class="line">C——1——&gt;D</span><br><span class="line">D——12——&gt;E</span><br><span class="line">C——43——&gt;I</span><br><span class="line">B——4——&gt;G</span><br><span class="line">G——3——&gt;H</span><br><span class="line">A——5——&gt;F</span><br></pre></td></tr></table></figure>

<p><strong><em>JAVA-广度遍历</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class AMGraph&lt;T&gt; &#123;</span><br><span class="line">	</span><br><span class="line">	......</span><br><span class="line">//    访问数组</span><br><span class="line">    private boolean[] visited;</span><br><span class="line"></span><br><span class="line">//    广度遍历</span><br><span class="line">    public void bfs() &#123;</span><br><span class="line">        for (int i = 0; i&lt;visited.length; i++) &#123;</span><br><span class="line">            visited[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i&lt;visited.length; i++) &#123;</span><br><span class="line">            bfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	//在广度优先算法中，将与顶点邻接的点都保存到队列中，然后先进先出；我这里用列表代替，异曲同工</span><br><span class="line">    private void bfs(int h) &#123;</span><br><span class="line">        visited[h] = true;</span><br><span class="line">        List&lt;Integer&gt; tails = new ArrayList&lt;&gt;();</span><br><span class="line">//        广度优先</span><br><span class="line">        for (int j=0; j&lt;nodes.length; j++) &#123;</span><br><span class="line">            if (!visited[j] &amp;&amp; edges[h][j] != 0) &#123;</span><br><span class="line">                visited[j] = true;</span><br><span class="line">                System.out.println(nodes[h]+&quot;——&quot;+edges[h][j]+&quot;——&gt;&quot;+nodes[j]);</span><br><span class="line">                tails.add(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int index: tails) &#123;</span><br><span class="line">            bfs(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AMGraph&lt;String&gt; amGraph = AMGraph.create(new String[]&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;&#125;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">             amGraph.addEdge(&quot;A&quot;, &quot;B&quot;,9);</span><br><span class="line">             amGraph.addEdge(&quot;A&quot;, &quot;F&quot;,5);</span><br><span class="line">             amGraph.addEdge(&quot;B&quot;, &quot;G&quot;,4);</span><br><span class="line">             amGraph.addEdge(&quot;B&quot;, &quot;C&quot;,7);</span><br><span class="line">             amGraph.addEdge(&quot;B&quot;, &quot;I&quot;,6);</span><br><span class="line">             amGraph.addEdge(&quot;F&quot;, &quot;G&quot;,2);</span><br><span class="line">             amGraph.addEdge(&quot;F&quot;, &quot;E&quot;,55);</span><br><span class="line">             amGraph.addEdge(&quot;C&quot;, &quot;I&quot;,43);</span><br><span class="line">             amGraph.addEdge(&quot;C&quot;, &quot;D&quot;,1);</span><br><span class="line">             amGraph.addEdge(&quot;I&quot;, &quot;D&quot;,6);</span><br><span class="line">             amGraph.addEdge(&quot;G&quot;, &quot;D&quot;,9);</span><br><span class="line">             amGraph.addEdge(&quot;G&quot;, &quot;H&quot;,3);</span><br><span class="line">             amGraph.addEdge(&quot;H&quot;, &quot;D&quot;,2);</span><br><span class="line">             amGraph.addEdge(&quot;H&quot;, &quot;E&quot;,22);</span><br><span class="line">             amGraph.addEdge(&quot;D&quot;, &quot;E&quot;,12);</span><br><span class="line"></span><br><span class="line">             amGraph.bfs();</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A——9——&gt;B</span><br><span class="line">A——5——&gt;F</span><br><span class="line">B——7——&gt;C</span><br><span class="line">B——4——&gt;G</span><br><span class="line">B——6——&gt;I</span><br><span class="line">C——1——&gt;D</span><br><span class="line">D——12——&gt;E</span><br><span class="line">G——3——&gt;H</span><br></pre></td></tr></table></figure>

<h3 id="五、最小生成树"><a href="#五、最小生成树" class="headerlink" title="五、最小生成树"></a>五、最小生成树</h3><p>一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。</p>
<ul>
<li>最小生成树一般是指将带权图转换为总权最小、涉及所有节点的树结构。</li>
<li>最小生成树可以用kruskal（克鲁斯卡尔）算法或prim（普里姆）算法求出。</li>
</ul>
<p><strong><em>prim（普里姆）算法</em></strong></p>
<p><img src="/image/sjjg/plm.png" alt="普里姆"></p>
<p>JAVA代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">// 图-邻接矩阵- 网（带权无向图）</span><br><span class="line">public class AMGraphN&lt;T&gt; &#123;</span><br><span class="line">    //    顶点</span><br><span class="line">    private Object[] nodes;</span><br><span class="line">    //    边</span><br><span class="line">    private int[][] edges;</span><br><span class="line">    //    访问数组</span><br><span class="line">    private boolean[] visited;</span><br><span class="line">    private final int INIT_SIZE = 10;</span><br><span class="line"></span><br><span class="line">    private AMGraphN() &#123;</span><br><span class="line">        nodes = new Object[INIT_SIZE];</span><br><span class="line">        edges = new int[INIT_SIZE][INIT_SIZE];</span><br><span class="line">        visited = new boolean[INIT_SIZE];</span><br><span class="line">    &#125;</span><br><span class="line">    private AMGraphN (int size) &#123;</span><br><span class="line">        nodes = new Object[size];</span><br><span class="line">        edges = new int[size][size];</span><br><span class="line">        visited = new boolean[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Description 创建图</span><br><span class="line">     */</span><br><span class="line">    public static AMGraphN create(String[] nodes) &#123;</span><br><span class="line">        AMGraphN amGraph;</span><br><span class="line">        if (10 != nodes.length) &#123;</span><br><span class="line">            amGraph = new AMGraphN(nodes.length);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            amGraph = new AMGraphN();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i=0; i&lt;nodes.length;i++) &#123;</span><br><span class="line">            amGraph.nodes[i] = nodes[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return amGraph;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Description 添加边</span><br><span class="line">     * @param head 弧头</span><br><span class="line">     * @param tail 弧尾</span><br><span class="line">     * @param wegt 权重</span><br><span class="line">     */</span><br><span class="line">    public void addEdge (int head, int tail, int wegt) throws Exception &#123;</span><br><span class="line">        if (head &gt;= nodes.length &amp;&amp; tail &gt;= nodes.length) &#123;</span><br><span class="line">            throw new Exception(&quot;结点不存在&quot;);</span><br><span class="line">        &#125; else if (head&lt;0 &amp;&amp; tail&lt;0) &#123;</span><br><span class="line">            throw new Exception(&quot;结点不存在&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            edges[head][tail] = wegt;</span><br><span class="line">            edges[tail][head] = wegt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addEdge (T t, T t1, int wegt) throws Exception &#123;</span><br><span class="line">        addEdge(getIndex(t), getIndex(t1), wegt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Description 获取顶点索引</span><br><span class="line">     * @param t 元素</span><br><span class="line">     * @return 数组下标索引</span><br><span class="line">     */</span><br><span class="line">    public int getIndex (T t) &#123;</span><br><span class="line">        for (int i=0; i&lt; nodes.length; i++) &#123;</span><br><span class="line">            if (t.equals(nodes[i])) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //    遍历边</span><br><span class="line">    public void edges() &#123;</span><br><span class="line">        for (int i = 0; i&lt;visited.length; i++) &#123;</span><br><span class="line">            visited[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i&lt;visited.length; i++) &#123;</span><br><span class="line">            edges(i, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	   public void plm() &#123;</span><br><span class="line">//        已处理顶点</span><br><span class="line">        List&lt;Integer&gt; completed = new ArrayList&lt;&gt;();</span><br><span class="line">//        1.init</span><br><span class="line">        completed.add(0);</span><br><span class="line">        for (int i = 0; i&lt;visited.length; i++) &#123;</span><br><span class="line">            visited[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[0] = true;</span><br><span class="line"></span><br><span class="line">        do &#123;</span><br><span class="line">            int min_wdgt = -1;</span><br><span class="line">            int mh=-1, mt=-1;</span><br><span class="line">//            2. 获取到已处理集合路径最短的顶点</span><br><span class="line">            for (int index: completed) &#123;</span><br><span class="line">                for (int j=0; j&lt;nodes.length; j++) &#123;</span><br><span class="line">                    if (!visited[j] &amp;&amp; edges[index][j] != 0) &#123;</span><br><span class="line">                        int cost = edges[index][j];</span><br><span class="line">                        if (min_wdgt == -1 || cost &lt; min_wdgt) &#123;</span><br><span class="line">                            min_wdgt = cost;</span><br><span class="line">                            mh = index;</span><br><span class="line">                            mt = j;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">//            3.输出</span><br><span class="line">            System.out.println(nodes[mh]+&quot;——&quot;+edges[mh][mt]+&quot;——&quot;+nodes[mt]);</span><br><span class="line">            visited[mt]=true;</span><br><span class="line">            completed.add(mt);</span><br><span class="line">        &#125; while (completed.size() &lt; nodes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AMGraphN&lt;String&gt; amGraph = AMGraphN.create(new String[]&#123;&quot;V1&quot;,&quot;V2&quot;,&quot;V3&quot;,&quot;V4&quot;,&quot;V5&quot;,&quot;V6&quot;&#125;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            amGraph.addEdge(&quot;V1&quot;, &quot;V2&quot;,6);</span><br><span class="line">            amGraph.addEdge(&quot;V1&quot;, &quot;V3&quot;,1);</span><br><span class="line">            amGraph.addEdge(&quot;V1&quot;, &quot;V4&quot;,5);</span><br><span class="line">            amGraph.addEdge(&quot;V2&quot;, &quot;V3&quot;,5);</span><br><span class="line">            amGraph.addEdge(&quot;V3&quot;, &quot;V4&quot;,5);</span><br><span class="line">            amGraph.addEdge(&quot;V2&quot;, &quot;V5&quot;,3);</span><br><span class="line">            amGraph.addEdge(&quot;V3&quot;, &quot;V5&quot;,6);</span><br><span class="line">            amGraph.addEdge(&quot;V3&quot;, &quot;V6&quot;,4);</span><br><span class="line">            amGraph.addEdge(&quot;V4&quot;, &quot;V6&quot;,2);</span><br><span class="line">            amGraph.addEdge(&quot;V5&quot;, &quot;V6&quot;,6);</span><br><span class="line">            amGraph.plm();</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运算结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">V1——1——V3</span><br><span class="line">V3——4——V6</span><br><span class="line">V6——2——V4</span><br><span class="line">V3——5——V2</span><br><span class="line">V2——3——V5</span><br></pre></td></tr></table></figure>

<p>算法优化：<br>    添加环路判断，在找出最小节点后，需要在加入树之前通过在当前树中可否通过一个节点到达另一个节点</p>
<p><strong><em>kruskal（克鲁斯卡尔）算法</em></strong></p>
<p>算法思想</p>
<p>1.将图的所有连接线去掉，只剩顶点<br>2.从图的边集数组中找到权值最小的边，将边的两个顶点连接起来<br>3.继续寻找权值最小的边，将两个顶点之间连接起来，如果选择的边使得最小生成树出现了环路，则放弃该边，选择权值次小的边<br>4.直到所有的顶点都被连接在一起并且没有环路，最小生成树就生成了。</p>
<h3 id="六、最短路径"><a href="#六、最短路径" class="headerlink" title="六、最短路径"></a>六、最短路径</h3><p><img src="/image/sjjg/zdlj.png" alt="最短路径"></p>
<p><strong><em>迪杰斯特拉算法（Dijkstra）</em></strong></p>
<p>特点：</p>
<ul>
<li><code>单源最短路径</code>，求某个顶点到其它顶点的最短路径</li>
<li>遵循<code>路径长度递增的次序</code>原则</li>
<li>有环图，正序逆序皆可</li>
</ul>
<p>步骤如下：<br><img src="/image/sjjg/djstl.png" alt="迪杰斯特拉"></p>
<p><em>JAVA-无向图最短路径-迪杰斯特拉</em><br>注：数据参考上图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">// 无向图</span><br><span class="line">public class AMGraphN&lt;T&gt; &#123;</span><br><span class="line">	...</span><br><span class="line">    /**</span><br><span class="line">    * @Description 最短路径-迪杰斯特拉算法</span><br><span class="line">    * @param source 源点</span><br><span class="line">    * @param target 终点</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">    public void dijkstra(T source, T target) &#123;</span><br><span class="line">//        1.init</span><br><span class="line">        int si = getIndex(source);</span><br><span class="line">        int ti = getIndex(target);</span><br><span class="line">//        已处理顶点</span><br><span class="line">        for (int i = 0; i&lt;visited.length; i++) &#123;</span><br><span class="line">            visited[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[si] = true;</span><br><span class="line">		</span><br><span class="line">//      源点到各顶点的路径</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(si, 0);</span><br><span class="line"></span><br><span class="line">        do &#123;</span><br><span class="line">            int min_cost = -1;</span><br><span class="line">            int min_index = -1;</span><br><span class="line">            for (int i=0; i&lt;nodes.length; i++) &#123;</span><br><span class="line">                if (visited[i]) &#123;</span><br><span class="line">                    int tg = dijkstra(i);</span><br><span class="line">                    if (tg!=-1&amp;&amp;(min_cost == -1 || min_cost &gt; edges[i][tg]+map.get(i))) &#123;</span><br><span class="line">                        min_cost = edges[i][tg]+map.get(i);</span><br><span class="line">                        min_index = tg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(min_index, min_cost);</span><br><span class="line">            visited[min_index] = true;</span><br><span class="line">        &#125; while (map.size() &lt; nodes.length);</span><br><span class="line">        System.out.println(source+&quot;-&gt;&quot;+target+&quot;: &quot;+map.get(ti));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @Description 迪杰斯特拉-步骤一：获取某个顶点最短路径顶点</span><br><span class="line">    * @param node 顶点</span><br><span class="line">    * @return 顶点索引</span><br><span class="line">    */</span><br><span class="line">    private int dijkstra(int node) &#123;</span><br><span class="line">        int min_cost = -1, min_index = -1;</span><br><span class="line">        for (int j=0; j&lt;nodes.length; j++) &#123;</span><br><span class="line">//            判定成功条件：顶点没有被遍历，不是从起点到起点，存在边</span><br><span class="line">             if (!visited[j] &amp;&amp; j != node &amp;&amp; edges[node][j] != 0) &#123;</span><br><span class="line">                 if (min_cost == -1 || edges[node][j] &lt; min_cost) &#123;</span><br><span class="line">                     min_cost = edges[node][j];</span><br><span class="line">                     min_index = j;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return min_index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AMGraphN&lt;String&gt; amGraph = AMGraphN.create(new String[]&#123;&quot;V0&quot;,&quot;V1&quot;,&quot;V2&quot;,&quot;V3&quot;,&quot;V4&quot;&#125;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            amGraph.addEdge(&quot;V0&quot;, &quot;V1&quot;,4);</span><br><span class="line">            amGraph.addEdge(&quot;V0&quot;, &quot;V2&quot;,6);</span><br><span class="line">            amGraph.addEdge(&quot;V0&quot;, &quot;V3&quot;,9);</span><br><span class="line">            amGraph.addEdge(&quot;V1&quot;, &quot;V2&quot;,1);</span><br><span class="line">            amGraph.addEdge(&quot;V1&quot;, &quot;V4&quot;,4);</span><br><span class="line">            amGraph.addEdge(&quot;V2&quot;, &quot;V4&quot;,2);</span><br><span class="line">            amGraph.addEdge(&quot;V3&quot;, &quot;V2&quot;,2);</span><br><span class="line">            amGraph.dijkstra(&quot;V1&quot;,&quot;V4&quot;);</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  finally &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>弗洛伊德算法</em></strong></p>
<p>基本思想如下：</p>
<p>弗洛伊德算法定义了两个二维矩阵：</p>
<ul>
<li>矩阵D记录顶点间的最小路径 <ul>
<li>例如D[0][3]= 10，说明顶点0 到 3 的最短路径为10；</li>
</ul>
</li>
<li>矩阵P记录顶点间最小路径中的中转点 <ul>
<li>例如P[0][3]= 1 说明，0 到 3的最短路径轨迹为：0 -&gt; 1 -&gt; 3。</li>
</ul>
</li>
<li>它通过3重循环，k为中转点，v为起点，w为终点，循环比较D0[v][w] 和 D0[v][k] + D0[k][w] 最小值，如果D0[v][k] + D0[k][w] 为更小值，则把D0[v][k] + D0[k][w] 覆盖保存在D1[v][w]中。</li>
</ul>
<p><strong><em>应用</em></strong></p>
<p>导航时获取最短路径</p>
<h3 id="七、拓扑排序（有向无环图）"><a href="#七、拓扑排序（有向无环图）" class="headerlink" title="七、拓扑排序（有向无环图）"></a>七、拓扑排序（有向无环图）</h3><p><img src="/image/sjjg/tppx.png" alt="拓扑排序"></p>
<p><strong><em>实例</em></strong></p>
<p>如下所示，我们学习高等代数需要代数基础，而代数则不需要前置知识。</p>
<p><img src="/image/sjjg/tpjgsl.png" alt="拓扑排序1"></p>
<p>拓扑排序步骤：</p>
<ul>
<li>步骤一：我们会在无环有向图中，先选择没有前驱的顶点（通常这样的点会有多个，选择后驱较少的即可）</li>
<li>步骤二：删除它的对应边，然后将顶点加入到拓扑排序中</li>
<li>步骤三：重复步骤一</li>
</ul>
<p>注：由于没有前驱的顶点不只一个，所以拓扑排序一般可以有多个排序</p>
<p><strong><em>应用</em></strong></p>
<p>解决工程的顺序问题；</p>
<p>关键路径的使用</p>
<ul>
<li>在项目管理中，关键路径是指网络终端元素的元素的序列，该序列具有最长的总工期并决定了整个项目的最短完成时间。</li>
<li>关键路径的工期决定了整个项目的工期。任何关键路径上的终端元素的延迟将直接影响项目的预期完成时间（例如在关键路径上没有浮动时间）。</li>
<li>一个项目可以有多个，并行的关键路径。另一个总工期比关键路径的总工期略少的一条并行路径被称为次关键路径。</li>
<li>最初，关键路径方法只考虑终端元素之间的逻辑依赖关系。关键链方法中增加了资源约束。</li>
<li>关键路径方法是由杜邦公司发明的。</li>
</ul>
<h3 id="八、参考资料"><a href="#八、参考资料" class="headerlink" title="八、参考资料"></a>八、参考资料</h3><blockquote>
<p><a href="https://blog.csdn.net/yeruby/article/details/38615045" target="_blank" rel="noopener">最小生成树Prim算法理解</a><br><a href="https://www.bilibili.com/video/av52374596/" target="_blank" rel="noopener">第6章 图-迪杰斯特拉算法</a><br>大话数据结构-第七章</p>
</blockquote>
</div><div class="post-copyright"><blockquote><p>原文作者: 古城烟雨</p><p>原文链接: <a href="http://zws6672.top/2020/04/27/datastruct-6/">http://zws6672.top/2020/04/27/datastruct-6/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/算法/">算法</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/04/30/sf-1/" class="pre">算法（一）查询</a><a href="/2020/04/20/datastruct-5/" class="next">数据结构（六）树</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、基本概念"><span class="toc-text">一、基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、抽象数据类型"><span class="toc-text">二、抽象数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、存储结构"><span class="toc-text">三、存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、遍历"><span class="toc-text">四、遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、最小生成树"><span class="toc-text">五、最小生成树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六、最短路径"><span class="toc-text">六、最短路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#七、拓扑排序（有向无环图）"><span class="toc-text">七、拓扑排序（有向无环图）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#八、参考资料"><span class="toc-text">八、参考资料</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/fmi-daccosim/">基于FMI标准的仿真软件————Daccosim</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/vue_add_method/">vue_add_method</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/test/">test</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/springboot-1/">springboot（一）入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/26/jdk-bytecodeEngine/">虚拟机字节码执行引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/15/jdk-cload/">虚拟机类加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/14/jdk-classesFileStruct/">深入理解Java虚拟机——类文件结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/04/springboot-aop/">SpringBoot 使用 AOP（面向切面编程）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/30/mysql-lock/">mysql 引擎的行锁与表锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/29/design-structure-eg/">结构型模式——实例</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/devops/" style="font-size: 15px;">devops</a> <a href="/tags/neo4j/" style="font-size: 15px;">neo4j</a> <a href="/tags/CI/" style="font-size: 15px;">CI</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/oracle/" style="font-size: 15px;">oracle</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/系统/" style="font-size: 15px;">系统</a> <a href="/tags/博客搭建/" style="font-size: 15px;">博客搭建</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/ms/" style="font-size: 15px;">ms</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/运维/" style="font-size: 15px;">运维</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/javaweb/" style="font-size: 15px;">javaweb</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/微服务/" style="font-size: 15px;">微服务</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/elasticsearch/" style="font-size: 15px;">elasticsearch</a> <a href="/tags/fmi/" style="font-size: 15px;">fmi</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/nk/" style="font-size: 15px;">nk</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://juejin.im/" title="掘金" target="_blank">掘金</a><ul></ul><a href="https://www.cnblogs.com/" title="博客园" target="_blank">博客园</a><ul></ul><a href="https://www.infoq.cn/" title="info" target="_blank">info</a><ul></ul><a href="https://www.ibm.com/" title="ibm" target="_blank">ibm</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">古城烟雨.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>
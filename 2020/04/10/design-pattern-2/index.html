<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一些关于技术的碎语"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>设计模式（二）结构型模式 | 微言术语</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">设计模式（二）结构型模式</h1><a id="logo" href="/.">微言术语</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">设计模式（二）结构型模式</h1><div class="post-meta"><a href="/2020/04/10/design-pattern-2/#comments" class="comment-count"></a><p><span class="date">Apr 10, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><table>
<thead>
<tr>
<th align="left">范围\目的</th>
<th align="left">结构型模式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">类模式</td>
<td align="left">(类）适配器</td>
</tr>
<tr>
<td align="left">对象模式</td>
<td align="left">代理<br>(对象）适配器<br>桥接<br>装饰<br>外观<br>享元<br>组合</td>
</tr>
</tbody></table>
<p>结构型模式：描述了如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<ul>
<li>组合：部分与整体是与生俱来的，部分的存在依赖于整体，部分无法独立存在。</li>
<li>聚合：部分与整体是松散的，部分不依赖于整体，可以独立存在。动态组合，称之为聚合。</li>
</ul>
<p>结构型模式分为以下 7 种：</p>
<ul>
<li>代理（Proxy）模式：代理访问，隐藏实现，代理类需要实现被代理类相同的接口。</li>
<li>适配器（Adapter）模式：转换接口，避免接口不兼容。</li>
<li>桥接（Bridge）模式：将抽象与实现分离，用组合关系代替继承关系。</li>
<li>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</li>
<li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
</ul>
<hr>
<h1 id="适配器模式——适配不兼容接口"><a href="#适配器模式——适配不兼容接口" class="headerlink" title="适配器模式——适配不兼容接口"></a>适配器模式——适配不兼容接口</h1><p><strong><em>定义</em></strong></p>
<p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<p>该模式的主要优点如下。</p>
<ul>
<li>客户端通过适配器可以<code>透明地调用目标接口</code>。</li>
<li><code>复用了现存的类</code>，程序员不需要修改原有代码而重用现有的适配者类。</li>
<li><code>将目标类和适配者类解耦</code>，解决了目标类和适配者类接口不一致的问题。</li>
</ul>
<p>其缺点是：对类适配器来说，更换适配器的实现过程比较复杂。</p>
<p><strong><em>结构</em></strong></p>
<p>适配器模式（Adapter）包含以下主要角色。</p>
<ul>
<li>目标（Target）接口：业务所需要的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ul>
<p><img src="/image/degin-pattern/spqms.png" alt="适配器模式"></p>
<p><strong><em>类适配器</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 适配器</span><br><span class="line">public class MyAdapter extends MyAdaptee implements Target&#123;</span><br><span class="line">    // 实际需要的方法</span><br><span class="line">    @Override</span><br><span class="line">    public void haha() &#123;</span><br><span class="line">        System.out.println(&quot;业务代码1&quot;);</span><br><span class="line">        hello();</span><br><span class="line">        System.out.println(&quot;业务代码2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 需要的接口</span><br><span class="line">interface Target &#123;</span><br><span class="line">    void haha();</span><br><span class="line">&#125;</span><br><span class="line">// 适配者</span><br><span class="line">class MyAdaptee &#123;</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>对象适配器</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 适配器模式是为了在不重构旧接口的情况下，启用新的接口又能使用旧接口服务</span><br><span class="line"></span><br><span class="line">// 对象适配器</span><br><span class="line">// 不继承适配者，因为继承会破坏类的封装性；通过组合的方式来使用适配者</span><br><span class="line">public class MyAdapter2 implements Target2&#123;</span><br><span class="line">    MyAdaptee2 myAdaptee2;</span><br><span class="line">    public MyAdapter2(MyAdaptee2 myAdaptee) &#123;</span><br><span class="line">        this.myAdaptee2 = myAdaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void haha() &#123;</span><br><span class="line">        System.out.println(&quot;业务代码1&quot;);</span><br><span class="line">        myAdaptee2.hello();</span><br><span class="line">        System.out.println(&quot;业务代码2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 需要的接口</span><br><span class="line">interface Target2 &#123;</span><br><span class="line">    void haha();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 旧接口</span><br><span class="line">interface OldTarget2 &#123;</span><br><span class="line">    public void hello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 适配者</span><br><span class="line">class MyAdaptee2 implements OldTarget2&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="代理模式——隐藏实现细节"><a href="#代理模式——隐藏实现细节" class="headerlink" title="代理模式——隐藏实现细节"></a>代理模式——隐藏实现细节</h1><p><strong><em>定义</em></strong></p>
<p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>代理模式的主要优点有：<br>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；<br>代理对象可以扩展目标对象的功能；<br>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</p>
<p>其主要缺点是：<br>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；<br>增加了系统的复杂度；</p>
<blockquote>
<p>注：这符合迪米特法则，即最少知识原则；减少类与类的通讯，而是通过代理进行访问。但是，代理模式也使得代码阅读性较差。</p>
</blockquote>
<p><strong><em>结构</em></strong></p>
<ul>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ul>
<p><img src="/image/degin-pattern/dlms.png" alt="代理模式"></p>
<p><strong><em>代理模式实例</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*代理*/</span><br><span class="line">public class MyProxy implements Subject&#123;</span><br><span class="line">    RealSUbject realSUbject;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void hello() &#123;</span><br><span class="line">        if (realSUbject == null) &#123;</span><br><span class="line">            realSUbject = new RealSUbject();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSUbject.hello();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    public void preRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;访问真实主题之前的预处理。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void postRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;访问真实主题之后的后续处理。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*抽象主题*/</span><br><span class="line">interface Subject &#123;</span><br><span class="line">    void hello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*真实主题*/</span><br><span class="line">class RealSUbject implements Subject &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(&quot;这是真实主题&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代理模式与适配器模式的区别</em></strong></p>
<p>适配器模式：当旧的接口无法满足新的需求，我们无法修改或者替换旧的接口，可以将新接口转换成旧接口（即新接口需要有旧接口的所有方法）；早期的枚举接口是Enumeration而后定义的枚举接口是Iterator;有很多旧的类实现了enumeration接口暴露出了一些服务，但是这些服务我们现在想通过传入Iterator接口而不是Enumeration接口来调用，这时就需要一个适配器。</p>
<p>代理模式：实现的接口与旧接口完全一致，不存在扩展；只是为了隐藏方法的具体实现，而是通过代理进行处理。</p>
<hr>
<h1 id="桥接模式——抽象与实现分离"><a href="#桥接模式——抽象与实现分离" class="headerlink" title="桥接模式——抽象与实现分离"></a>桥接模式——抽象与实现分离</h1><p><strong><em>定义</em></strong></p>
<p>桥接（Bridge）模式的定义如下：</p>
<ul>
<li>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li>
</ul>
<p>桥接（Bridge）模式的优点是：</p>
<ul>
<li>由于抽象与实现分离，所以扩展能力强；</li>
<li>其实现细节对客户透明。</li>
</ul>
<p>缺点是：</p>
<ul>
<li>由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。</li>
</ul>
<p><strong><em>结构</em></strong></p>
<p>桥接（Bridge）模式包含以下主要角色。</p>
<ul>
<li>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</li>
<li>扩展抽象化（Refined    Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li>
<li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</li>
<li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</li>
</ul>
<p>如下图所示，例如自行车是一种交通工具，但依据使用地段的不同可以分为公路自行车、场地自行车，这是一种维度；而对于公路自行车来说，也有许多款式，这是第二种维度。<br><img src="/image/degin-pattern/qjms.png" alt="桥接模式"></p>
<p><strong><em>桥接模式实例</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MyBridge &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyImplementor myImplementor = new ConcreteImplementorA();</span><br><span class="line">        Abstraction abstraction = new ExtendAbstraction(myImplementor);</span><br><span class="line">        abstraction.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现化角色</span><br><span class="line">interface MyImplementor &#123;</span><br><span class="line">    void helloImpl();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体实现化角色A</span><br><span class="line">class ConcreteImplementorA implements MyImplementor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void helloImpl() &#123;</span><br><span class="line">        System.out.println(&quot;具体实现化角色A:hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象角色</span><br><span class="line">// 抽象类中的方法需要显式声明为抽象的</span><br><span class="line">abstract class Abstraction &#123;</span><br><span class="line">    protected MyImplementor myImplementor;</span><br><span class="line">    public Abstraction(MyImplementor myImplementor) &#123;</span><br><span class="line">        this.myImplementor = myImplementor;</span><br><span class="line">    &#125;</span><br><span class="line">    abstract void hello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象角色实现</span><br><span class="line">class ExtendAbstraction extends Abstraction &#123;</span><br><span class="line">    public ExtendAbstraction(MyImplementor myImplementor) &#123;</span><br><span class="line">        super(myImplementor);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    void hello() &#123;</span><br><span class="line">        myImplementor.helloImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="装饰模式——动态增加职责"><a href="#装饰模式——动态增加职责" class="headerlink" title="装饰模式——动态增加职责"></a>装饰模式——动态增加职责</h1><p><strong><em>定义</em></strong></p>
<p>装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<p>装饰（Decorator）模式的主要优点有：</p>
<ul>
<li>采用装饰模式扩展对象的功能比采用继承方式更加灵活。</li>
<li>可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。</li>
</ul>
<p>其主要缺点是：装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。</p>
<p><strong><em>结构</em></strong></p>
<p>装饰模式主要包含以下角色。</p>
<ul>
<li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（Concrete    Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ul>
<p><img src="/image/degin-pattern/zsms.png" alt="装饰模式"></p>
<p><strong><em>实例</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class MyDecorator &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Component component = new ConcreteComponent();</span><br><span class="line">        Component d = new ConcreteDecorator(component);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//抽象构件角色</span><br><span class="line">interface  Component &#123;</span><br><span class="line">    void operation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体构件角色</span><br><span class="line">class ConcreteComponent implements Component &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        System.out.println(&quot;基本构件&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象装饰角色</span><br><span class="line">abstract class Decorator implements Component &#123;</span><br><span class="line">    Component component;</span><br><span class="line"></span><br><span class="line">    public Decorator(Component component) &#123;</span><br><span class="line">        this.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体装饰角色</span><br><span class="line">class ConcreteDecorator extends Decorator &#123;</span><br><span class="line"></span><br><span class="line">    public ConcreteDecorator(Component component) &#123;</span><br><span class="line">        super(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        super.operation();</span><br><span class="line">        addDecor();</span><br><span class="line">    &#125;</span><br><span class="line">    void addDecor() &#123;</span><br><span class="line">        System.out.println(&quot;额外装饰&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>扩展：JDK中装饰模式的使用</em></strong></p>
<p>在Java的IO流中，用到了装饰模式。<code>FilterInputStream</code>就是一个经典的抽象装饰类，拥有多个具体装饰类。而<code>FileInputStream</code>是一个具体构件，InputStream是抽象构件。<br>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">// 抽象构件</span><br><span class="line">public abstract class InputStream implements Closeable &#123;</span><br><span class="line">	...</span><br><span class="line">	public abstract int read() throws IOException;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体构件</span><br><span class="line">public class FileInputStream extends InputStream &#123;</span><br><span class="line">	...</span><br><span class="line">	public int read() throws IOException &#123;</span><br><span class="line">        return read0();</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象装饰类</span><br><span class="line">public class FilterInputStream extends InputStream &#123;</span><br><span class="line">	...</span><br><span class="line">	protected volatile InputStream in;</span><br><span class="line">	</span><br><span class="line">    protected FilterInputStream(InputStream in) &#123;</span><br><span class="line">        this.in = in;</span><br><span class="line">    &#125;</span><br><span class="line">	public int read() throws IOException &#123;</span><br><span class="line">        return in.read();</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体装饰类</span><br><span class="line">public class BufferedInputStream extends FilterInputStream &#123;</span><br><span class="line">	...</span><br><span class="line">	public synchronized int read() throws IOException &#123;</span><br><span class="line">		// 缓冲区读取结束，重新填充</span><br><span class="line">        if (pos &gt;= count) &#123;</span><br><span class="line">            fill();</span><br><span class="line">            if (pos &gt;= count)</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return getBufIfOpen()[pos++] &amp; 0xff;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	private void fill() throws IOException &#123;</span><br><span class="line">        byte[] buffer = getBufIfOpen();</span><br><span class="line">        if (markpos &lt; 0)</span><br><span class="line">            pos = 0;            /* no mark: throw away the buffer */</span><br><span class="line">        else if (pos &gt;= buffer.length)  /* no room left in buffer */</span><br><span class="line">            if (markpos &gt; 0) &#123;  /* can throw away early part of the buffer */</span><br><span class="line">                int sz = pos - markpos;</span><br><span class="line">                System.arraycopy(buffer, markpos, buffer, 0, sz);</span><br><span class="line">                pos = sz;</span><br><span class="line">                markpos = 0;</span><br><span class="line">            &#125; else if (buffer.length &gt;= marklimit) &#123;</span><br><span class="line">                markpos = -1;   /* buffer got too big, invalidate mark */</span><br><span class="line">                pos = 0;        /* drop buffer contents */</span><br><span class="line">            &#125; else if (buffer.length &gt;= MAX_BUFFER_SIZE) &#123;</span><br><span class="line">                throw new OutOfMemoryError(&quot;Required array size too large&quot;);</span><br><span class="line">            &#125; else &#123;            /* grow buffer */</span><br><span class="line">                int nsz = (pos &lt;= MAX_BUFFER_SIZE - pos) ?</span><br><span class="line">                        pos * 2 : MAX_BUFFER_SIZE;</span><br><span class="line">                if (nsz &gt; marklimit)</span><br><span class="line">                    nsz = marklimit;</span><br><span class="line">                byte nbuf[] = new byte[nsz];</span><br><span class="line">                System.arraycopy(buffer, 0, nbuf, 0, pos);</span><br><span class="line">                if (!bufUpdater.compareAndSet(this, buffer, nbuf)) &#123;</span><br><span class="line">                    // Can&apos;t replace buf if there was an async close.</span><br><span class="line">                    // Note: This would need to be changed if fill()</span><br><span class="line">                    // is ever made accessible to multiple threads.</span><br><span class="line">                    // But for now, the only way CAS can fail is via close.</span><br><span class="line">                    // assert buf == null;</span><br><span class="line">                    throw new IOException(&quot;Stream closed&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                buffer = nbuf;</span><br><span class="line">            &#125;</span><br><span class="line">        count = pos;</span><br><span class="line">		// 获取基础构件，调用read方法</span><br><span class="line">        int n = getInIfOpen().read(buffer, pos, buffer.length - pos);</span><br><span class="line">        if (n &gt; 0)</span><br><span class="line">            count = n + pos;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以从以上的源码看出，在读取文件的时候，<code>BufferedInputStream</code>借助装饰模式对FileInputStream的读取方法进行了拓展，添加了缓冲功能。</p>
<hr>
<h1 id="外观模式——为子系统中接口提供一致的界面"><a href="#外观模式——为子系统中接口提供一致的界面" class="headerlink" title="外观模式——为子系统中接口提供一致的界面"></a>外观模式——为子系统中接口提供一致的界面</h1><p><strong><em>定义</em></strong></p>
<p>外观（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>
<p>外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点：</p>
<ul>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
<li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>
</ul>
<p>外观（Facade）模式的主要缺点如下</p>
<ul>
<li>不能很好地限制客户使用子系统类。</li>
<li>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
</ul>
<p><strong><em>结构</em></strong></p>
<p>外观（Facade）模式包含以下主要角色。</p>
<ul>
<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li>
<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li>
<li>客户（Client）角色：通过一个外观角色访问各个子系统的功能。</li>
</ul>
<p><img src="/image/degin-pattern/wgms.png" alt="外观模式"></p>
<p><strong><em>实例</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class FacadePattern &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Facade f=new Facade();</span><br><span class="line">        f.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Facade &#123;</span><br><span class="line">    private SubSystem01 obj1=new SubSystem01();</span><br><span class="line">    private SubSystem02 obj2=new SubSystem02();</span><br><span class="line">    private SubSystem03 obj3=new SubSystem03();</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem01</span><br><span class="line">&#123;</span><br><span class="line">    public  void method1() &#123;</span><br><span class="line">        System.out.println(&quot;子系统01的method1()被调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem02</span><br><span class="line">&#123;</span><br><span class="line">    public  void method2() &#123;</span><br><span class="line">        System.out.println(&quot;子系统02的method2()被调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem03</span><br><span class="line">&#123;</span><br><span class="line">    public  void method3() &#123;</span><br><span class="line">        System.out.println(&quot;子系统03的method3()被调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="享元模式——共享内部数据"><a href="#享元模式——共享内部数据" class="headerlink" title="享元模式——共享内部数据"></a>享元模式——共享内部数据</h1><p><strong><em>定义</em></strong></p>
<p>享元（Flyweight）模式的定义：运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
<p>享元模式的主要优点是：</p>
<ul>
<li>相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</li>
</ul>
<p>其主要缺点是：</p>
<ul>
<li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</li>
<li>读取享元模式的外部状态会使得运行时间稍微变长。</li>
</ul>
<p><strong><em>结构</em></strong></p>
<p>享元模式中存在以下两种状态：</p>
<ul>
<li>内部状态，即不会随着环境的改变而改变的可共享部分；</li>
<li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化</li>
</ul>
<p>享元模式的主要角色有如下。</p>
<ul>
<li>抽象享元角色（Flyweight）:是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。</li>
<li>具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。</li>
<li>非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。</li>
<li>享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li>
</ul>
<p><img src="/image/degin-pattern/xyms.png" alt="享元模式"></p>
<p><strong><em>实例</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class FlyweightPattern &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FlyweightFactory flyweightFactory = new FlyweightFactory();</span><br><span class="line">        Flyweight f01 = flyweightFactory.getFlyweight(&quot;a&quot;);</span><br><span class="line">        f01.opra(new UnsharedFlyweight(&quot;第一次调用a&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 非享元角色</span><br><span class="line">class UnsharedFlyweight &#123;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    public UnsharedFlyweight(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象享元角色</span><br><span class="line">interface Flyweight &#123;</span><br><span class="line">    void opra(UnsharedFlyweight unsharedFlyweight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//具体享元角色</span><br><span class="line">class ConcreteFlyweight implements Flyweight &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public ConcreteFlyweight(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void opra(UnsharedFlyweight unsharedFlyweight) &#123;</span><br><span class="line">        System.out.println(&quot;享元信息：&quot;+name);</span><br><span class="line">        System.out.println(&quot;非享元信息：&quot;+unsharedFlyweight.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//享元工厂</span><br><span class="line">class FlyweightFactory &#123;</span><br><span class="line">    private HashMap&lt;String, Flyweight&gt; flyweightHashMap = new HashMap&lt;&gt;();</span><br><span class="line">    public synchronized Flyweight getFlyweight (String name) &#123;</span><br><span class="line">        Flyweight flyweight = flyweightHashMap.get(name);</span><br><span class="line">        if (flyweight == null) &#123;</span><br><span class="line">            flyweight = new ConcreteFlyweight(name);</span><br><span class="line">            flyweightHashMap.put(name, flyweight);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;享元 &quot;+name+&quot; 已存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="组合模式——动态访问"><a href="#组合模式——动态访问" class="headerlink" title="组合模式——动态访问"></a>组合模式——动态访问</h1><p><strong><em>定义</em></strong></p>
<p>组合（Composite）模式的定义：</p>
<ul>
<li>有时又叫作部分-整体模式，它是一种<code>将对象组合成树状的层次结构</code>的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</li>
</ul>
<p>组合模式的主要优点有：</p>
<ul>
<li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li>
<li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li>
</ul>
<p>其主要缺点是：</p>
<ul>
<li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li>
<li>不容易限制容器中的构件；</li>
<li>不容易用继承的方法来增加构件的新功能；</li>
</ul>
<p><strong><em>结构</em></strong></p>
<p>组合模式包含以下主要角色。</p>
<ul>
<li>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</li>
<li>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。</li>
<li>树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。</li>
</ul>
<p>组合模式分为：</p>
<ul>
<li>透明式的组合模式<ul>
<li>由于抽象构件声明了两种构件中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的</li>
</ul>
</li>
</ul>
<p><img src="/image/degin-pattern/zhms.png" alt="组合模式"></p>
<ul>
<li>安全式的组合模式<ul>
<li>将管理树叶构件的任务交付给树枝构件，抽象构件和树叶构件没有对子对象的管理方法，避免了安全问题。但是，客户端调用时需要了解构件的类型，这就失去了透明性。</li>
</ul>
</li>
</ul>
<p><img src="/image/degin-pattern/zhms1.png" alt="组合模式"></p>
<p><strong><em>实例</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class CompositePattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Component c0=new Composite(); </span><br><span class="line">        Component c1=new Composite(); </span><br><span class="line">        Component leaf1=new Leaf(&quot;1&quot;); </span><br><span class="line">        Component leaf2=new Leaf(&quot;2&quot;); </span><br><span class="line">        Component leaf3=new Leaf(&quot;3&quot;);          </span><br><span class="line">        c0.add(leaf1); </span><br><span class="line">        c0.add(c1);</span><br><span class="line">        c1.add(leaf2); </span><br><span class="line">        c1.add(leaf3);          </span><br><span class="line">        c0.operation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象构件</span><br><span class="line">interface Component</span><br><span class="line">&#123;</span><br><span class="line">    public void add(Component c);</span><br><span class="line">    public void remove(Component c);</span><br><span class="line">    public Component getChild(int i);</span><br><span class="line">    public void operation();</span><br><span class="line">&#125;</span><br><span class="line">//树叶构件</span><br><span class="line">class Leaf implements Component</span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public Leaf(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void add(Component c)&#123; &#125;           </span><br><span class="line">    public void remove(Component c)&#123; &#125;   </span><br><span class="line">    public Component getChild(int i)</span><br><span class="line">    &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;   </span><br><span class="line">    public void operation()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;树叶&quot;+name+&quot;：被访问！&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//树枝构件</span><br><span class="line">class Composite implements Component</span><br><span class="line">&#123;</span><br><span class="line">    private ArrayList&lt;Component&gt; children=new ArrayList&lt;Component&gt;();   </span><br><span class="line">    public void add(Component c)</span><br><span class="line">    &#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    public void remove(Component c)</span><br><span class="line">    &#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    public Component getChild(int i)</span><br><span class="line">    &#123;</span><br><span class="line">        return children.get(i);</span><br><span class="line">    &#125;   </span><br><span class="line">    public void operation()</span><br><span class="line">    &#123;</span><br><span class="line">        for(Object obj:children)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Component)obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>组合模式的应用场景</em></strong></p>
<p>前面分析了组合模式的结构与特点，下面分析它适用的以下应用场景。</p>
<ul>
<li>在需要表示一个对象整体与部分的层次结构的场合。</li>
<li>要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。</li>
</ul>
<hr>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><blockquote>
<p><a href="https://www.cnblogs.com/alsf/p/8506912.html" target="_blank" rel="noopener">模式的秘密-适配器模式和代理模式的区别</a></p>
</blockquote>
</div><div class="post-copyright"><blockquote><p>原文作者: 古城烟雨</p><p>原文链接: <a href="http://zws6672.top/2020/04/10/design-pattern-2/">http://zws6672.top/2020/04/10/design-pattern-2/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/设计模式/">设计模式</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/04/10/design-pattern-3/" class="pre">设计模式（三）行为型模式</a><a href="/2020/04/10/desgin-pattern-1/" class="next">设计模式（一）创建型模式</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#适配器模式——适配不兼容接口"><span class="toc-text">适配器模式——适配不兼容接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#代理模式——隐藏实现细节"><span class="toc-text">代理模式——隐藏实现细节</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#桥接模式——抽象与实现分离"><span class="toc-text">桥接模式——抽象与实现分离</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#装饰模式——动态增加职责"><span class="toc-text">装饰模式——动态增加职责</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#外观模式——为子系统中接口提供一致的界面"><span class="toc-text">外观模式——为子系统中接口提供一致的界面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#享元模式——共享内部数据"><span class="toc-text">享元模式——共享内部数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#组合模式——动态访问"><span class="toc-text">组合模式——动态访问</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考文章"><span class="toc-text">参考文章</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/mysql-opt/">MySQL 优化(一)设计与功能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/tool-uml/">UML中关系</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/fmi-ssp-dcp/">了解fmi、ssp与dcp</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/hexo-sync/">多PC同步hexo</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/fmi-daccosim/">基于FMI标准的仿真软件————Daccosim</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/springboot-1/">springboot（一）入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/13/jdk-backend-compile/">后端编译与优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/13/jdk-front-compile/">前端编译与优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/26/jdk-bytecodeEngine/">虚拟机字节码执行引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/15/jdk-cload/">虚拟机类加载机制</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/devops/" style="font-size: 15px;">devops</a> <a href="/tags/CI/" style="font-size: 15px;">CI</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/neo4j/" style="font-size: 15px;">neo4j</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/oracle/" style="font-size: 15px;">oracle</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/系统/" style="font-size: 15px;">系统</a> <a href="/tags/博客搭建/" style="font-size: 15px;">博客搭建</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/ms/" style="font-size: 15px;">ms</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/运维/" style="font-size: 15px;">运维</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/javaweb/" style="font-size: 15px;">javaweb</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/elasticsearch/" style="font-size: 15px;">elasticsearch</a> <a href="/tags/fmi/" style="font-size: 15px;">fmi</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/微服务/" style="font-size: 15px;">微服务</a> <a href="/tags/soft-skills/" style="font-size: 15px;">soft-skills</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/nk/" style="font-size: 15px;">nk</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://juejin.im/" title="掘金" target="_blank">掘金</a><ul></ul><a href="https://www.cnblogs.com/" title="博客园" target="_blank">博客园</a><ul></ul><a href="https://www.infoq.cn/" title="info" target="_blank">info</a><ul></ul><a href="https://www.ibm.com/" title="ibm" target="_blank">ibm</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">古城烟雨.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一些关于技术的碎语"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>leetcode-20200914-20200917 | 微言术语</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">leetcode-20200914-20200917</h1><a id="logo" href="/.">微言术语</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">leetcode-20200914-20200917</h1><div class="post-meta"><a href="/2020/09/18/leetcode-20200914-20200917/#comments" class="comment-count"></a><p><span class="date">Sep 18, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a></h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
</blockquote>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>方法一：动态规划</p>
<ol>
<li>大问题中找到子问题：求G(n)，即求[1,n]的解的和，那就先以其中的i(1&lt;=i&lt;=n)为顶点, 记为f(i)</li>
<li>解决子问题：i为顶点的解，为G[i-1] * G[n-i]的解。</li>
<li>合并子问题求的大问题的解: G[n] = f(1) +….+f(i) + …f(n)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numTrees(int n) &#123;</span><br><span class="line">        int[] dp = new int[n+1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        </span><br><span class="line">        for(int i = 2; i &lt; n + 1; i++)</span><br><span class="line">            for(int j = 1; j &lt; i + 1; j++) </span><br><span class="line">                dp[i] += dp[j-1] * dp[i-j];</span><br><span class="line">        </span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：数学</p>
<p>事实上我们在方法一中推导出的 G(n)G(n)函数的值在数学上被称为卡塔兰数。卡塔兰数更便于计算的定义如下:</p>
<p><img src="/image/leetcode/unique-binary-search-trees.png" alt="卡塔兰数"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numTrees(int n) &#123;</span><br><span class="line">        // 提示：我们在这里需要用 long 类型防止计算过程中的溢出</span><br><span class="line">        long C = 1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            C = C * 2 * (2 * i + 1) / (i + 2);</span><br><span class="line">        &#125;</span><br><span class="line">        return (int) C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a></h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">说明:</span><br><span class="line">1 ≤ m ≤ n ≤ 链表长度。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseBetween(ListNode head, int m, int n) &#123;</span><br><span class="line">        ListNode dummyHead = new ListNode(0);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode g = dummyHead;</span><br><span class="line">        ListNode p = dummyHead.next;</span><br><span class="line"></span><br><span class="line">        int step = 0;</span><br><span class="line">        while (step &lt; m - 1) &#123;</span><br><span class="line">            g = g.next; p = p.next;</span><br><span class="line">            step ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n - m; i++) &#123;</span><br><span class="line">            ListNode removed = p.next;</span><br><span class="line">            p.next = p.next.next;</span><br><span class="line"></span><br><span class="line">            removed.next = g.next;</span><br><span class="line">            g.next = removed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="版本数组"><a href="#版本数组" class="headerlink" title="版本数组"></a>版本数组</h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>服务端测试：目前你正在领导团队开发一款新软件。你在检查项目的时候发现最后一个版本的测试没有通过，并且你知道只要上一个版本有错误，此面版本都会是错误的。 假设你有S个版本数组【1,2,3,4…,S】，你想找出最早发生错误的版本。假设查找版本的API是 IsBug(Sn) 传入版本号就会返误。 请使用API写一个函数用尽量少的步骤找出这第一个出错的版本号。</p>
</blockquote>
<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">    public Sn searchBug(Sn[]arr) &#123;</span><br><span class="line">        for(Sn sn: arr) &#123;</span><br><span class="line">            if(IsBug(sn)) &#123;</span><br><span class="line">                return sn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean IsBug(Sn sn) &#123;</span><br><span class="line">        return sn.isBug;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sn &#123;</span><br><span class="line">    public Sn(boolean isBug) &#123;</span><br><span class="line">        this.isBug = isBug;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean isBug;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="统计字符串中数字和字母的出现次数"><a href="#统计字符串中数字和字母的出现次数" class="headerlink" title="统计字符串中数字和字母的出现次数"></a>统计字符串中数字和字母的出现次数</h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>服务端测试：给定一个字符串A，字符串由所有数字和字母组成，求这个字符串里面所出现的数字和字母，同时统计这些数字和字母的出现次数。例:INPUT:A=”aaaBBBaaA23”….OUTPUT:{A:1,B:3,a:5,2:1,3:1}</p>
</blockquote>
<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Map getTimes (String str) &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; result = new HashMap&lt;Character, Integer&gt;();</span><br><span class="line">    for(Character cr: str.toCharArray()) &#123;</span><br><span class="line">        result.put(cr, result.get(cr)==null?1:result.get(cr)+1);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pow-x-n"><a href="#pow-x-n" class="headerlink" title="pow(x, n)"></a><a href>pow(x, n)</a></h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 = 1/22 = 1/4 = 0.25</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">-100.0 &lt; x &lt; 100.0</span><br><span class="line">n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p><a href="https://leetcode-cn.com/problems/powx-n/solution/50-powx-n-kuai-su-mi-qing-xi-tu-jie-by-jyd/" target="_blank" rel="noopener">快速幂解法</a></p>
<p><img src="/image/leetcode/powx-n.png" alt="powx-n"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public double myPow(double x, int n) &#123;</span><br><span class="line">        if(x == 0.0f) return 0.0d;</span><br><span class="line">        long b = n;</span><br><span class="line">        double res = 1.0;</span><br><span class="line">        if(b &lt; 0) &#123;</span><br><span class="line">            x = 1 / x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        while(b &gt; 0) &#123;</span><br><span class="line">            if((b &amp; 1) == 1) res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            b &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">134. 加油站</a></h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
</blockquote>
<p>说明: </p>
<ul>
<li>如果题目有解，该答案即为唯一答案。</li>
<li>输入数组均为非空数组，且长度相同。</li>
<li>输入数组中的元素均为非负数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">gas  = [1,2,3,4,5]</span><br><span class="line">cost = [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">gas  = [2,3,4]</span><br><span class="line">cost = [3,4,3]</span><br><span class="line"></span><br><span class="line">输出: -1</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-- 击败了100.00%</span><br><span class="line">gas  = [1,2,3,4,5]</span><br><span class="line">cost = [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">gas  = [-2,-2,-2,3,3]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">		// 计算当前为起点，到下个加油点的变化</span><br><span class="line">        for(int i=0; i&lt; gas.length; i++) &#123;</span><br><span class="line">            gas[i] = gas[i]-cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        int minvalue = 0, minindex=-1;</span><br><span class="line">		</span><br><span class="line">		// 计算变化的总值，为负则无法跑完一圈</span><br><span class="line">        for(int i=0; i&lt;gas.length; i++) &#123;</span><br><span class="line">            sum+=gas[i];</span><br><span class="line">			//从0开始遍历，找到汽油损耗最大的加油点，下一个加油点为目标起始点</span><br><span class="line">            if(sum&lt;minvalue) &#123;</span><br><span class="line">                minvalue=sum;</span><br><span class="line">                minindex=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum&lt;0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return minindex+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表重排序"><a href="#链表重排序" class="headerlink" title="链表重排序"></a><a href>链表重排序</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个单链表 L：L0→L1→…→Ln-1→Ln ，</span><br><span class="line">将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</span><br><span class="line"></span><br><span class="line">你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>解法一：遍历，通过数组重组列表;注意边界控制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void reorderList(ListNode head) &#123;</span><br><span class="line">        List&lt;ListNode&gt; list = new ArrayList&lt;ListNode&gt;();</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        while(temp != null) &#123;</span><br><span class="line">            list.add(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(list.size()&lt;=2) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = head;</span><br><span class="line"></span><br><span class="line">        for(int i=0,j=list.size()-1; i&lt;=j; i++, j--) &#123;</span><br><span class="line">            list.get(i).next = list.get(j);</span><br><span class="line">            </span><br><span class="line">            if(i+1 !=j) &#123;</span><br><span class="line">                list.get(j).next = list.get(i+1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                list.get(j).next = null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(i+2==j) &#123;</span><br><span class="line">                list.get(i+1).next = null;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二：找到链表中点，分裂成两个链表，然后合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 数据</span><br><span class="line">1-&gt;2-&gt;3-&gt;4</span><br><span class="line"></span><br><span class="line">2. 分裂</span><br><span class="line">1-&gt;2 </span><br><span class="line">3-&gt;4</span><br><span class="line"></span><br><span class="line">3. 合并</span><br><span class="line">1-&gt;4-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>

<h3 id="字典判断"><a href="#字典判断" class="headerlink" title="字典判断"></a><a href>字典判断</a></h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>panpan</p>
</blockquote>
<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。<br>说明：<br>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>解法一：超出时间限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;</span><br><span class="line">        for(char cr: s.toCharArray()) &#123;</span><br><span class="line">            boolean flag = false;</span><br><span class="line">            for(String str: wordDict) &#123;</span><br><span class="line">                if(str.contains(cr+&quot;&quot;)) &#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!flag) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return wordBreak2(s, wordDict);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean wordBreak2(String s, List&lt;String&gt; wordDict) &#123;</span><br><span class="line">        for(String str: wordDict) &#123;</span><br><span class="line">            if(str.length() &lt; s.length()) &#123;</span><br><span class="line">                String temp = s.substring(0, str.length());</span><br><span class="line">                if(s.split(str).length == 0) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp.equals(str)) &#123;</span><br><span class="line">                    if(wordBreak(s.substring(str.length()), wordDict)) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else if(str.length() == s.length()) &#123;</span><br><span class="line">                if(str.equals(s)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二：动态规划，类似爬楼梯</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    /*</span><br><span class="line">        动态规划算法，dp[i]表示s前i个字符能否拆分</span><br><span class="line">        转移方程：dp[j] = dp[i] &amp;&amp; check(s[i+1, j]);</span><br><span class="line">        check(s[i+1, j])就是判断i+1到j这一段字符是否能够拆分</span><br><span class="line">        其实，调整遍历顺序，这等价于s[i+1, j]是否是wordDict中的元素</span><br><span class="line">        这个举个例子就很容易理解。</span><br><span class="line">        假如wordDict=[&quot;apple&quot;, &quot;pen&quot;, &quot;code&quot;],s = &quot;applepencode&quot;;</span><br><span class="line">        dp[8] = dp[5] + check(&quot;pen&quot;)</span><br><span class="line">        翻译一下：前八位能否拆分取决于前五位能否拆分，加上五到八位是否属于字典</span><br><span class="line">        （注意：i的顺序是从j-1 -&gt; 0哦~</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    public HashMap&lt;String, Boolean&gt; hash = new HashMap&lt;&gt;();</span><br><span class="line">    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;</span><br><span class="line">        boolean[] dp = new boolean[s.length()+1];</span><br><span class="line">        </span><br><span class="line">        //方便check，构建一个哈希表</span><br><span class="line">        for(String word : wordDict)&#123;</span><br><span class="line">            hash.put(word, true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //初始化</span><br><span class="line">        dp[0] = true;</span><br><span class="line"></span><br><span class="line">        //遍历</span><br><span class="line">        for(int j = 1; j &lt;= s.length(); j++)&#123;</span><br><span class="line">            for(int i = j-1; i &gt;= 0; i--)&#123;</span><br><span class="line">                dp[j] = dp[i] &amp;&amp; check(s.substring(i, j));</span><br><span class="line">                if(dp[j])</span><br><span class="line">					break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean check(String s)&#123;</span><br><span class="line">        return hash.getOrDefault(s, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制</a></h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。<br>获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。<br>进阶:<br>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );</span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       // 返回  1</span><br><span class="line">cache.put(3, 3);    // 该操作会使得关键字 2 作废</span><br><span class="line">cache.get(2);       // 返回 -1 (未找到)</span><br><span class="line">cache.put(4, 4);    // 该操作会使得关键字 1 作废</span><br><span class="line">cache.get(1);       // 返回 -1 (未找到)</span><br><span class="line">cache.get(3);       // 返回  3</span><br><span class="line">cache.get(4);       // 返回  4</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>解法一：自定义链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="line"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="line"> * int param_1 = obj.get(key);</span><br><span class="line"> * obj.put(key,value);</span><br><span class="line"> */</span><br><span class="line">class LRUCache &#123;</span><br><span class="line">    int capacity;</span><br><span class="line">    int maxCapacity;</span><br><span class="line">    LRUNode head;</span><br><span class="line">	LRUNode tail;</span><br><span class="line"></span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        this.maxCapacity=capacity;</span><br><span class="line">        this.capacity=0;</span><br><span class="line">        this.head=new LRUNode();</span><br><span class="line">		tail=head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int get(int key) &#123;</span><br><span class="line">        //值存在判定</span><br><span class="line">        LRUNode temp = exsitKey(key);</span><br><span class="line"></span><br><span class="line">        if(temp != null) &#123;</span><br><span class="line">            int value = temp.value;</span><br><span class="line">            sort(temp);</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void put(int key, int value) &#123;</span><br><span class="line"></span><br><span class="line">		if(maxCapacity==0) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		//1. 值存在？</span><br><span class="line">        LRUNode temp = exsitKey(key);</span><br><span class="line"></span><br><span class="line">        //2. 存在即更新</span><br><span class="line">        if(temp!=null) &#123;</span><br><span class="line">            // 更新值，更新频率，更新排序</span><br><span class="line">            temp.value = value;</span><br><span class="line">            sort(temp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		//3. 值不存在，判定容量</span><br><span class="line">        if(capacity == maxCapacity) &#123;</span><br><span class="line">            //缓存已满，去除首节点</span><br><span class="line">            if(head.next == tail) &#123;</span><br><span class="line">				tail=head;</span><br><span class="line">			&#125;</span><br><span class="line">            head.next = head.next.next;</span><br><span class="line">            capacity--;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		//4. 添加新数据</span><br><span class="line">		LRUNode node = new LRUNode(key, value);</span><br><span class="line">		tail.next = node;</span><br><span class="line">		tail = tail.next;</span><br><span class="line">		capacity++;</span><br><span class="line">		</span><br><span class="line">		return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 缓存重排序</span><br><span class="line">    private void sort(LRUNode target) &#123;</span><br><span class="line">		if(tail!=target) &#123;</span><br><span class="line">			LRUNode temp = new LRUNode(target.key, target.value);</span><br><span class="line">			tail.next=temp;</span><br><span class="line">			tail=tail.next;</span><br><span class="line">			</span><br><span class="line">			target.key = target.next.key;</span><br><span class="line">            target.value = target.next.value;</span><br><span class="line">			target.next = target.next.next;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private LRUNode exsitKey(int key) &#123;</span><br><span class="line">        LRUNode temp = head.next;</span><br><span class="line">        // 值存在</span><br><span class="line">        while(temp != null ) &#123;</span><br><span class="line">            if(temp.key == key) &#123;</span><br><span class="line">                return temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LRUNode &#123;</span><br><span class="line">    LRUNode next;</span><br><span class="line">    int key;</span><br><span class="line">    int value;</span><br><span class="line">    public LRUNode() &#123;</span><br><span class="line">        next = null;</span><br><span class="line">    &#125;</span><br><span class="line">    public LRUNode(int key,int value) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        next = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二：使用Java自带的链表相关API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;&#123;</span><br><span class="line">    private int capacity;</span><br><span class="line">    // 默认加载因子:0.75</span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        super(capacity, 0.75F, true);</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int get(int key) &#123;</span><br><span class="line">        return super.getOrDefault(key, -1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void put(int key, int value) &#123;</span><br><span class="line">        super.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) &#123;</span><br><span class="line">        return size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">77. 组合</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: n = 4, k = 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        //标记元素是否用过</span><br><span class="line">        boolean[] flag = new boolean[n];</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; listList = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;Integer&gt;();</span><br><span class="line">        getList(listList,treeSet, flag,0, k);</span><br><span class="line">        return listList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void getList(List&lt;List&lt;Integer&gt;&gt; listlist, TreeSet&lt;Integer&gt; treeSet, boolean[] flag,int st, int k) &#123;</span><br><span class="line">        for(int i=st;i&lt;flag.length; i++) &#123;</span><br><span class="line">            if(!flag[i]) &#123;</span><br><span class="line">                flag[i]=true;</span><br><span class="line">                treeSet.add(i+1);</span><br><span class="line">                if(k!=1) &#123;</span><br><span class="line">                    getList(listlist, treeSet, flag,i,k-1);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    listlist.add(new ArrayList&lt;Integer&gt;(treeSet));</span><br><span class="line">                &#125;</span><br><span class="line">                treeSet.pollLast();</span><br><span class="line">                flag[i]=false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="商品购买抉择"><a href="#商品购买抉择" class="headerlink" title="商品购买抉择"></a>商品购买抉择</h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设有商品：面包10元/个，酸奶6元/个 鸡蛋2元/3个</span><br><span class="line">如何用200元刚好买够200个商品</span><br><span class="line">请编程计算</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>这是个三元一次方程组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">30x+18y+2z=600</span><br><span class="line">x+y+z=200</span><br></pre></td></tr></table></figure>

<p>边界判定：</p>
<ul>
<li><code>2*i+(200-i)*18&lt;=600</code></li>
<li><code>j*18+(200-i-j)*30 == 600-2*i</code> 得出结论</li>
<li><code>j*18+(200-i-j)*30+2*i &lt; 600</code> 循环继续</li>
<li><code>j*18+(200-i-j)*30+2*i &gt; 600</code> 跳出循环</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(int i=200; i&gt;=0;i--) &#123;</span><br><span class="line"></span><br><span class="line">            if(2*i+(200-i)*18&gt;600)</span><br><span class="line">                continue;</span><br><span class="line">            for(int j=200-i; j&gt;=0; j--) &#123;</span><br><span class="line">                int temp = j*18+(200-i-j)*30;</span><br><span class="line">                if(temp == 600-2*i) &#123;</span><br><span class="line">                    System.out.println(&quot;面包买&quot;+(200-i-j)+&quot;个，酸奶买&quot;+j+&quot;个，鸡蛋买&quot;+i+&quot;个&quot;);</span><br><span class="line">//                    面包买6个，酸奶买2个，鸡蛋买192个</span><br><span class="line">//                    面包买2个，酸奶买9个，鸡蛋买189个</span><br><span class="line">                &#125; else if(temp &gt; 600-2*i) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>解法一：插入法，超出时间限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode sortList(ListNode head) &#123;</span><br><span class="line">        ListNode first = new ListNode();</span><br><span class="line">        first.next = head;</span><br><span class="line">        ListNode tail = head, temp;</span><br><span class="line"></span><br><span class="line">        while(tail.next != null) &#123;</span><br><span class="line">            if(tail.next.val &lt; tail.val) &#123;</span><br><span class="line">                temp = first;</span><br><span class="line">                while(temp.next != null &amp;&amp; temp.next.val &lt; tail.next.val) &#123;</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode node = temp.next;</span><br><span class="line">                temp.next = tail.next;</span><br><span class="line">                tail.next = tail.next.next;</span><br><span class="line">                temp.next.next = node;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return first.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二：递归，快排</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode sortList(ListNode head) &#123;</span><br><span class="line">        ListNode rt = head, lh=new ListNode(),lf=lh;</span><br><span class="line"></span><br><span class="line">        if(head==null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(rt.next!=null) &#123;</span><br><span class="line">            if(rt.next.val &lt; head.val) &#123;</span><br><span class="line">                lf.next = rt.next;</span><br><span class="line">                lf = lf.next;</span><br><span class="line">                rt.next = rt.next.next;</span><br><span class="line">                lf.next=null;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                rt=rt.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if(head.next != null) &#123;</span><br><span class="line">            head.next = sortList(head.next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(lh.next != null) &#123;</span><br><span class="line">            lh.next = sortList(lh.next);</span><br><span class="line"></span><br><span class="line">            ListNode tail = lh;</span><br><span class="line">            while(tail.next != null) &#123;</span><br><span class="line">                tail=tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail.next = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return lh.next==null?head:lh.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">给定一个可包含重复数字的序列，返回所有不重复的全排列。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>前面有<code>全排列 I</code>的题目，用回溯解题。区别在于这道题数组中数字可重复，这就会导致排列重复，需要剪枝。</p>
<p>核心代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">回溯：</span><br><span class="line">	list.add(nums[i]);</span><br><span class="line">	flag[i]=true; // 用于表示数字被使用</span><br><span class="line">	getList(list, nums, flag, size+1); // 进入下一层</span><br><span class="line">	flag[i]=false;</span><br><span class="line">	list.remove(size);</span><br><span class="line"></span><br><span class="line">剪枝1：排列；命中后，检测下个数字是否重复，重复跳过，避免排列重复</span><br><span class="line">	Arrays.sort(nums);</span><br><span class="line">	while(i&lt;length-1 &amp;&amp; nums[i] == nums[i+1])</span><br><span class="line">		i++;</span><br><span class="line">剪枝2：获取一个排列后结束，避免空循环</span><br><span class="line">	if(size+1 == length) &#123;</span><br><span class="line">		...</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; listlist = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        boolean[] flag = new boolean[nums.length];</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        getList(list, nums, flag, 0);</span><br><span class="line">        return listlist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void getList(List&lt;Integer&gt; list, int[] nums, boolean[] flag, int size) &#123;</span><br><span class="line">        int length = nums.length;</span><br><span class="line">        for(int i=0; i&lt;length; i++) &#123;</span><br><span class="line">            if(!flag[i]) &#123;</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line"></span><br><span class="line">                if(size+1 == length) &#123;</span><br><span class="line">                    listlist.add(new ArrayList&lt;Integer&gt;(list));</span><br><span class="line">                    list.remove(size);</span><br><span class="line">                    return;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    flag[i]=true;</span><br><span class="line">                    getList(list, nums, flag, size+1);</span><br><span class="line">                    flag[i]=false;</span><br><span class="line">                &#125;</span><br><span class="line">                list.remove(size);</span><br><span class="line"></span><br><span class="line">                while(i&lt;length-1 &amp;&amp; nums[i] == nums[i+1])</span><br><span class="line">                    i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">48. 旋转图像</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">给定一个 n × n 的二维矩阵表示一个图像。</span><br><span class="line"></span><br><span class="line">将图像顺时针旋转 90 度。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">给定 matrix = </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>逐层转动，逐角转动。</p>
<p><img src="/image/leetcode/rotate-image.png" alt="旋转图像"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void rotate(int[][] matrix) &#123;</span><br><span class="line">	</span><br><span class="line">		int length = matrix.length, crl = (length+1)/2;</span><br><span class="line">		</span><br><span class="line">		for(int i=0; i&lt;crl; i++) &#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">			int a1=i,b1=i;</span><br><span class="line">			int a2=i,b2=length-1-i;</span><br><span class="line">			int a3=length-1-i,b3=length-1-i;</span><br><span class="line">			int a4=length-1-i,b4=i;</span><br><span class="line">			</span><br><span class="line">			for(int j=i; j&lt;matrix.length-1-i;j++) &#123;</span><br><span class="line">                </span><br><span class="line">				int temp = matrix[a1][b1];</span><br><span class="line">				matrix[a1][b1] = matrix[a4][b4];</span><br><span class="line">				matrix[a4][b4] = matrix[a3][b3];</span><br><span class="line">				matrix[a3][b3] = matrix[a2][b2];</span><br><span class="line">				matrix[a2][b2] = temp;</span><br><span class="line"></span><br><span class="line">				b1++;</span><br><span class="line">				a2++;</span><br><span class="line">				b3--;</span><br><span class="line">				a4--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">给定一个非负整数数组，你最初位于数组的第一个位置。</span><br><span class="line"></span><br><span class="line">数组中的每个元素代表你在该位置可以跳跃的最大长度。</span><br><span class="line"></span><br><span class="line">判断你是否能够到达最后一个位置。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: true</span><br><span class="line">解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [3,2,1,0,4]</span><br><span class="line">输出: false</span><br><span class="line">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>方法一：递归，超出时间限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canJump(int[] nums) &#123;</span><br><span class="line">        return preJump(nums, nums.length-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean preJump(int[] nums, int target) &#123;</span><br><span class="line">        if(target==0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=target-1; i&gt;=0; i--) &#123;</span><br><span class="line">            if(target-i&lt;= nums[i]) &#123;</span><br><span class="line">                if(preJump(nums, i)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：暴力循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canJump(int[] nums) &#123;</span><br><span class="line">        boolean[]flag = new boolean[nums.length];</span><br><span class="line">        flag[0]=true;</span><br><span class="line">        for(int i=0; i&lt;nums.length-1; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            if(!flag[i]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else if(i!=0 &amp;&amp; nums[i]&lt;nums[i-1]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            </span><br><span class="line">            for(int j=1; j&lt;=nums[i]; j++) &#123;</span><br><span class="line">                if(i+j&gt;nums.length-1) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                flag[i+j]=true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(flag[nums.length-1])</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return flag[nums.length-1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给出一个区间的集合，请合并所有重叠的区间。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: intervals = [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p><a href="https://leetcode-cn.com/problems/merge-intervals/solution/chi-jing-ran-yi-yan-miao-dong-by-sweetiee/" target="_blank" rel="noopener">解法</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] merge(int[][] intervals) &#123;</span><br><span class="line">        // 先按照区间起始位置排序</span><br><span class="line">        Arrays.sort(intervals, (v1, v2) -&gt; v1[0] - v2[0]);</span><br><span class="line">        // 遍历区间</span><br><span class="line">        int[][] res = new int[intervals.length][2];</span><br><span class="line">        int idx = -1;</span><br><span class="line">        for (int[] interval: intervals) &#123;</span><br><span class="line">            // 如果结果数组是空的，或者当前区间的起始位置 &gt; 结果数组中最后区间的终止位置，</span><br><span class="line">            // 则不合并，直接将当前区间加入结果数组。</span><br><span class="line">            if (idx == -1 || interval[0] &gt; res[idx][1]) &#123;</span><br><span class="line">                res[++idx] = interval;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 反之将当前区间合并至结果数组的最后区间</span><br><span class="line">                res[idx][1] = Math.max(res[idx][1], interval[1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Arrays.copyOf(res, idx + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><blockquote><p>原文作者: 古城烟雨</p><p>原文链接: <a href="http://zws6672.top/2020/09/18/leetcode-20200914-20200917/">http://zws6672.top/2020/09/18/leetcode-20200914-20200917/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/leetcode/">leetcode</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/09/24/redis-1/" class="pre">redis（一）入门</a><a href="/2020/09/18/mysql-test/" class="next">MySQL SQL 练习题合集</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#96-不同的二叉搜索树"><span class="toc-text">96. 不同的二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#92-反转链表-II"><span class="toc-text">92. 反转链表 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#版本数组"><span class="toc-text">版本数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#统计字符串中数字和字母的出现次数"><span class="toc-text">统计字符串中数字和字母的出现次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pow-x-n"><span class="toc-text">pow(x, n)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-加油站"><span class="toc-text">134. 加油站</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表重排序"><span class="toc-text">链表重排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字典判断"><span class="toc-text">字典判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#146-LRU缓存机制"><span class="toc-text">146. LRU缓存机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77-组合"><span class="toc-text">77. 组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#商品购买抉择"><span class="toc-text">商品购买抉择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#148-排序链表"><span class="toc-text">148. 排序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-全排列-II"><span class="toc-text">47. 全排列 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-旋转图像"><span class="toc-text">48. 旋转图像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-跳跃游戏"><span class="toc-text">55. 跳跃游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-合并区间"><span class="toc-text">56. 合并区间</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/mysql-opt/">MySQL 优化(一)设计与功能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/tool-uml/">UML中关系</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/fmi-ssp-dcp/">了解fmi、ssp与dcp</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/hexo-sync/">多PC同步hexo</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/fmi-daccosim/">基于FMI标准的仿真软件————Daccosim</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/springboot-1/">springboot（一）入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/13/jdk-backend-compile/">后端编译与优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/13/jdk-front-compile/">前端编译与优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/26/jdk-bytecodeEngine/">虚拟机字节码执行引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/15/jdk-cload/">虚拟机类加载机制</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/devops/" style="font-size: 15px;">devops</a> <a href="/tags/CI/" style="font-size: 15px;">CI</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/neo4j/" style="font-size: 15px;">neo4j</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/oracle/" style="font-size: 15px;">oracle</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/系统/" style="font-size: 15px;">系统</a> <a href="/tags/博客搭建/" style="font-size: 15px;">博客搭建</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/ms/" style="font-size: 15px;">ms</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/运维/" style="font-size: 15px;">运维</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/javaweb/" style="font-size: 15px;">javaweb</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/elasticsearch/" style="font-size: 15px;">elasticsearch</a> <a href="/tags/fmi/" style="font-size: 15px;">fmi</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/微服务/" style="font-size: 15px;">微服务</a> <a href="/tags/soft-skills/" style="font-size: 15px;">soft-skills</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/nk/" style="font-size: 15px;">nk</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://juejin.im/" title="掘金" target="_blank">掘金</a><ul></ul><a href="https://www.cnblogs.com/" title="博客园" target="_blank">博客园</a><ul></ul><a href="https://www.infoq.cn/" title="info" target="_blank">info</a><ul></ul><a href="https://www.ibm.com/" title="ibm" target="_blank">ibm</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">古城烟雨.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>
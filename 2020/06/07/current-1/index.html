<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一些关于技术的碎语"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>java 并发（一）入门 | 微言术语</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">java 并发（一）入门</h1><a id="logo" href="/.">微言术语</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">java 并发（一）入门</h1><div class="post-meta"><a href="/2020/06/07/current-1/#comments" class="comment-count"></a><p><span class="date">Jun 07, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>jdk5.0————很重要的特性就是增加了并发包java.util.concurrent，用于优化多线程的使用，包含了锁相关的一些类、线程池相关的一些类。</p>
<h3 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1. 前置知识"></a>1. 前置知识</h3><p>在学习并发包之前，需要学习一些前置知识：</p>
<ul>
<li>内存模型</li>
<li>内存屏障</li>
<li>volatile变量</li>
<li>CAS机制</li>
<li>AbstractQueuedSynchronizer（AQS同步器）</li>
</ul>
<p><strong><em>体系划分</em></strong></p>
<p><img src="/image/current/currentjg.png" alt="concurrent包体系划分"></p>
<hr>
<h3 id="2-java内存模型"><a href="#2-java内存模型" class="headerlink" title="2. java内存模型"></a>2. java内存模型</h3><p>在内存模型中可见，每个线程都存在着一个单独栈空间。具体内存结构如下：</p>
<p><img src="/image/jvm/JVM.png" alt="JVM体系结构"></p>
<p>了解内存模型，可以加深我们对于Java多线程的理解。</p>
<hr>
<h3 id="3-内存屏障"><a href="#3-内存屏障" class="headerlink" title="3. 内存屏障"></a>3. 内存屏障</h3><p>内存屏障，也称内存栅栏，内存栅障，屏障指令等， 是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。</p>
<p>编译器和处理器必须同时遵守重排规则。多核处理器需使用内存屏障指令来确保一致性。即使编译器优化掉了一个字段访问（因为一个读入的值未被使用），需要产生内存屏障，就像这个访问仍然需要保护。</p>
<p><strong><em>类型</em></strong></p>
<ul>
<li><p>写内存屏障（Store Memory Barrier）：处理器将存储缓存值写回主存（阻塞方式）。</p>
</li>
<li><p>读内存屏障（Load Memory Barrier）：处理器，处理失效队列（阻塞方式）。</p>
<p><img src="/image/current/ncpz.png" alt="内存屏障类型"></p>
</li>
<li><p>lock：解锁时，jvm会强制刷新cpu缓存，导致当前线程更改，对其他线程可见。</p>
</li>
<li><p>volatile：标记volatile的字段，在写操作时，会强制刷新cpu缓存，标记volatile的字段，每次读取都是直接读内存。</p>
</li>
<li><p>final：即时编译器在final写操作后，会插入内存屏障，来禁止重排序，保证可见性</p>
</li>
</ul>
<hr>
<h3 id="4-volatile变量"><a href="#4-volatile变量" class="headerlink" title="4. volatile变量"></a>4. volatile变量</h3><p> <img src="/image/java-bf/volatile.png" alt="volatile"></p>
<p> <code>volatile</code> 用于声明一个共享变量，它只能保证数据的可见性，而不能保证原子化。</p>
<ul>
<li><p>可见性，不同线程可以访问同一变量。</p>
</li>
<li><p>不保证原子性，被 <code>volatile</code>声明的变量的自增操作无法保证线程安全。<code>不要将volatile用在getAndOperate场合.(即获取操作后不能连着修改操作)</code></p>
<p><img src="/image/java-bf/volatile2.png" alt="volatile"></p>
</li>
</ul>
<h5 id="4-1-使用实例"><a href="#4-1-使用实例" class="headerlink" title="4.1 使用实例"></a>4.1 使用实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private volatile boolean flag = true;</span><br><span class="line">private volatile int num = 0;</span><br><span class="line">@Test</span><br><span class="line">public void test() &#123;</span><br><span class="line">	//线程安全</span><br><span class="line">    if (flag) &#123;</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">        flag = false;</span><br><span class="line">        // 业务代码</span><br><span class="line">    &#125;</span><br><span class="line">	//非线程安全</span><br><span class="line">	num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-为什么volatile无法保证原子性"><a href="#4-2-为什么volatile无法保证原子性" class="headerlink" title="4.2 为什么volatile无法保证原子性"></a>4.2 为什么volatile无法保证原子性</h5><p><code>i++</code>会被编译成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov    0xc(%r10),%r8d ; Load</span><br><span class="line">inc    %r8d           ; Increment</span><br><span class="line">mov    %r8d,0xc(%r10) ; Store</span><br><span class="line">lock addl $0x0,(%rsp) ; StoreLoad Barrier 内存屏障</span><br></pre></td></tr></table></figure>

<p>被<code>volatile</code>声明的变量，如果使用累加操作（非原子操作），被编译成汇编语言时，写操作会导致添加一个写内存屏障。在执行写屏障之前，如果其它线程提前一步修改了值，就会被丢失。</p>
<hr>
<h3 id="5-CAS机制"><a href="#5-CAS机制" class="headerlink" title="5. CAS机制"></a>5. CAS机制</h3><h5 id="5-1-几种锁机制"><a href="#5-1-几种锁机制" class="headerlink" title="5.1 几种锁机制"></a>5.1 几种锁机制</h5><ul>
<li>synchronized————独占锁（悲观锁),会导致其它所有需要锁的线程挂起；利用 JVM 字节码层面来实现同步机制，它是一个悲观锁机制。</li>
<li>volatile————透明性，但不保证原子操作</li>
<li>CAS————自旋锁（乐观锁).总是认为自己可以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败`</li>
</ul>
<h5 id="5-2-基础"><a href="#5-2-基础" class="headerlink" title="5.2 基础"></a>5.2 基础</h5><p>CAS,compare and swap的缩写，中文翻译成比较并交换。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 <code>如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。</code>无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。</p>
<p>通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键。</p>
<p>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。</p>
<hr>
<h3 id="6-AbstractQueuedSynchronizer（AQS-抽象队列同步器）"><a href="#6-AbstractQueuedSynchronizer（AQS-抽象队列同步器）" class="headerlink" title="6. AbstractQueuedSynchronizer（AQS 抽象队列同步器）"></a>6. AbstractQueuedSynchronizer（AQS 抽象队列同步器）</h3><p>AQS使用一个整型的volatile变量（命名为state）来维护同步状态，这是接下来实现大部分同步需求的基础，还提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架。</p>
<h5 id="6-1-Java声明"><a href="#6-1-Java声明" class="headerlink" title="6.1 Java声明"></a>6.1 Java声明</h5><p>该同步器利用了一个int来表示状态，期望它能够成为实现大部分同步需求的基础。使用的方法是继承，子类通过继承同步器并需要实现它的方法来管理其状态，管理的方式就是通过类似acquire和release的方式来操纵状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractQueuedSynchronizer</span><br><span class="line">	extends AbstractOwnableSynchronizer</span><br><span class="line">    implements java.io.Serializable</span><br></pre></td></tr></table></figure>

<h5 id="6-2-数据结构"><a href="#6-2-数据结构" class="headerlink" title="6.2 数据结构"></a>6.2 数据结构</h5><p><strong><em>等待队列</em></strong><br><img src="/image/current/compareAndSetTail.png" alt="compareAndSetTail"></p>
<p>同步器核心之一便是等待队列，该队列的节点定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">	//首节点</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line">	</span><br><span class="line">    //表示节点的状态。默认为0，表示当前节点在sync队列中，等待着获取锁。</span><br><span class="line">    //其它几个状态为：CANCELLED、SIGNAL、CONDITION、PROPAGATE</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line">	</span><br><span class="line">    //前驱节点</span><br><span class="line">    volatile Node prev;</span><br><span class="line">    //后继节点</span><br><span class="line">    volatile Node next;</span><br><span class="line">    //获取锁的线程</span><br><span class="line">    volatile Thread thread;</span><br><span class="line">    //存储condition队列中的后继节点。</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">waitStatus的几个状态</span><br><span class="line"></span><br><span class="line">CANCELLED(1) : 由于 timeout/interrupt, 线程被取消</span><br><span class="line">0            : 其他状态</span><br><span class="line">SIGNAL(-1)   : 线程成功被阻塞,可以调用当前结点的后续结点</span><br><span class="line">CONDITION(-2): 位于条件队列中，等待condition</span><br><span class="line">PROPAGATE(-3): 表示当前场景下后续的acquireShared能够得以执行</span><br></pre></td></tr></table></figure>

<p>该等待队列是“CLH（自旋锁）”锁队列，用于阻塞同步器，使用了相同的策略来控制当前线程的上一个线程的信息。每个节点包含一个状态字段，用于区分该线程是否会被阻塞，而不保证线程获得锁。CLH队列需要一个虚拟头节点才能启动。</p>
<h5 id="6-3-几个核心方法"><a href="#6-3-几个核心方法" class="headerlink" title="6.3 几个核心方法"></a>6.3 几个核心方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.getState()</span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.setState(int)</span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState(int, int)</span><br></pre></td></tr></table></figure>

<p><strong><em>compareAndSetState</em></strong><br><code>compareAndSetState</code>是一个基于<code>CAS原则</code>定义的方法，用于设置队列的尾节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private final boolean compareAndSetTail(Node expect, Node update) &#123;</span><br><span class="line">	return unsafe.compareAndSwapObject(this, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>interrupt()方法:仅仅使线程中打了一个停止的标记，并不是真的停止线程</p>
</blockquote>
<hr>
<h3 id="7-参考文章"><a href="#7-参考文章" class="headerlink" title="7. 参考文章"></a>7. 参考文章</h3><p><a href="https://www.cnblogs.com/Mainz/p/3556430.html" target="_blank" rel="noopener">为什么volatile不能保证原子性而Atomic可以？</a><br><a href="https://www.cnblogs.com/upcwanghaibo/p/8626802.html" target="_blank" rel="noopener">多线程之CAS</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: 古城烟雨</p><p>原文链接: <a href="http://zws6672.top/2020/06/07/current-1/">http://zws6672.top/2020/06/07/current-1/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/并发/">并发</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/06/08/javatool-jbe/" class="pre">JBE-Java字节码编辑器</a><a href="/2020/05/31/ms-3/" class="next">面试（三）SSM</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-前置知识"><span class="toc-text">1. 前置知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-java内存模型"><span class="toc-text">2. java内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-内存屏障"><span class="toc-text">3. 内存屏障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-volatile变量"><span class="toc-text">4. volatile变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-使用实例"><span class="toc-text">4.1 使用实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-为什么volatile无法保证原子性"><span class="toc-text">4.2 为什么volatile无法保证原子性</span></a></li></ol></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#5-CAS机制"><span class="toc-text">5. CAS机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-几种锁机制"><span class="toc-text">5.1 几种锁机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-基础"><span class="toc-text">5.2 基础</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-AbstractQueuedSynchronizer（AQS-抽象队列同步器）"><span class="toc-text">6. AbstractQueuedSynchronizer（AQS 抽象队列同步器）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-Java声明"><span class="toc-text">6.1 Java声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-数据结构"><span class="toc-text">6.2 数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-几个核心方法"><span class="toc-text">6.3 几个核心方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-参考文章"><span class="toc-text">7. 参考文章</span></a></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/01/09/java-util-0/">Java集合（一）入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/09/http/">Http 协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/07/ms-dsq/">面试——某电商笔试</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/23/mq-2/">RabbitMQ（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/14/regex/">正则表达式汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/18/mservice-transaction/">微服务中事务的安全性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/17/nk-201102-201115/">nk-201102-201115</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/17/leetcode-201102-201115/">leetcode-201102-201115</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/04/java-concurrent/">Java多线程（一）ThreadLocal</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/03/ms-tt/">面试记录（六）某拓</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/devops/" style="font-size: 15px;">devops</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/CI/" style="font-size: 15px;">CI</a> <a href="/tags/neo4j/" style="font-size: 15px;">neo4j</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/系统/" style="font-size: 15px;">系统</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/oracle/" style="font-size: 15px;">oracle</a> <a href="/tags/博客搭建/" style="font-size: 15px;">博客搭建</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/ms/" style="font-size: 15px;">ms</a> <a href="/tags/运维/" style="font-size: 15px;">运维</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/javaweb/" style="font-size: 15px;">javaweb</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/微服务/" style="font-size: 15px;">微服务</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/elasticsearch/" style="font-size: 15px;">elasticsearch</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/nk/" style="font-size: 15px;">nk</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://juejin.im/" title="掘金" target="_blank">掘金</a><ul></ul><a href="https://www.cnblogs.com/" title="博客园" target="_blank">博客园</a><ul></ul><a href="https://www.infoq.cn/" title="info" target="_blank">info</a><ul></ul><a href="https://www.ibm.com/" title="ibm" target="_blank">ibm</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">古城烟雨.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一些关于技术的碎语"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>leetcode-20200927-20201004 | 微言术语</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">leetcode-20200927-20201004</h1><a id="logo" href="/.">微言术语</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">leetcode-20200927-20201004</h1><div class="post-meta"><a href="/2020/10/04/leetcode-20200927-20201004/#comments" class="comment-count"></a><p><span class="date">Oct 04, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h3 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a><a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">71. 简化路径</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</span><br><span class="line"></span><br><span class="line">在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径</span><br><span class="line"></span><br><span class="line">请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：&quot;/home/&quot;</span><br><span class="line">输出：&quot;/home&quot;</span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：&quot;/../&quot;</span><br><span class="line">输出：&quot;/&quot;</span><br><span class="line">解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：&quot;/home//foo/&quot;</span><br><span class="line">输出：&quot;/home/foo&quot;</span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：&quot;/a/./b/../../c/&quot;</span><br><span class="line">输出：&quot;/c&quot;</span><br><span class="line">示例 5：</span><br><span class="line"></span><br><span class="line">输入：&quot;/a/../../b/../c//.//&quot;</span><br><span class="line">输出：&quot;/c&quot;</span><br><span class="line">示例 6：</span><br><span class="line"></span><br><span class="line">输入：&quot;/a//b////c/d//././/..&quot;</span><br><span class="line">输出：&quot;/a/b/c&quot;</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String simplifyPath(String path) &#123;</span><br><span class="line">        if(path==null||path.trim().length()==0) &#123;</span><br><span class="line">            return path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path = path.replaceAll(&quot;//&quot;,&quot;/&quot;);</span><br><span class="line">        String[] strs=path.split(&quot;/&quot;);</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(&quot;/&quot;);</span><br><span class="line">        for (int i=1; i&lt;strs.length; i++) &#123;</span><br><span class="line">            if(strs[i].equals(&quot;..&quot;)) &#123;</span><br><span class="line">                if(list.size()!=1) &#123;</span><br><span class="line">                    list.remove(list.size()-1);</span><br><span class="line">                    list.remove(list.size()-1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  else if(!strs[i].equals(&quot;.&quot;) &amp;&amp; !strs[i].equals(&quot;&quot;)) &#123;</span><br><span class="line">                list.add(strs[i]);</span><br><span class="line">                list.add(&quot;/&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer sb = new StringBuffer();</span><br><span class="line">        for(String str: list) &#123;</span><br><span class="line">            sb.append(str);</span><br><span class="line">        &#125;</span><br><span class="line">        if(sb.length()!=1 &amp;&amp; sb.charAt(sb.length()-1)==&apos;/&apos;) &#123;</span><br><span class="line">            sb.delete(sb.length()-1,sb.length());</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</span><br><span class="line"></span><br><span class="line">说明：解集不能包含重复的子集。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: nums = [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 推导过程如下，存在[1,2,3,4]</span><br><span class="line"> * </span><br><span class="line"> * 不加元素，第一个子集为空集合[],</span><br><span class="line"> * 加元素[1]，添加子集[1],子集为 [],[1]</span><br><span class="line"> * 加元素[2]，添加子集[2] [1,2],子集为 [],[1],[2],[1,2]</span><br><span class="line"> * 加元素[3]，添加子集[3],[1,3] [2,3] [1,2,3],子集为 [],[1],[2],[1,2],[3],[1,3] [2,3] [1,2,3]</span><br><span class="line"> * </span><br><span class="line"> * 加入元素后，还为原子集中所有的集合添加新元素，作为新的集合加入到子集中</span><br><span class="line"> * []</span><br><span class="line"> * 		[]</span><br><span class="line"> * [1]</span><br><span class="line"> * 		[],[1]</span><br><span class="line"> * [2]</span><br><span class="line"> * 		[],[1],[2],[1,2]</span><br><span class="line"> * [3] </span><br><span class="line"> * 		[],[1],[2],[1,2],[3],[1,3] [2,3] [1,2,3]</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; listlist = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        listlist.add(list);</span><br><span class="line">        for(int i=0; i&lt;nums.length; i++) &#123;</span><br><span class="line">            int size = listlist.size();</span><br><span class="line">            for (int j=0; j&lt;size; j++) &#123;</span><br><span class="line">                list = new ArrayList&lt;Integer&gt;(listlist.get(j));</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">                listlist.add(list);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return listlist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">给你一个由 &apos;1&apos;（陆地）和 &apos;0&apos;（水）组成的的二维网格，请你计算网格中岛屿的数量。</span><br><span class="line"></span><br><span class="line">岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</span><br><span class="line"></span><br><span class="line">此外，你可以假设该网格的四条边均被水包围。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">[&apos;1&apos;,&apos;1&apos;,&apos;1&apos;,&apos;1&apos;,&apos;0&apos;],</span><br><span class="line">[&apos;1&apos;,&apos;1&apos;,&apos;0&apos;,&apos;1&apos;,&apos;0&apos;],</span><br><span class="line">[&apos;1&apos;,&apos;1&apos;,&apos;0&apos;,&apos;0&apos;,&apos;0&apos;],</span><br><span class="line">[&apos;0&apos;,&apos;0&apos;,&apos;0&apos;,&apos;0&apos;,&apos;0&apos;]</span><br><span class="line">]</span><br><span class="line">输出: 1</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">[&apos;1&apos;,&apos;1&apos;,&apos;0&apos;,&apos;0&apos;,&apos;0&apos;],</span><br><span class="line">[&apos;1&apos;,&apos;1&apos;,&apos;0&apos;,&apos;0&apos;,&apos;0&apos;],</span><br><span class="line">[&apos;0&apos;,&apos;0&apos;,&apos;1&apos;,&apos;0&apos;,&apos;0&apos;],</span><br><span class="line">[&apos;0&apos;,&apos;0&apos;,&apos;0&apos;,&apos;1&apos;,&apos;1&apos;]</span><br><span class="line">]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int numIslands;</span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        numIslands=0;</span><br><span class="line">		//双循环遍历岛屿</span><br><span class="line">        for(int i=0; i&lt;grid.length; i++) &#123;</span><br><span class="line">            for(int j=0;j&lt;grid[0].length; j++) &#123;</span><br><span class="line">                if(grid[i][j]==&apos;1&apos;) &#123;</span><br><span class="line">                    numIslands++;</span><br><span class="line">                    flag(grid,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return numIslands;</span><br><span class="line">    &#125;</span><br><span class="line">	//如果当前格子为陆地，置为0，并检测上下左右的格子</span><br><span class="line">    private void flag(char[][] grid, int i, int j) &#123;</span><br><span class="line">        if(grid[i][j]==&apos;1&apos;) &#123;</span><br><span class="line">            grid[i][j]=&apos;0&apos;;</span><br><span class="line">			//检测左边的岛屿</span><br><span class="line">            if(j!=0) &#123;</span><br><span class="line">               flag(grid, i, j-1); </span><br><span class="line">            &#125;</span><br><span class="line">			//检测右边的岛屿</span><br><span class="line">            if(j&lt;grid[0].length-1) &#123;</span><br><span class="line">                flag(grid, i, j+1);</span><br><span class="line">            &#125;</span><br><span class="line">			//检测上方的岛屿</span><br><span class="line">            if(i!=0) &#123;</span><br><span class="line">               flag(grid, i-1, j); </span><br><span class="line">            &#125;</span><br><span class="line">			//检测下方的岛屿</span><br><span class="line">            if(i&lt;grid.length-1) &#123;</span><br><span class="line">                flag(grid, i+1, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</span><br><span class="line"></span><br><span class="line">在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</span><br><span class="line"></span><br><span class="line">给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。</span><br><span class="line">你可以假定输入的先决条件中没有重复的边。</span><br><span class="line">1 &lt;= numCourses &lt;= 10^5</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<h3 id="207-课程表-1"><a href="#207-课程表-1" class="headerlink" title="207. 课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</span><br><span class="line"></span><br><span class="line">在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</span><br><span class="line"></span><br><span class="line">给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong><br><a href="https://www.jianshu.com/p/3347f54a3187" target="_blank" rel="noopener">深入理解拓扑排序（Topological sort)</a><br>核心思想就是：<br>    先构造邻接表和节点入度数组，用队列记录初始的入度为0的节点，从队列中取元素，将该节点指向的那些节点的入度-1（删除操作），若有新的入度为0的节点，加入队列中，直到队列为空，排序结束，判断取出来的节点的数目是否==图节点数目，否则有环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;//numCourses个结点的有向图</span><br><span class="line">        int n=prerequisites.length;//n条边</span><br><span class="line">        ArrayList&lt;Integer&gt; [] adjacencyList=new ArrayList[numCourses];//邻接表</span><br><span class="line">        int [] inDegree=new int[numCourses];//入度数组，inDegree[i]的值表示节点i的入度</span><br><span class="line">        //先由边的集合构建邻接表</span><br><span class="line">        for(int i=0;i&lt;numCourses;i++)&#123;</span><br><span class="line">            adjacencyList[i]=new ArrayList&lt;&gt;();//节点i的下标为i</span><br><span class="line">        &#125;</span><br><span class="line">        for (int [] pre:prerequisites) &#123;</span><br><span class="line">            adjacencyList[pre[1]].add(pre[0]);//pre=[0,1],1是边的起始点，0才是终点，是节点1指向节点0</span><br><span class="line">            inDegree[pre[0]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        //拓扑排序判断是不是DAG</span><br><span class="line">        return topologicalSort(adjacencyList,inDegree,numCourses);</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean topologicalSort(ArrayList&lt;Integer&gt; [] adjacencyList,int [] inDegree,int n)&#123;//邻接表和入度数组</span><br><span class="line">        int res=0;//拓扑排序能取出来的节点数目</span><br><span class="line">        Queue&lt;Integer&gt; queue=new LinkedList&lt;Integer&gt;();//存储入度为0的节点</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            if(inDegree[i]==0) queue.offer(i);//节点i的入度为0，添加进队列</span><br><span class="line">        &#125;</span><br><span class="line">         while (!queue.isEmpty()) &#123;</span><br><span class="line">            int i = queue.poll();//取出节点i</span><br><span class="line">            res++;</span><br><span class="line">            for (int child_of_i : adjacencyList[i]) &#123;//对节点i指向的每一个节点</span><br><span class="line">                inDegree[child_of_i]--;</span><br><span class="line">                if (inDegree[child_of_i] == 0) queue.offer(child_of_i);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        return res==n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. 字母异位词分组</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">所有输入均为小写字母。</span><br><span class="line">不考虑答案输出的顺序。</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>解法有二：字符串排序，再比较；统计字符串中每个字符串出现的次数，再比较</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        int size = strs.length;</span><br><span class="line">        boolean[] flag = new boolean[size];</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; listlist = new ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        </span><br><span class="line">        for(int i=0; i&lt;size; i++) &#123;</span><br><span class="line">            // 解析未标记的单词</span><br><span class="line">            if(!flag[i]) &#123;</span><br><span class="line">                List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">                list.add(strs[i]);</span><br><span class="line">                flag[i]=!flag[i];</span><br><span class="line"></span><br><span class="line">                if(i!=size-1) &#123;</span><br><span class="line">                    //统计字符串中每个字符串出现的次数</span><br><span class="line">                    char[] ca = new char[26];</span><br><span class="line">                    for (char c : strs[i].toCharArray())</span><br><span class="line">                        ca[c - &apos;a&apos;]++;</span><br><span class="line">                    </span><br><span class="line">                    //比较单词结构</span><br><span class="line">                    for(int j=i+1; j&lt;size; j++) &#123;</span><br><span class="line">                        if(!flag[j] &amp;&amp; strs[i].length()==strs[j].length()) &#123;</span><br><span class="line">                             char[] temp = Arrays.copyOf(ca, 26);</span><br><span class="line">                             boolean test = true;</span><br><span class="line">                             for (char c : strs[j].toCharArray()) &#123;</span><br><span class="line">                                    if(temp[c-&apos;a&apos;]==0) &#123;</span><br><span class="line">                                        test=false;</span><br><span class="line">                                        break;</span><br><span class="line">                                    &#125; else &#123;</span><br><span class="line">                                        temp[c-&apos;a&apos;]--;</span><br><span class="line">                                    &#125;</span><br><span class="line">                             &#125;</span><br><span class="line">                             if(test) &#123;</span><br><span class="line">                                list.add(strs[j]);</span><br><span class="line">                                flag[j]=!flag[j];</span><br><span class="line">                             &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                listlist.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return listlist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">59. 螺旋矩阵 II</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: 3</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>解析：这道题主要是按序填充数组，注意边界控制即可</p>
<p>图解如下：<br><img src="/image/leetcode/spiral-matrix-ii" alt="spiral-matrix-ii"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] generateMatrix(int n) &#123;</span><br><span class="line">        int[][]arr = new int[n][n];</span><br><span class="line">        if(n==0) &#123;</span><br><span class="line">            return arr;</span><br><span class="line">        &#125;</span><br><span class="line">        int cir = (n+1)/2, temp=1;</span><br><span class="line">        </span><br><span class="line">        for(int i=0; i&lt;cir;i++) &#123;</span><br><span class="line">            for(int j=i; j&lt;n-i; j++) &#123;</span><br><span class="line">                arr[i][j]= temp;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i == n-1-i) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j=i+1; j&lt;n-1-i; j++) &#123;</span><br><span class="line">                arr[j][n-1-i]= temp;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j=n-1-i; j&gt;=i; j--) &#123;</span><br><span class="line">                arr[n-1-i][j]= temp;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j=n-2-i; j&gt;i; j--) &#123;</span><br><span class="line">                arr[j][i]= temp;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title></a><a href></a></h3><p><strong><em>题目</em></strong></p>
<p><strong><em>题解</em></strong></p>
<h3 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">73. 矩阵置零</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</span><br><span class="line"></span><br><span class="line">原地算法是指不依赖额外的资源或者依赖少数的额外资源,仅依靠输出来覆盖输入的一种算法操作.</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">	输入: </span><br><span class="line">	[</span><br><span class="line">	  [1,1,1],</span><br><span class="line">	  [1,0,1],</span><br><span class="line">	  [1,1,1]</span><br><span class="line">	]</span><br><span class="line">	输出: </span><br><span class="line">	[</span><br><span class="line">	  [1,0,1],</span><br><span class="line">	  [0,0,0],</span><br><span class="line">	  [1,0,1]</span><br><span class="line">	]</span><br><span class="line">	</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">	输入: </span><br><span class="line">	[</span><br><span class="line">	  [0,1,2,0],</span><br><span class="line">	  [3,4,5,2],</span><br><span class="line">	  [1,3,1,5]</span><br><span class="line">	]</span><br><span class="line">	输出: </span><br><span class="line">	[</span><br><span class="line">	  [0,0,0,0],</span><br><span class="line">	  [0,4,5,0],</span><br><span class="line">	  [0,3,1,0]</span><br><span class="line">	]</span><br><span class="line">进阶:</span><br><span class="line">	一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。</span><br><span class="line">	一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。</span><br><span class="line">	你能想出一个常数空间的解决方案吗？</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>解析：这道题的难点在于，尽可能的少使用额外空间，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void setZeroes(int[][] matrix) &#123;</span><br><span class="line">        int row = matrix.length, col = matrix[0].length;</span><br><span class="line">		// 行列标记</span><br><span class="line">        boolean[]flag = new boolean[row+col];</span><br><span class="line">		</span><br><span class="line">		// 初始化标记</span><br><span class="line">        for(int i=0; i&lt;row; i++) &#123;</span><br><span class="line">            for(int j=0; j&lt;col; j++) &#123;</span><br><span class="line">                if(matrix[i][j]==0) &#123;</span><br><span class="line">                    flag[i]=true;</span><br><span class="line">                    flag[row+j]=true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		// 按照行标记更新数据</span><br><span class="line">        for(int i=0; i&lt;row; i++) &#123;</span><br><span class="line">            if(flag[i]) &#123;</span><br><span class="line">                for(int j=0; j&lt;col; j++) &#123;</span><br><span class="line">                    matrix[i][j]=0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		// 按照列标记更新数据</span><br><span class="line">        for(int j=row; j&lt;col+row; j++) &#123;</span><br><span class="line">            if(flag[j]) &#123;</span><br><span class="line">                for(int i=0; i&lt;row; i++) &#123;</span><br><span class="line">                    matrix[i][j-row]=0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. 搜索二维矩阵</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</span><br><span class="line"></span><br><span class="line">每行中的整数从左到右按升序排列。</span><br><span class="line">每行的第一个整数大于前一行的最后一个整数。</span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">	输入:</span><br><span class="line">	matrix = [</span><br><span class="line">	  [1,   3,  5,  7],</span><br><span class="line">	  [10, 11, 16, 20],</span><br><span class="line">	  [23, 30, 34, 50]</span><br><span class="line">	]</span><br><span class="line">	target = 3</span><br><span class="line">	输出: true</span><br><span class="line">	</span><br><span class="line">示例 2:</span><br><span class="line">	输入:</span><br><span class="line">	matrix = [</span><br><span class="line">	  [1,   3,  5,  7],</span><br><span class="line">	  [10, 11, 16, 20],</span><br><span class="line">	  [23, 30, 34, 50]</span><br><span class="line">	]</span><br><span class="line">	target = 13</span><br><span class="line">	输出: false</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>题解：<br>基于<code>每行的第一个整数大于前一行的最后一个整数</code>确定行数；基于<code>每行中的整数从左到右按升序排列</code>确定列数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean searchMatrix(int[][] matrix, int target) &#123;</span><br><span class="line">        if(matrix.length==0 || matrix[0].length==0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int row = matrix.length,col=matrix[0].length;</span><br><span class="line">        int i=0;</span><br><span class="line">        do &#123;</span><br><span class="line">            if(matrix[i][0]&lt;target) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else if( matrix[i][0]==target) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while(i&lt;row);</span><br><span class="line"></span><br><span class="line">        if(i!=0) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        for(int j=0; j&lt;col; j++) &#123;</span><br><span class="line">            if(matrix[i][j]==target) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">79. 单词搜索</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定一个二维网格和一个单词，找出该单词是否存在于网格中。</span><br><span class="line">单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">	board =</span><br><span class="line">	[</span><br><span class="line">	  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">	  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">	  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">	]</span><br><span class="line"></span><br><span class="line">	给定 word = &quot;ABCCED&quot;, 返回 true</span><br><span class="line">	给定 word = &quot;SEE&quot;, 返回 true</span><br><span class="line">	给定 word = &quot;ABCB&quot;, 返回 false</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>解析：</p>
<ul>
<li>暴力循环，找到每一个时候做起始字母的坐标</li>
<li>边界越界判定（i&lt;0||i&gt;=board.length||j&lt;0||j&gt;=board[0].length）</li>
<li>当前字母匹配判定（word.charAt(wt)!=board[i][j]）</li>
<li>防止字母重复使用（board[i][j]=’.’; board[i][j]=temp;）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">        if(board.length==0||board[0].length==0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int row=board.length,col=board[0].length;</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;row; i++) &#123;</span><br><span class="line">            for(int j=0; j&lt;col; j++) &#123;</span><br><span class="line">                if(test(board, i, j, word, 0)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean test(char[][] board, int i, int j, String word, int wt) &#123;</span><br><span class="line">        if(i&lt;0||i&gt;=board.length||j&lt;0||j&gt;=board[0].length||word.charAt(wt)!=board[i][j]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(word.length()-1==wt)</span><br><span class="line">            return true;</span><br><span class="line">        char temp = board[i][j];</span><br><span class="line">        </span><br><span class="line">        board[i][j]=&apos;.&apos;;</span><br><span class="line">        boolean flag = test(board, i-1, j, word, wt+1)||test(board, i+1, j, word, wt+1)||test(board, i, j-1, word, wt+1)||test(board, i, j+1, word, wt+1);</span><br><span class="line">        board[i][j]=temp;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="80-删除排序数组中的重复项-II"><a href="#80-删除排序数组中的重复项-II" class="headerlink" title="80. 删除排序数组中的重复项 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">80. 删除排序数组中的重复项 II</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</span><br><span class="line">不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">	给定 nums = [1,1,1,2,2,3],</span><br><span class="line">	函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</span><br><span class="line">	你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line">	</span><br><span class="line">示例 2:</span><br><span class="line">	给定 nums = [0,0,1,1,1,1,2,3,3],</span><br><span class="line">	函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。</span><br><span class="line">	你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">	为什么返回数值是整数，但输出的答案是数组呢?</span><br><span class="line">	请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">	你可以想象内部操作如下:</span><br><span class="line">	// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">	int len = removeDuplicates(nums);</span><br><span class="line">	// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">	// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">	for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">	    print(nums[i]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        int i=0,j=0;</span><br><span class="line">        for(; i&lt;nums.length; i++) &#123;</span><br><span class="line">            if(i&lt;2 || nums[i]!=nums[j-2]) &#123;</span><br><span class="line">                if(i != j) &#123;</span><br><span class="line">                    nums[j]=nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">假设按照升序排序的数组在预先未知的某个点上进行了旋转。</span><br><span class="line"></span><br><span class="line">( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</span><br><span class="line"></span><br><span class="line">编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums = [2,5,6,0,0,1,2], target = 0</span><br><span class="line">输出: true</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums = [2,5,6,0,0,1,2], target = 3</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">进阶:</span><br><span class="line"></span><br><span class="line">	这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。</span><br><span class="line">	这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<p>注意边界控制，由于是有序数组旋转的，可以分为左右两段，两段中值都是升序的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean search(int[] nums, int target) &#123;</span><br><span class="line">        int i=0, j=nums.length-1;</span><br><span class="line">        if(j&lt;0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        do &#123;</span><br><span class="line">            if(nums[i]==target||nums[j]==target) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if(nums[i]&gt;target &amp;&amp; nums[j]&lt;target||i==j) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(nums[i]&lt;target) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(nums[j]&gt;target) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; while(true);</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">输出: 1-&gt;2-&gt;5</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line">输出: 2-&gt;3</span><br></pre></td></tr></table></figure>

<p><strong><em>题解</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        if(head==null||head.next==null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode lf = head, temp=new ListNode(),rt;</span><br><span class="line">        while(lf!=null &amp;&amp; lf.next != null) &#123;</span><br><span class="line">            rt=lf.next;</span><br><span class="line">            if(rt.val != lf.val) &#123;</span><br><span class="line">                temp = lf;</span><br><span class="line">                lf=lf.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                while(rt.next!=null &amp;&amp; rt.val==rt.next.val ) &#123;</span><br><span class="line">                    rt=rt.next;</span><br><span class="line">                &#125;</span><br><span class="line">                if(lf == head) &#123;</span><br><span class="line">                    head = rt.next;</span><br><span class="line">                    lf = head;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    temp.next = rt.next;</span><br><span class="line">                    lf = temp.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="89-格雷编码"><a href="#89-格雷编码" class="headerlink" title="89. 格雷编码"></a><a href="https://leetcode-cn.com/problems/gray-code/" target="_blank" rel="noopener">89. 格雷编码</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</span><br><span class="line"></span><br><span class="line">给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。</span><br><span class="line"></span><br><span class="line">格雷编码序列必须以 0 开头。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 2</span><br><span class="line">输出: [0,1,3,2]</span><br><span class="line">解释:</span><br><span class="line">00 - 0</span><br><span class="line">01 - 1</span><br><span class="line">11 - 3</span><br><span class="line">10 - 2</span><br><span class="line"></span><br><span class="line">对于给定的 n，其格雷编码序列并不唯一。</span><br><span class="line">例如，[0,2,3,1] 也是一个有效的格雷编码序列。</span><br><span class="line"></span><br><span class="line">00 - 0</span><br><span class="line">10 - 2</span><br><span class="line">11 - 3</span><br><span class="line">01 - 1</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 0</span><br><span class="line">输出: [0]</span><br><span class="line">解释: 我们定义格雷编码序列必须以 0 开头。</span><br><span class="line">     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。</span><br><span class="line">     因此，当 n = 0 时，其格雷编码序列为 [0]。</span><br></pre></td></tr></table></figure>

<p><strong><em><a href="https://leetcode-cn.com/problems/gray-code/solution/gen-ju-ge-lei-ma-de-xing-zhi-by-powcai/" target="_blank" rel="noopener">题解</a></em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">根据格雷码的性质，利用动态规划的方法，通过镜像的原理求解。</span><br><span class="line">n=1,</span><br><span class="line">	0</span><br><span class="line">	1</span><br><span class="line">n=2(第一个和最后一个是镜像关系，第二个和倒数第二个是镜像关系),</span><br><span class="line">	00</span><br><span class="line">	01</span><br><span class="line">	10</span><br><span class="line">	11</span><br><span class="line">n=3,</span><br><span class="line">	000</span><br><span class="line">	001</span><br><span class="line">	010</span><br><span class="line">	011</span><br><span class="line">	100</span><br><span class="line">	101</span><br><span class="line">	110</span><br><span class="line">	111</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; grayCode(int n) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        res.add(0);</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = res.size() - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">                res.add(res.get(j) ^ (1 &lt;&lt; i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a></h3><p><strong><em>题目</em></strong></p>
<figure class="highlight plain"><figcaption><span>nums，返回该数组所有可能的子集（幂集）。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">说明：解集不能包含重复的子集。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong><em><a href="https://leetcode-cn.com/problems/subsets-ii/solution/javahui-su-suan-fa-shu-zu-pai-xu-tong-ceng-jian-zh/" target="_blank" rel="noopener">题解</a></em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    方法：回溯搜索算法 + 数组排序 + 同层剪枝</span><br><span class="line">    思路：使用回溯算法遍历决策树，穷举所有解，决策树的每个节点维护当前已选路径track/path和选择列表等信息</span><br><span class="line">          相比t078-子集（不包含重复元素），本题可能包含重复元素，若不进行剪枝处理，子集可能出现重复。</span><br><span class="line">          （1）数组排序：对原始数组进行排序，保证重复元素必相邻，方便后续剪枝</span><br><span class="line">          （2）同层剪枝：当决策树由【当前层】向【下一层】递归时，依次向路径中添加1个数组元素；</span><br><span class="line">                        同一层中，若向不同路径添加重复元素（排序后重复元素相邻），该枝干出现重复，需进行剪枝 → 跳过当次循环。</span><br><span class="line">    时间复杂度：</span><br><span class="line">    空间复杂度：</span><br><span class="line">    类似题目：t046-全排列、t077-组合、t078-子集（不包含重复元素）</span><br><span class="line">             【t040-组合总和II】（数组元素可能有重复，每个元素仅能选一次）</span><br><span class="line">    优化点：路径track/path可使用栈Stack，可方便使用压栈push()和出栈操作pop()。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    //结果集</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;</span><br><span class="line">        //特判</span><br><span class="line">        if(nums.length == 0) </span><br><span class="line">			return res;</span><br><span class="line">        //对数组元素进行排序，保证重复元素必相邻，方便后续剪枝</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        //记录已作选择（路径）</span><br><span class="line">        List&lt;Integer&gt; track = new ArrayList&lt;&gt;();</span><br><span class="line">        //调用回溯函数</span><br><span class="line">        backtrack(nums, 0, track);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //回溯函数</span><br><span class="line">    //路径：已作出的选择-track已包含的数组元素</span><br><span class="line">    //选择列表：当前可选择的数组元素（数组nums中start索引及之后的元素）</span><br><span class="line">    //结束条件：正向遍历至数组的末尾时</span><br><span class="line">    private void backtrack(int[] nums, int start, List&lt;Integer&gt; track) &#123;</span><br><span class="line">        //结果集中包含已选路径（部分子集），需对引用track进行拷贝</span><br><span class="line">        res.add(new ArrayList&lt;&gt;(track));</span><br><span class="line"></span><br><span class="line">        //遍历数组</span><br><span class="line">        //结束条件：i == nums.length时终止，遍历完全部数组元素</span><br><span class="line">        for(int i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            //同层剪枝：同一层的两条不同路径中加入的元素出现重复时（数组已排序） → 跳过当次循环</span><br><span class="line">            if(i &gt; start &amp;&amp; nums[i] == nums[i - 1])&#123;  // i-1元素的索引必须在start索引及之后位置，即i &gt;= start + 1;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //作出选择</span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            //递归调用回溯函数 → 进入决策树的下一层（第i + 1个数组元素）</span><br><span class="line">            backtrack(nums, i + 1, track);</span><br><span class="line">            //撤销选择</span><br><span class="line">            track.remove(track.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><blockquote><p>原文作者: 古城烟雨</p><p>原文链接: <a href="http://zws6672.top/2020/10/04/leetcode-20200927-20201004/">http://zws6672.top/2020/10/04/leetcode-20200927-20201004/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/leetcode/">leetcode</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/10/04/redis-5/" class="pre">redis（五）集群</a><a href="/2020/10/02/redis-4/" class="next">redis（四）数据类型相关命令</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#71-简化路径"><span class="toc-text">71. 简化路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78-子集"><span class="toc-text">78. 子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#200-岛屿数量"><span class="toc-text">200. 岛屿数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#207-课程表"><span class="toc-text">207. 课程表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#207-课程表-1"><span class="toc-text">207. 课程表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-字母异位词分组"><span class="toc-text">49. 字母异位词分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-螺旋矩阵-II"><span class="toc-text">59. 螺旋矩阵 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73-矩阵置零"><span class="toc-text">73. 矩阵置零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74-搜索二维矩阵"><span class="toc-text">74. 搜索二维矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79-单词搜索"><span class="toc-text">79. 单词搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#80-删除排序数组中的重复项-II"><span class="toc-text">80. 删除排序数组中的重复项 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#81-搜索旋转排序数组-II"><span class="toc-text">81. 搜索旋转排序数组 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#82-删除排序链表中的重复元素-II"><span class="toc-text">82. 删除排序链表中的重复元素 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#89-格雷编码"><span class="toc-text">89. 格雷编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#90-子集-II"><span class="toc-text">90. 子集 II</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/mysql-opt/">MySQL 优化(一)设计与功能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/tool-uml/">UML中关系</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/fmi-ssp-dcp/">了解fmi、ssp与dcp</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/16/hexo-sync/">多PC同步hexo</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/fmi-daccosim/">基于FMI标准的仿真软件————Daccosim</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/springboot-1/">springboot（一）入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/13/jdk-backend-compile/">后端编译与优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/13/jdk-front-compile/">前端编译与优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/26/jdk-bytecodeEngine/">虚拟机字节码执行引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/15/jdk-cload/">虚拟机类加载机制</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/devops/" style="font-size: 15px;">devops</a> <a href="/tags/CI/" style="font-size: 15px;">CI</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/neo4j/" style="font-size: 15px;">neo4j</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/oracle/" style="font-size: 15px;">oracle</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/系统/" style="font-size: 15px;">系统</a> <a href="/tags/博客搭建/" style="font-size: 15px;">博客搭建</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/ms/" style="font-size: 15px;">ms</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/运维/" style="font-size: 15px;">运维</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/javaweb/" style="font-size: 15px;">javaweb</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/elasticsearch/" style="font-size: 15px;">elasticsearch</a> <a href="/tags/fmi/" style="font-size: 15px;">fmi</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/微服务/" style="font-size: 15px;">微服务</a> <a href="/tags/soft-skills/" style="font-size: 15px;">soft-skills</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/nk/" style="font-size: 15px;">nk</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://juejin.im/" title="掘金" target="_blank">掘金</a><ul></ul><a href="https://www.cnblogs.com/" title="博客园" target="_blank">博客园</a><ul></ul><a href="https://www.infoq.cn/" title="info" target="_blank">info</a><ul></ul><a href="https://www.ibm.com/" title="ibm" target="_blank">ibm</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">古城烟雨.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>